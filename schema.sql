create database cos30049
    with owner superuser;

create type public.auction as enum ('dutch', 'english', 'min_price');

alter type public.auction owner to superuser;

create type public.tag as enum ('Classic', 'Electric', 'City Pop');

alter type public.tag owner to superuser;

create type public.genre as enum ('Anime', 'Classic', 'Angelic', 'Rock');

alter type public.genre owner to superuser;

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem is 'access control list';

-- Unknown how to generate base type type

comment on type pg_catalog.bit is 'fixed-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.bool is 'boolean, ''true''/''false''';

-- Unknown how to generate base type type

comment on type pg_catalog.box is 'geometric box ''(lower left,upper right)''';

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar is 'char(length), blank-padded string, fixed storage length';

-- Unknown how to generate base type type

comment on type pg_catalog.bytea is 'variable-length string, binary values escaped';

-- Unknown how to generate base type type

comment on type pg_catalog.char is 'single character';

-- Unknown how to generate base type type

comment on type pg_catalog.cid is 'command identifier type, sequence in transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.cidr is 'network IP address/netmask, network address';

-- Unknown how to generate base type type

comment on type pg_catalog.circle is 'geometric circle ''(center,radius)''';

-- Unknown how to generate base type type

comment on type pg_catalog.date is 'date';

-- Unknown how to generate base type type

comment on type pg_catalog.float4 is 'single-precision floating point number, 4-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.float8 is 'double-precision floating point number, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector is 'GiST index internal text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.inet is 'IP address/netmask, host address, netmask optional';

-- Unknown how to generate base type type

comment on type pg_catalog.int2 is '-32 thousand to 32 thousand, 2-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.int4 is '-2 billion to 2 billion integer, 4-byte storage';

create domain information_schema.cardinal_number as integer
    constraint cardinal_number_domain_check check (VALUE >= 0);

-- Unknown how to generate base type type

comment on type pg_catalog.int8 is '~18 digit integer, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.interval is '@ <number> <units>, time interval';

-- Unknown how to generate base type type

comment on type pg_catalog.json is 'JSON stored as text';

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb is 'Binary JSON';

-- Unknown how to generate base type type

comment on type pg_catalog.jsonpath is 'JSON path';

-- Unknown how to generate base type type

comment on type pg_catalog.line is 'geometric line';

-- Unknown how to generate base type type

comment on type pg_catalog.lseg is 'geometric line segment ''(pt1,pt2)''';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr is 'XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8 is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.money is 'monetary amounts, $d,ddd.cc';

-- Unknown how to generate base type type

comment on type pg_catalog.name is '63-byte type for storing system identifiers';

-- Unknown how to generate base type type

comment on type pg_catalog.numeric is 'numeric(precision, decimal), arbitrary precision number';

-- Unknown how to generate base type type

comment on type pg_catalog.oid is 'object identifier(oid), maximum 4 billion';

-- Unknown how to generate base type type

comment on type pg_catalog.path is 'geometric path ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_brin_bloom_summary is 'BRIN bloom summary';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_brin_minmax_multi_summary is 'BRIN minmax-multi summary';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies is 'multivariate dependencies';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn is 'PostgreSQL LSN datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_mcv_list is 'multivariate MCV list';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct is 'multivariate ndistinct coefficients';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree is 'string representing an internal node tree';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_snapshot is 'snapshot';

-- Unknown how to generate base type type

comment on type pg_catalog.point is 'geometric point ''(x, y)''';

-- Unknown how to generate base type type

comment on type pg_catalog.polygon is 'geometric polygon ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor is 'reference to cursor (portal name)';

-- Unknown how to generate base type type

comment on type pg_catalog.regclass is 'registered class';

-- Unknown how to generate base type type

comment on type pg_catalog.regcollation is 'registered collation';

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig is 'registered text search configuration';

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary is 'registered text search dictionary';

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace is 'registered namespace';

-- Unknown how to generate base type type

comment on type pg_catalog.regoper is 'registered operator';

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator is 'registered operator (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regproc is 'registered procedure';

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure is 'registered procedure (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regrole is 'registered role';

-- Unknown how to generate base type type

comment on type pg_catalog.regtype is 'registered type';

create domain information_schema.sql_identifier as name;

-- Unknown how to generate base type type

comment on type pg_catalog.text is 'variable-length string, no limit specified';

-- Unknown how to generate base type type

comment on type pg_catalog.tid is '(block, offset), physical location of tuple';

-- Unknown how to generate base type type

comment on type pg_catalog.time is 'time of day';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp is 'date and time';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz is 'date and time with time zone';

create domain information_schema.time_stamp as timestamp(2) with time zone
    default CURRENT_TIMESTAMP(2);

-- Unknown how to generate base type type

comment on type pg_catalog.timetz is 'time of day with time zone';

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery is 'query representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector is 'text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot is 'txid snapshot';

-- Unknown how to generate base type type

comment on type pg_catalog.uuid is 'UUID datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.varbit is 'variable-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.varchar is 'varchar(length), non-blank-padded string, variable storage length';

create domain information_schema.character_data as varchar;

-- Unknown how to generate base type type

comment on type pg_catalog.xid is 'transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.xid8 is 'full transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.xml is 'XML content';

create domain information_schema.yes_or_no as varchar(3)
    constraint yes_or_no_check check ((VALUE)::text = ANY
                                      ((ARRAY ['YES'::character varying, 'NO'::character varying])::text[]));

create table public.users
(
    user_id     serial
        primary key,
    username    varchar(255) not null,
    password    varchar(255) not null,
    email       varchar(255) not null,
    phone_num   varchar(255) not null,
    description varchar(255) not null,
    address     varchar(255) not null,
    language    varchar(255) not null,
    avatar_url  varchar(255) not null
);

alter table public.users
    owner to superuser;

create table public.music
(
    music_id    serial
        primary key,
    title       varchar(255) not null,
    description text,
    tag         genre,
    music_url   text,
    owner_id    integer
        references public.users,
    price       numeric      not null,
    picture_url text,
    author      varchar(255)
);

alter table public.music
    owner to superuser;

create table public.wallet
(
    wallet_id      serial
        primary key,
    user_id        integer
        references public.users,
    wallet_address varchar(255)                        not null
        unique,
    eth_balance    numeric   default 0                 not null,
    created_at     timestamp default CURRENT_TIMESTAMP not null
);

alter table public.wallet
    owner to superuser;

create table public.transactions
(
    transaction_id   serial
        primary key,
    buyer_id         integer
        references public.users,
    seller_id        integer
        references public.users,
    music_id         integer
        references public.music,
    token_id         varchar(255)                        not null,
    transaction_date timestamp default CURRENT_TIMESTAMP not null
);

alter table public.transactions
    owner to superuser;

create table public.likes
(
    like_id   serial
        primary key,
    user_id   integer
        references public.users,
    music_id  integer
        references public.music,
    timestamp timestamp default CURRENT_TIMESTAMP not null
);

alter table public.likes
    owner to superuser;

create table pg_catalog.pg_aggregate
(
    aggfnoid         unknown not null
        constraint pg_aggregate_fnoid_index
            primary key,
    aggkind          unknown not null,
    aggnumdirectargs unknown not null,
    aggtransfn       unknown not null,
    aggfinalfn       unknown not null,
    aggcombinefn     unknown not null,
    aggserialfn      unknown not null,
    aggdeserialfn    unknown not null,
    aggmtransfn      unknown not null,
    aggminvtransfn   unknown not null,
    aggmfinalfn      unknown not null,
    aggfinalextra    unknown not null,
    aggmfinalextra   unknown not null,
    aggfinalmodify   unknown not null,
    aggmfinalmodify  unknown not null,
    aggsortop        unknown not null,
    aggtranstype     unknown not null,
    aggtransspace    unknown not null,
    aggmtranstype    unknown not null,
    aggmtransspace   unknown not null,
    agginitval       unknown,
    aggminitval      unknown
);

create table pg_catalog.pg_am
(
    oid       unknown not null
        constraint pg_am_oid_index
            primary key,
    amname    unknown not null
        constraint pg_am_name_index
            unique,
    amhandler unknown not null,
    amtype    unknown not null
);

create table pg_catalog.pg_amop
(
    oid            unknown not null
        constraint pg_amop_oid_index
            primary key,
    amopfamily     unknown not null,
    amoplefttype   unknown not null,
    amoprighttype  unknown not null,
    amopstrategy   unknown not null,
    amoppurpose    unknown not null,
    amopopr        unknown not null,
    amopmethod     unknown not null,
    amopsortfamily unknown not null,
    constraint pg_amop_fam_strat_index
        unique (amopfamily, amoplefttype, amoprighttype, amopstrategy),
    constraint pg_amop_opr_fam_index
        unique (amopopr, amoppurpose, amopfamily)
);

create table pg_catalog.pg_amproc
(
    oid             unknown not null
        constraint pg_amproc_oid_index
            primary key,
    amprocfamily    unknown not null,
    amproclefttype  unknown not null,
    amprocrighttype unknown not null,
    amprocnum       unknown not null,
    amproc          unknown not null,
    constraint pg_amproc_fam_proc_index
        unique (amprocfamily, amproclefttype, amprocrighttype, amprocnum)
);

create table pg_catalog.pg_attrdef
(
    oid     unknown not null
        constraint pg_attrdef_oid_index
            primary key,
    adrelid unknown not null,
    adnum   unknown not null,
    adbin   unknown not null,
    constraint pg_attrdef_adrelid_adnum_index
        unique (adrelid, adnum)
);

create table pg_catalog.pg_attribute
(
    attrelid       unknown not null,
    attname        unknown not null,
    atttypid       unknown not null,
    attstattarget  unknown not null,
    attlen         unknown not null,
    attnum         unknown not null,
    attndims       unknown not null,
    attcacheoff    unknown not null,
    atttypmod      unknown not null,
    attbyval       unknown not null,
    attalign       unknown not null,
    attstorage     unknown not null,
    attcompression unknown not null,
    attnotnull     unknown not null,
    atthasdef      unknown not null,
    atthasmissing  unknown not null,
    attidentity    unknown not null,
    attgenerated   unknown not null,
    attisdropped   unknown not null,
    attislocal     unknown not null,
    attinhcount    unknown not null,
    attcollation   unknown not null,
    attacl         unknown,
    attoptions     unknown,
    attfdwoptions  unknown,
    attmissingval  unknown,
    constraint pg_attribute_relid_attnum_index
        primary key (attrelid, attnum),
    constraint pg_attribute_relid_attnam_index
        unique (attrelid, attname)
);

create table pg_catalog.pg_auth_members
(
    roleid       unknown not null,
    member       unknown not null,
    grantor      unknown not null,
    admin_option unknown not null,
    constraint pg_auth_members_role_member_index
        primary key (roleid, member),
    constraint pg_auth_members_member_role_index
        unique (member, roleid)
)
    tablespace pg_global;

create table pg_catalog.pg_authid
(
    oid            unknown not null
        constraint pg_authid_oid_index
            primary key,
    rolname        unknown not null
        constraint pg_authid_rolname_index
            unique,
    rolsuper       unknown not null,
    rolinherit     unknown not null,
    rolcreaterole  unknown not null,
    rolcreatedb    unknown not null,
    rolcanlogin    unknown not null,
    rolreplication unknown not null,
    rolbypassrls   unknown not null,
    rolconnlimit   unknown not null,
    rolpassword    unknown,
    rolvaliduntil  unknown
)
    tablespace pg_global;

create table pg_catalog.pg_cast
(
    oid         unknown not null
        constraint pg_cast_oid_index
            primary key,
    castsource  unknown not null,
    casttarget  unknown not null,
    castfunc    unknown not null,
    castcontext unknown not null,
    castmethod  unknown not null,
    constraint pg_cast_source_target_index
        unique (castsource, casttarget)
);

create table pg_catalog.pg_class
(
    oid                 unknown not null
        constraint pg_class_oid_index
            primary key,
    relname             unknown not null,
    relnamespace        unknown not null,
    reltype             unknown not null,
    reloftype           unknown not null,
    relowner            unknown not null,
    relam               unknown not null,
    relfilenode         unknown not null,
    reltablespace       unknown not null,
    relpages            unknown not null,
    reltuples           unknown not null,
    relallvisible       unknown not null,
    reltoastrelid       unknown not null,
    relhasindex         unknown not null,
    relisshared         unknown not null,
    relpersistence      unknown not null,
    relkind             unknown not null,
    relnatts            unknown not null,
    relchecks           unknown not null,
    relhasrules         unknown not null,
    relhastriggers      unknown not null,
    relhassubclass      unknown not null,
    relrowsecurity      unknown not null,
    relforcerowsecurity unknown not null,
    relispopulated      unknown not null,
    relreplident        unknown not null,
    relispartition      unknown not null,
    relrewrite          unknown not null,
    relfrozenxid        unknown not null,
    relminmxid          unknown not null,
    relacl              unknown,
    reloptions          unknown,
    relpartbound        unknown,
    constraint pg_class_relname_nsp_index
        unique (relname, relnamespace)
);

create index pg_class_tblspc_relfilenode_index
    on pg_catalog.pg_class (reltablespace, relfilenode);

create table pg_catalog.pg_collation
(
    oid                 unknown not null
        constraint pg_collation_oid_index
            primary key,
    collname            unknown not null,
    collnamespace       unknown not null,
    collowner           unknown not null,
    collprovider        unknown not null,
    collisdeterministic unknown not null,
    collencoding        unknown not null,
    collcollate         unknown not null,
    collctype           unknown not null,
    collversion         unknown,
    constraint pg_collation_name_enc_nsp_index
        unique (collname, collencoding, collnamespace)
);

create table pg_catalog.pg_constraint
(
    oid           unknown not null
        constraint pg_constraint_oid_index
            primary key,
    conname       unknown not null,
    connamespace  unknown not null,
    contype       unknown not null,
    condeferrable unknown not null,
    condeferred   unknown not null,
    convalidated  unknown not null,
    conrelid      unknown not null,
    contypid      unknown not null,
    conindid      unknown not null,
    conparentid   unknown not null,
    confrelid     unknown not null,
    confupdtype   unknown not null,
    confdeltype   unknown not null,
    confmatchtype unknown not null,
    conislocal    unknown not null,
    coninhcount   unknown not null,
    connoinherit  unknown not null,
    conkey        unknown,
    confkey       unknown,
    conpfeqop     unknown,
    conppeqop     unknown,
    conffeqop     unknown,
    conexclop     unknown,
    conbin        unknown,
    constraint pg_constraint_conrelid_contypid_conname_index
        unique (conrelid, contypid, conname)
);

create index pg_constraint_conname_nsp_index
    on pg_catalog.pg_constraint (conname collate "C", connamespace);

create index pg_constraint_conparentid_index
    on pg_catalog.pg_constraint (conparentid);

create index pg_constraint_contypid_index
    on pg_catalog.pg_constraint (contypid);

create table pg_catalog.pg_conversion
(
    oid            unknown not null
        constraint pg_conversion_oid_index
            primary key,
    conname        unknown not null,
    connamespace   unknown not null,
    conowner       unknown not null,
    conforencoding unknown not null,
    contoencoding  unknown not null,
    conproc        unknown not null,
    condefault     unknown not null,
    constraint pg_conversion_default_index
        unique (connamespace, conforencoding, contoencoding, oid),
    constraint pg_conversion_name_nsp_index
        unique (conname, connamespace)
);

create table pg_catalog.pg_database
(
    oid           unknown not null
        constraint pg_database_oid_index
            primary key,
    datname       unknown not null
        constraint pg_database_datname_index
            unique,
    datdba        unknown not null,
    encoding      unknown not null,
    datcollate    unknown not null,
    datctype      unknown not null,
    datistemplate unknown not null,
    datallowconn  unknown not null,
    datconnlimit  unknown not null,
    datlastsysoid unknown not null,
    datfrozenxid  unknown not null,
    datminmxid    unknown not null,
    dattablespace unknown not null,
    datacl        unknown
)
    tablespace pg_global;

create table pg_catalog.pg_db_role_setting
(
    setdatabase unknown not null,
    setrole     unknown not null,
    setconfig   unknown,
    constraint pg_db_role_setting_databaseid_rol_index
        primary key (setdatabase, setrole)
)
    tablespace pg_global;

create table pg_catalog.pg_default_acl
(
    oid             unknown not null
        constraint pg_default_acl_oid_index
            primary key,
    defaclrole      unknown not null,
    defaclnamespace unknown not null,
    defaclobjtype   unknown not null,
    defaclacl       unknown not null,
    constraint pg_default_acl_role_nsp_obj_index
        unique (defaclrole, defaclnamespace, defaclobjtype)
);

create table pg_catalog.pg_depend
(
    classid     unknown not null,
    objid       unknown not null,
    objsubid    unknown not null,
    refclassid  unknown not null,
    refobjid    unknown not null,
    refobjsubid unknown not null,
    deptype     unknown not null
);

create index pg_depend_depender_index
    on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
    on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

create table pg_catalog.pg_description
(
    objoid      unknown not null,
    classoid    unknown not null,
    objsubid    unknown not null,
    description unknown not null,
    constraint pg_description_o_c_o_index
        primary key (objoid, classoid, objsubid)
);

create table pg_catalog.pg_enum
(
    oid           unknown not null
        constraint pg_enum_oid_index
            primary key,
    enumtypid     unknown not null,
    enumsortorder unknown not null,
    enumlabel     unknown not null,
    constraint pg_enum_typid_label_index
        unique (enumtypid, enumlabel),
    constraint pg_enum_typid_sortorder_index
        unique (enumtypid, enumsortorder)
);

create table pg_catalog.pg_event_trigger
(
    oid        unknown not null
        constraint pg_event_trigger_oid_index
            primary key,
    evtname    unknown not null
        constraint pg_event_trigger_evtname_index
            unique,
    evtevent   unknown not null,
    evtowner   unknown not null,
    evtfoid    unknown not null,
    evtenabled unknown not null,
    evttags    unknown
);

create table pg_catalog.pg_extension
(
    oid            unknown not null
        constraint pg_extension_oid_index
            primary key,
    extname        unknown not null
        constraint pg_extension_name_index
            unique,
    extowner       unknown not null,
    extnamespace   unknown not null,
    extrelocatable unknown not null,
    extversion     unknown not null,
    extconfig      unknown,
    extcondition   unknown
);

create table pg_catalog.pg_foreign_data_wrapper
(
    oid          unknown not null
        constraint pg_foreign_data_wrapper_oid_index
            primary key,
    fdwname      unknown not null
        constraint pg_foreign_data_wrapper_name_index
            unique,
    fdwowner     unknown not null,
    fdwhandler   unknown not null,
    fdwvalidator unknown not null,
    fdwacl       unknown,
    fdwoptions   unknown
);

create table pg_catalog.pg_foreign_server
(
    oid        unknown not null
        constraint pg_foreign_server_oid_index
            primary key,
    srvname    unknown not null
        constraint pg_foreign_server_name_index
            unique,
    srvowner   unknown not null,
    srvfdw     unknown not null,
    srvtype    unknown,
    srvversion unknown,
    srvacl     unknown,
    srvoptions unknown
);

create table pg_catalog.pg_foreign_table
(
    ftrelid   unknown not null
        constraint pg_foreign_table_relid_index
            primary key,
    ftserver  unknown not null,
    ftoptions unknown
);

create table pg_catalog.pg_index
(
    indexrelid     unknown not null
        constraint pg_index_indexrelid_index
            primary key,
    indrelid       unknown not null,
    indnatts       unknown not null,
    indnkeyatts    unknown not null,
    indisunique    unknown not null,
    indisprimary   unknown not null,
    indisexclusion unknown not null,
    indimmediate   unknown not null,
    indisclustered unknown not null,
    indisvalid     unknown not null,
    indcheckxmin   unknown not null,
    indisready     unknown not null,
    indislive      unknown not null,
    indisreplident unknown not null,
    indkey         unknown not null,
    indcollation   unknown not null,
    indclass       unknown not null,
    indoption      unknown not null,
    indexprs       unknown,
    indpred        unknown
);

create index pg_index_indrelid_index
    on pg_catalog.pg_index (indrelid);

create table pg_catalog.pg_inherits
(
    inhrelid         unknown not null,
    inhparent        unknown not null,
    inhseqno         unknown not null,
    inhdetachpending unknown not null,
    constraint pg_inherits_relid_seqno_index
        primary key (inhrelid, inhseqno)
);

create index pg_inherits_parent_index
    on pg_catalog.pg_inherits (inhparent);

create table pg_catalog.pg_init_privs
(
    objoid    unknown not null,
    classoid  unknown not null,
    objsubid  unknown not null,
    privtype  unknown not null,
    initprivs unknown not null,
    constraint pg_init_privs_o_c_o_index
        primary key (objoid, classoid, objsubid)
);

create table pg_catalog.pg_language
(
    oid           unknown not null
        constraint pg_language_oid_index
            primary key,
    lanname       unknown not null
        constraint pg_language_name_index
            unique,
    lanowner      unknown not null,
    lanispl       unknown not null,
    lanpltrusted  unknown not null,
    lanplcallfoid unknown not null,
    laninline     unknown not null,
    lanvalidator  unknown not null,
    lanacl        unknown
);

create table pg_catalog.pg_largeobject
(
    loid   unknown not null,
    pageno unknown not null,
    data   unknown not null,
    constraint pg_largeobject_loid_pn_index
        primary key (loid, pageno)
);

create table pg_catalog.pg_largeobject_metadata
(
    oid      unknown not null
        constraint pg_largeobject_metadata_oid_index
            primary key,
    lomowner unknown not null,
    lomacl   unknown
);

create table pg_catalog.pg_namespace
(
    oid      unknown not null
        constraint pg_namespace_oid_index
            primary key,
    nspname  unknown not null
        constraint pg_namespace_nspname_index
            unique,
    nspowner unknown not null,
    nspacl   unknown
);

create table pg_catalog.pg_opclass
(
    oid          unknown not null
        constraint pg_opclass_oid_index
            primary key,
    opcmethod    unknown not null,
    opcname      unknown not null,
    opcnamespace unknown not null,
    opcowner     unknown not null,
    opcfamily    unknown not null,
    opcintype    unknown not null,
    opcdefault   unknown not null,
    opckeytype   unknown not null,
    constraint pg_opclass_am_name_nsp_index
        unique (opcmethod, opcname, opcnamespace)
);

create table pg_catalog.pg_operator
(
    oid          unknown not null
        constraint pg_operator_oid_index
            primary key,
    oprname      unknown not null,
    oprnamespace unknown not null,
    oprowner     unknown not null,
    oprkind      unknown not null,
    oprcanmerge  unknown not null,
    oprcanhash   unknown not null,
    oprleft      unknown not null,
    oprright     unknown not null,
    oprresult    unknown not null,
    oprcom       unknown not null,
    oprnegate    unknown not null,
    oprcode      unknown not null,
    oprrest      unknown not null,
    oprjoin      unknown not null,
    constraint pg_operator_oprname_l_r_n_index
        unique (oprname, oprleft, oprright, oprnamespace)
);

create table pg_catalog.pg_opfamily
(
    oid          unknown not null
        constraint pg_opfamily_oid_index
            primary key,
    opfmethod    unknown not null,
    opfname      unknown not null,
    opfnamespace unknown not null,
    opfowner     unknown not null,
    constraint pg_opfamily_am_name_nsp_index
        unique (opfmethod, opfname, opfnamespace)
);

create table pg_catalog.pg_partitioned_table
(
    partrelid     unknown not null
        constraint pg_partitioned_table_partrelid_index
            primary key,
    partstrat     unknown not null,
    partnatts     unknown not null,
    partdefid     unknown not null,
    partattrs     unknown not null,
    partclass     unknown not null,
    partcollation unknown not null,
    partexprs     unknown
);

create table pg_catalog.pg_policy
(
    oid           unknown not null
        constraint pg_policy_oid_index
            primary key,
    polname       unknown not null,
    polrelid      unknown not null,
    polcmd        unknown not null,
    polpermissive unknown not null,
    polroles      unknown not null,
    polqual       unknown,
    polwithcheck  unknown,
    constraint pg_policy_polrelid_polname_index
        unique (polrelid, polname)
);

create table pg_catalog.pg_proc
(
    oid             unknown not null
        constraint pg_proc_oid_index
            primary key,
    proname         unknown not null,
    pronamespace    unknown not null,
    proowner        unknown not null,
    prolang         unknown not null,
    procost         unknown not null,
    prorows         unknown not null,
    provariadic     unknown not null,
    prosupport      unknown not null,
    prokind         unknown not null,
    prosecdef       unknown not null,
    proleakproof    unknown not null,
    proisstrict     unknown not null,
    proretset       unknown not null,
    provolatile     unknown not null,
    proparallel     unknown not null,
    pronargs        unknown not null,
    pronargdefaults unknown not null,
    prorettype      unknown not null,
    proargtypes     unknown not null,
    proallargtypes  unknown,
    proargmodes     unknown,
    proargnames     unknown,
    proargdefaults  unknown,
    protrftypes     unknown,
    prosrc          unknown not null,
    probin          unknown,
    prosqlbody      unknown,
    proconfig       unknown,
    proacl          unknown,
    constraint pg_proc_proname_args_nsp_index
        unique (proname, proargtypes, pronamespace)
);

create table pg_catalog.pg_publication
(
    oid          unknown not null
        constraint pg_publication_oid_index
            primary key,
    pubname      unknown not null
        constraint pg_publication_pubname_index
            unique,
    pubowner     unknown not null,
    puballtables unknown not null,
    pubinsert    unknown not null,
    pubupdate    unknown not null,
    pubdelete    unknown not null,
    pubtruncate  unknown not null,
    pubviaroot   unknown not null
);

create table pg_catalog.pg_publication_rel
(
    oid     unknown not null
        constraint pg_publication_rel_oid_index
            primary key,
    prpubid unknown not null,
    prrelid unknown not null,
    constraint pg_publication_rel_prrelid_prpubid_index
        unique (prrelid, prpubid)
);

create table pg_catalog.pg_range
(
    rngtypid      unknown not null
        constraint pg_range_rngtypid_index
            primary key,
    rngsubtype    unknown not null,
    rngmultitypid unknown not null
        constraint pg_range_rngmultitypid_index
            unique,
    rngcollation  unknown not null,
    rngsubopc     unknown not null,
    rngcanonical  unknown not null,
    rngsubdiff    unknown not null
);

create table pg_catalog.pg_replication_origin
(
    roident unknown not null
        constraint pg_replication_origin_roiident_index
            primary key,
    roname  unknown not null
        constraint pg_replication_origin_roname_index
            unique
)
    tablespace pg_global;

create table pg_catalog.pg_rewrite
(
    oid        unknown not null
        constraint pg_rewrite_oid_index
            primary key,
    rulename   unknown not null,
    ev_class   unknown not null,
    ev_type    unknown not null,
    ev_enabled unknown not null,
    is_instead unknown not null,
    ev_qual    unknown not null,
    ev_action  unknown not null,
    constraint pg_rewrite_rel_rulename_index
        unique (ev_class, rulename)
);

create table pg_catalog.pg_seclabel
(
    objoid   unknown not null,
    classoid unknown not null,
    objsubid unknown not null,
    provider unknown not null,
    label    unknown not null,
    constraint pg_seclabel_object_index
        primary key (objoid, classoid, objsubid, provider)
);

create table pg_catalog.pg_sequence
(
    seqrelid     unknown not null
        constraint pg_sequence_seqrelid_index
            primary key,
    seqtypid     unknown not null,
    seqstart     unknown not null,
    seqincrement unknown not null,
    seqmax       unknown not null,
    seqmin       unknown not null,
    seqcache     unknown not null,
    seqcycle     unknown not null
);

create table pg_catalog.pg_shdepend
(
    dbid       unknown not null,
    classid    unknown not null,
    objid      unknown not null,
    objsubid   unknown not null,
    refclassid unknown not null,
    refobjid   unknown not null,
    deptype    unknown not null
)
    tablespace pg_global;

create index pg_shdepend_depender_index
    on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid)
    tablespace pg_global;

create index pg_shdepend_reference_index
    on pg_catalog.pg_shdepend (refclassid, refobjid)
    tablespace pg_global;

create table pg_catalog.pg_shdescription
(
    objoid      unknown not null,
    classoid    unknown not null,
    description unknown not null,
    constraint pg_shdescription_o_c_index
        primary key (objoid, classoid)
)
    tablespace pg_global;

create table pg_catalog.pg_shseclabel
(
    objoid   unknown not null,
    classoid unknown not null,
    provider unknown not null,
    label    unknown not null,
    constraint pg_shseclabel_object_index
        primary key (objoid, classoid, provider)
)
    tablespace pg_global;

create table pg_catalog.pg_statistic
(
    starelid    unknown not null,
    staattnum   unknown not null,
    stainherit  unknown not null,
    stanullfrac unknown not null,
    stawidth    unknown not null,
    stadistinct unknown not null,
    stakind1    unknown not null,
    stakind2    unknown not null,
    stakind3    unknown not null,
    stakind4    unknown not null,
    stakind5    unknown not null,
    staop1      unknown not null,
    staop2      unknown not null,
    staop3      unknown not null,
    staop4      unknown not null,
    staop5      unknown not null,
    stacoll1    unknown not null,
    stacoll2    unknown not null,
    stacoll3    unknown not null,
    stacoll4    unknown not null,
    stacoll5    unknown not null,
    stanumbers1 unknown,
    stanumbers2 unknown,
    stanumbers3 unknown,
    stanumbers4 unknown,
    stanumbers5 unknown,
    stavalues1  unknown,
    stavalues2  unknown,
    stavalues3  unknown,
    stavalues4  unknown,
    stavalues5  unknown,
    constraint pg_statistic_relid_att_inh_index
        primary key (starelid, staattnum, stainherit)
);

create table pg_catalog.pg_statistic_ext
(
    oid           unknown not null
        constraint pg_statistic_ext_oid_index
            primary key,
    stxrelid      unknown not null,
    stxname       unknown not null,
    stxnamespace  unknown not null,
    stxowner      unknown not null,
    stxstattarget unknown not null,
    stxkeys       unknown not null,
    stxkind       unknown not null,
    stxexprs      unknown,
    constraint pg_statistic_ext_name_index
        unique (stxname, stxnamespace)
);

create index pg_statistic_ext_relid_index
    on pg_catalog.pg_statistic_ext (stxrelid);

create table pg_catalog.pg_statistic_ext_data
(
    stxoid           unknown not null
        constraint pg_statistic_ext_data_stxoid_index
            primary key,
    stxdndistinct    unknown,
    stxddependencies unknown,
    stxdmcv          unknown,
    stxdexpr         unknown
);

create table pg_catalog.pg_subscription
(
    oid             unknown not null
        constraint pg_subscription_oid_index
            primary key,
    subdbid         unknown not null,
    subname         unknown not null,
    subowner        unknown not null,
    subenabled      unknown not null,
    subbinary       unknown not null,
    substream       unknown not null,
    subconninfo     unknown not null,
    subslotname     unknown,
    subsynccommit   unknown not null,
    subpublications unknown not null,
    constraint pg_subscription_subname_index
        unique (subdbid, subname)
)
    tablespace pg_global;

create table pg_catalog.pg_subscription_rel
(
    srsubid    unknown not null,
    srrelid    unknown not null,
    srsubstate unknown not null,
    srsublsn   unknown,
    constraint pg_subscription_rel_srrelid_srsubid_index
        primary key (srrelid, srsubid)
);

create table pg_catalog.pg_tablespace
(
    oid        unknown not null
        constraint pg_tablespace_oid_index
            primary key,
    spcname    unknown not null
        constraint pg_tablespace_spcname_index
            unique,
    spcowner   unknown not null,
    spcacl     unknown,
    spcoptions unknown
)
    tablespace pg_global;

create table pg_catalog.pg_transform
(
    oid        unknown not null
        constraint pg_transform_oid_index
            primary key,
    trftype    unknown not null,
    trflang    unknown not null,
    trffromsql unknown not null,
    trftosql   unknown not null,
    constraint pg_transform_type_lang_index
        unique (trftype, trflang)
);

create table pg_catalog.pg_trigger
(
    oid            unknown not null
        constraint pg_trigger_oid_index
            primary key,
    tgrelid        unknown not null,
    tgparentid     unknown not null,
    tgname         unknown not null,
    tgfoid         unknown not null,
    tgtype         unknown not null,
    tgenabled      unknown not null,
    tgisinternal   unknown not null,
    tgconstrrelid  unknown not null,
    tgconstrindid  unknown not null,
    tgconstraint   unknown not null,
    tgdeferrable   unknown not null,
    tginitdeferred unknown not null,
    tgnargs        unknown not null,
    tgattr         unknown not null,
    tgargs         unknown not null,
    tgqual         unknown,
    tgoldtable     unknown,
    tgnewtable     unknown,
    constraint pg_trigger_tgrelid_tgname_index
        unique (tgrelid, tgname)
);

create index pg_trigger_tgconstraint_index
    on pg_catalog.pg_trigger (tgconstraint);

create table pg_catalog.pg_ts_config
(
    oid          unknown not null
        constraint pg_ts_config_oid_index
            primary key,
    cfgname      unknown not null,
    cfgnamespace unknown not null,
    cfgowner     unknown not null,
    cfgparser    unknown not null,
    constraint pg_ts_config_cfgname_index
        unique (cfgname, cfgnamespace)
);

create table pg_catalog.pg_ts_config_map
(
    mapcfg       unknown not null,
    maptokentype unknown not null,
    mapseqno     unknown not null,
    mapdict      unknown not null,
    constraint pg_ts_config_map_index
        primary key (mapcfg, maptokentype, mapseqno)
);

create table pg_catalog.pg_ts_dict
(
    oid            unknown not null
        constraint pg_ts_dict_oid_index
            primary key,
    dictname       unknown not null,
    dictnamespace  unknown not null,
    dictowner      unknown not null,
    dicttemplate   unknown not null,
    dictinitoption unknown,
    constraint pg_ts_dict_dictname_index
        unique (dictname, dictnamespace)
);

create table pg_catalog.pg_ts_parser
(
    oid          unknown not null
        constraint pg_ts_parser_oid_index
            primary key,
    prsname      unknown not null,
    prsnamespace unknown not null,
    prsstart     unknown not null,
    prstoken     unknown not null,
    prsend       unknown not null,
    prsheadline  unknown not null,
    prslextype   unknown not null,
    constraint pg_ts_parser_prsname_index
        unique (prsname, prsnamespace)
);

create table pg_catalog.pg_ts_template
(
    oid           unknown not null
        constraint pg_ts_template_oid_index
            primary key,
    tmplname      unknown not null,
    tmplnamespace unknown not null,
    tmplinit      unknown not null,
    tmpllexize    unknown not null,
    constraint pg_ts_template_tmplname_index
        unique (tmplname, tmplnamespace)
);

create table pg_catalog.pg_type
(
    oid            unknown not null
        constraint pg_type_oid_index
            primary key,
    typname        unknown not null,
    typnamespace   unknown not null,
    typowner       unknown not null,
    typlen         unknown not null,
    typbyval       unknown not null,
    typtype        unknown not null,
    typcategory    unknown not null,
    typispreferred unknown not null,
    typisdefined   unknown not null,
    typdelim       unknown not null,
    typrelid       unknown not null,
    typsubscript   unknown not null,
    typelem        unknown not null,
    typarray       unknown not null,
    typinput       unknown not null,
    typoutput      unknown not null,
    typreceive     unknown not null,
    typsend        unknown not null,
    typmodin       unknown not null,
    typmodout      unknown not null,
    typanalyze     unknown not null,
    typalign       unknown not null,
    typstorage     unknown not null,
    typnotnull     unknown not null,
    typbasetype    unknown not null,
    typtypmod      unknown not null,
    typndims       unknown not null,
    typcollation   unknown not null,
    typdefaultbin  unknown,
    typdefault     unknown,
    typacl         unknown,
    constraint pg_type_typname_nsp_index
        unique (typname, typnamespace)
);

create table pg_catalog.pg_user_mapping
(
    oid       unknown not null
        constraint pg_user_mapping_oid_index
            primary key,
    umuser    unknown not null,
    umserver  unknown not null,
    umoptions unknown,
    constraint pg_user_mapping_user_server_index
        unique (umuser, umserver)
);

create table information_schema.sql_features
(
    feature_id       unknown,
    feature_name     unknown,
    sub_feature_id   unknown,
    sub_feature_name unknown,
    is_supported     unknown,
    is_verified_by   unknown,
    comments         unknown
);

create table information_schema.sql_implementation_info
(
    implementation_info_id   unknown,
    implementation_info_name unknown,
    integer_value            unknown,
    character_value          unknown,
    comments                 unknown
);

create table information_schema.sql_parts
(
    feature_id     unknown,
    feature_name   unknown,
    is_supported   unknown,
    is_verified_by unknown,
    comments       unknown
);

create table information_schema.sql_sizing
(
    sizing_id       unknown,
    sizing_name     unknown,
    supported_value unknown,
    comments        unknown
);

create view information_schema._pg_foreign_data_wrappers
            (oid, fdwowner, fdwoptions, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             authorization_identifier, foreign_data_wrapper_language)
as
-- missing source code
;

create view information_schema._pg_foreign_servers
            (oid, srvoptions, foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog,
             foreign_data_wrapper_name, foreign_server_type, foreign_server_version, authorization_identifier)
as
-- missing source code
;

create view information_schema._pg_foreign_table_columns(nspname, relname, attname, attfdwoptions) as
-- missing source code
;

create view information_schema._pg_foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog,
             foreign_server_name, authorization_identifier)
as
-- missing source code
;

create view information_schema._pg_user_mappings
            (oid, umoptions, umuser, authorization_identifier, foreign_server_catalog, foreign_server_name, srvowner) as
-- missing source code
;

create view information_schema.administrable_role_authorizations(grantee, role_name, is_grantable) as
-- missing source code
;

create view information_schema.applicable_roles(grantee, role_name, is_grantable) as
-- missing source code
;

create view information_schema.attributes
            (udt_catalog, udt_schema, udt_name, attribute_name, ordinal_position, attribute_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             attribute_udt_catalog, attribute_udt_schema, attribute_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, is_derived_reference_attribute)
as
-- missing source code
;

create view information_schema.character_sets
            (character_set_catalog, character_set_schema, character_set_name, character_repertoire, form_of_use,
             default_collate_catalog, default_collate_schema, default_collate_name)
as
-- missing source code
;

create view information_schema.check_constraint_routine_usage
            (constraint_catalog, constraint_schema, constraint_name, specific_catalog, specific_schema,
             specific_name) as
-- missing source code
;

create view information_schema.check_constraints(constraint_catalog, constraint_schema, constraint_name, check_clause) as
-- missing source code
;

create view information_schema.collation_character_set_applicability
            (collation_catalog, collation_schema, collation_name, character_set_catalog, character_set_schema,
             character_set_name) as
-- missing source code
;

create view information_schema.collations(collation_catalog, collation_schema, collation_name, pad_attribute) as
-- missing source code
;

create view information_schema.column_column_usage
            (table_catalog, table_schema, table_name, column_name, dependent_column) as
-- missing source code
;

create view information_schema.column_domain_usage
            (domain_catalog, domain_schema, domain_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.column_options
            (table_catalog, table_schema, table_name, column_name, option_name, option_value) as
-- missing source code
;

create view information_schema.column_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.column_udt_usage
            (udt_catalog, udt_schema, udt_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.columns
            (table_catalog, table_schema, table_name, column_name, ordinal_position, column_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix,
             numeric_scale, datetime_precision, interval_type, interval_precision, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema,
             scope_name, maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation,
             identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated,
             generation_expression, is_updatable)
as
-- missing source code
;

create view information_schema.constraint_column_usage
            (table_catalog, table_schema, table_name, column_name, constraint_catalog, constraint_schema,
             constraint_name) as
-- missing source code
;

create view information_schema.constraint_table_usage
            (table_catalog, table_schema, table_name, constraint_catalog, constraint_schema, constraint_name) as
-- missing source code
;

create view information_schema.data_type_privileges
            (object_catalog, object_schema, object_name, object_type, dtd_identifier) as
-- missing source code
;

create view information_schema.domain_constraints
            (constraint_catalog, constraint_schema, constraint_name, domain_catalog, domain_schema, domain_name,
             is_deferrable, initially_deferred)
as
-- missing source code
;

create view information_schema.domain_udt_usage
            (udt_catalog, udt_schema, udt_name, domain_catalog, domain_schema, domain_name) as
-- missing source code
;

create view information_schema.domains
            (domain_catalog, domain_schema, domain_name, data_type, character_maximum_length, character_octet_length,
             character_set_catalog, character_set_schema, character_set_name, collation_catalog, collation_schema,
             collation_name, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
             interval_type, interval_precision, domain_default, udt_catalog, udt_schema, udt_name, scope_catalog,
             scope_schema, scope_name, maximum_cardinality, dtd_identifier)
as
-- missing source code
;

create view information_schema.element_types
            (object_catalog, object_schema, object_name, object_type, collection_type_identifier, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             domain_default, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier)
as
-- missing source code
;

create view information_schema.enabled_roles(role_name) as
-- missing source code
;

create view information_schema.foreign_data_wrapper_options
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_data_wrappers
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, authorization_identifier, library_name,
             foreign_data_wrapper_language)
as
-- missing source code
;

create view information_schema.foreign_server_options
            (foreign_server_catalog, foreign_server_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_servers
            (foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             foreign_server_type, foreign_server_version, authorization_identifier)
as
-- missing source code
;

create view information_schema.foreign_table_options
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, foreign_server_catalog,
             foreign_server_name) as
-- missing source code
;

create view information_schema.information_schema_catalog_name(catalog_name) as
-- missing source code
;

create view information_schema.key_column_usage
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             column_name, ordinal_position, position_in_unique_constraint)
as
-- missing source code
;

create view information_schema.parameters
            (specific_catalog, specific_schema, specific_name, ordinal_position, parameter_mode, is_result, as_locator,
             parameter_name, data_type, character_maximum_length, character_octet_length, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type,
             interval_precision, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, parameter_default)
as
-- missing source code
;

create view pg_catalog.pg_available_extension_versions
            (name, version, installed, superuser, trusted, relocatable, schema, requires, comment) as
-- missing source code
;

create view pg_catalog.pg_available_extensions(name, default_version, installed_version, comment) as
-- missing source code
;

create view pg_catalog.pg_backend_memory_contexts
            (name, ident, parent, level, total_bytes, total_nblocks, free_bytes, free_chunks, used_bytes) as
-- missing source code
;

create view pg_catalog.pg_config(name, setting) as
-- missing source code
;

create view pg_catalog.pg_cursors(name, statement, is_holdable, is_binary, is_scrollable, creation_time) as
-- missing source code
;

create view pg_catalog.pg_file_settings(sourcefile, sourceline, seqno, name, setting, applied, error) as
-- missing source code
;

create view pg_catalog.pg_group(groname, grosysid, grolist) as
-- missing source code
;

create view pg_catalog.pg_hba_file_rules
            (line_number, type, database, user_name, address, netmask, auth_method, options, error) as
-- missing source code
;

create view pg_catalog.pg_indexes(schemaname, tablename, indexname, tablespace, indexdef) as
-- missing source code
;

create view pg_catalog.pg_locks
            (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
             virtualtransaction, pid, mode, granted, fastpath, waitstart)
as
-- missing source code
;

create view pg_catalog.pg_matviews
            (schemaname, matviewname, matviewowner, tablespace, hasindexes, ispopulated, definition) as
-- missing source code
;

create view pg_catalog.pg_policies (schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check) as
-- missing source code
;

create view pg_catalog.pg_prepared_statements
            (name, statement, prepare_time, parameter_types, from_sql, generic_plans, custom_plans) as
-- missing source code
;

create view pg_catalog.pg_prepared_xacts(transaction, gid, prepared, owner, database) as
-- missing source code
;

create view pg_catalog.pg_publication_tables(pubname, schemaname, tablename) as
-- missing source code
;

create view pg_catalog.pg_replication_origin_status(local_id, external_id, remote_lsn, local_lsn) as
-- missing source code
;

create view pg_catalog.pg_replication_slots
            (slot_name, plugin, slot_type, datoid, database, temporary, active, active_pid, xmin, catalog_xmin,
             restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase)
as
-- missing source code
;

create view pg_catalog.pg_roles
            (rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolconnlimit,
             rolpassword, rolvaliduntil, rolbypassrls, rolconfig, oid)
as
-- missing source code
;

create view pg_catalog.pg_rules(schemaname, tablename, rulename, definition) as
-- missing source code
;

create view pg_catalog.pg_seclabels (objoid, classoid, objsubid, objtype, objnamespace, objname, provider, label) as
-- missing source code
;

create view pg_catalog.pg_sequences
            (schemaname, sequencename, sequenceowner, data_type, start_value, min_value, max_value, increment_by, cycle,
             cache_size, last_value)
as
-- missing source code
;

create view pg_catalog.pg_settings
            (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val,
             enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart)
as
-- missing source code
;

create rule pg_catalog.pg_settings_n as
    on update to pg_catalog.pg_settings
    do instead -- missing source code
;

create rule pg_catalog.pg_settings_u as
    on update to pg_catalog.pg_settings
    do also -- missing source code
;

create view pg_catalog.pg_shadow
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
-- missing source code
;

create view pg_catalog.pg_shmem_allocations(name, "off", size, allocated_size) as
-- missing source code
;

create view pg_catalog.pg_stat_activity
            (datid, datname, pid, leader_pid, usesysid, usename, application_name, client_addr, client_hostname,
             client_port, backend_start, xact_start, query_start, state_change, wait_event_type, wait_event, state,
             backend_xid, backend_xmin, query_id, query, backend_type)
as
-- missing source code
;

create view pg_catalog.pg_stat_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_archiver
            (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time,
             stats_reset) as
-- missing source code
;

create view pg_catalog.pg_stat_bgwriter
            (checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time, buffers_checkpoint,
             buffers_clean, maxwritten_clean, buffers_backend, buffers_backend_fsync, buffers_alloc, stats_reset)
as
-- missing source code
;

create view pg_catalog.pg_stat_database
            (datid, datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit, tup_returned, tup_fetched,
             tup_inserted, tup_updated, tup_deleted, conflicts, temp_files, temp_bytes, deadlocks, checksum_failures,
             checksum_last_failure, blk_read_time, blk_write_time, session_time, active_time, idle_in_transaction_time,
             sessions, sessions_abandoned, sessions_fatal, sessions_killed, stats_reset)
as
-- missing source code
;

create view pg_catalog.pg_stat_database_conflicts
            (datid, datname, confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock) as
-- missing source code
;

create view pg_catalog.pg_stat_gssapi(pid, gss_authenticated, principal, encrypted) as
-- missing source code
;

create view pg_catalog.pg_stat_progress_analyze
            (pid, datid, datname, relid, phase, sample_blks_total, sample_blks_scanned, ext_stats_total,
             ext_stats_computed, child_tables_total, child_tables_done, current_child_table_relid)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_basebackup
            (pid, phase, backup_total, backup_streamed, tablespaces_total, tablespaces_streamed) as
-- missing source code
;

create view pg_catalog.pg_stat_progress_cluster
            (pid, datid, datname, relid, command, phase, cluster_index_relid, heap_tuples_scanned, heap_tuples_written,
             heap_blks_total, heap_blks_scanned, index_rebuild_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_copy
            (pid, datid, datname, relid, command, type, bytes_processed, bytes_total, tuples_processed,
             tuples_excluded) as
-- missing source code
;

create view pg_catalog.pg_stat_progress_create_index
            (pid, datid, datname, relid, index_relid, command, phase, lockers_total, lockers_done, current_locker_pid,
             blocks_total, blocks_done, tuples_total, tuples_done, partitions_total, partitions_done)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_vacuum
            (pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned, heap_blks_vacuumed,
             index_vacuum_count, max_dead_tuples, num_dead_tuples)
as
-- missing source code
;

create view pg_catalog.pg_stat_replication
            (pid, usesysid, usename, application_name, client_addr, client_hostname, client_port, backend_start,
             backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag,
             sync_priority, sync_state, reply_time)
as
-- missing source code
;

create view pg_catalog.pg_stat_replication_slots
            (slot_name, spill_txns, spill_count, spill_bytes, stream_txns, stream_count, stream_bytes, total_txns,
             total_bytes, stats_reset)
as
-- missing source code
;

create view pg_catalog.pg_stat_slru
            (name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset) as
-- missing source code
;

create view pg_catalog.pg_stat_ssl(pid, ssl, version, cipher, bits, client_dn, client_serial, issuer_dn) as
-- missing source code
;

create view pg_catalog.pg_stat_subscription
            (subid, subname, pid, relid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
             latest_end_time) as
-- missing source code
;

create view pg_catalog.pg_stat_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
-- missing source code
;

create view pg_catalog.pg_stat_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_wal
            (wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time, wal_sync_time,
             stats_reset) as
-- missing source code
;

create view pg_catalog.pg_stat_wal_receiver
            (pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli,
             last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host,
             sender_port, conninfo)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
-- missing source code
;

create view pg_catalog.pg_stat_xact_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_statio_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_all_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_all_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_statio_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_sys_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_sys_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_statio_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_user_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_user_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_stats
            (schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct, most_common_vals,
             most_common_freqs, histogram_bounds, correlation, most_common_elems, most_common_elem_freqs,
             elem_count_histogram)
as
-- missing source code
;

create view pg_catalog.pg_stats_ext
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, attnames, exprs, kinds,
             n_distinct, dependencies, most_common_vals, most_common_val_nulls, most_common_freqs,
             most_common_base_freqs)
as
-- missing source code
;

create view pg_catalog.pg_stats_ext_exprs
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, expr, null_frac,
             avg_width, n_distinct, most_common_vals, most_common_freqs, histogram_bounds, correlation,
             most_common_elems, most_common_elem_freqs, elem_count_histogram)
as
-- missing source code
;

create view pg_catalog.pg_tables
            (schemaname, tablename, tableowner, tablespace, hasindexes, hasrules, hastriggers, rowsecurity) as
-- missing source code
;

create view pg_catalog.pg_timezone_abbrevs(abbrev, utc_offset, is_dst) as
-- missing source code
;

create view pg_catalog.pg_timezone_names(name, abbrev, utc_offset, is_dst) as
-- missing source code
;

create view pg_catalog.pg_user
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
-- missing source code
;

create view pg_catalog.pg_user_mappings(umid, srvid, srvname, umuser, usename, umoptions) as
-- missing source code
;

create view pg_catalog.pg_views(schemaname, viewname, viewowner, definition) as
-- missing source code
;

create view information_schema.referential_constraints
            (constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog,
             unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule)
as
-- missing source code
;

create view information_schema.role_column_grants
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.role_routine_grants
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
-- missing source code
;

create view information_schema.role_table_grants
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
-- missing source code
;

create view information_schema.role_udt_grants
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.role_usage_grants
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.routine_column_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             table_catalog, table_schema, table_name, column_name)
as
-- missing source code
;

create view information_schema.routine_privileges
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
-- missing source code
;

create view information_schema.routine_routine_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name) as
-- missing source code
;

create view information_schema.routine_sequence_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             sequence_catalog, sequence_schema, sequence_name)
as
-- missing source code
;

create view information_schema.routine_table_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             table_catalog, table_schema, table_name)
as
-- missing source code
;

create view information_schema.routines
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             routine_type, module_catalog, module_schema, module_name, udt_catalog, udt_schema, udt_name, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             type_udt_catalog, type_udt_schema, type_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, routine_body, routine_definition, external_name, external_language,
             parameter_style, is_deterministic, sql_data_access, is_null_call, sql_path, schema_level_routine,
             max_dynamic_result_sets, is_user_defined_cast, is_implicitly_invocable, security_type,
             to_sql_specific_catalog, to_sql_specific_schema, to_sql_specific_name, as_locator, created, last_altered,
             new_savepoint_level, is_udt_dependent, result_cast_from_data_type, result_cast_as_locator,
             result_cast_char_max_length, result_cast_char_octet_length, result_cast_char_set_catalog,
             result_cast_char_set_schema, result_cast_char_set_name, result_cast_collation_catalog,
             result_cast_collation_schema, result_cast_collation_name, result_cast_numeric_precision,
             result_cast_numeric_precision_radix, result_cast_numeric_scale, result_cast_datetime_precision,
             result_cast_interval_type, result_cast_interval_precision, result_cast_type_udt_catalog,
             result_cast_type_udt_schema, result_cast_type_udt_name, result_cast_scope_catalog,
             result_cast_scope_schema, result_cast_scope_name, result_cast_maximum_cardinality,
             result_cast_dtd_identifier)
as
-- missing source code
;

create view information_schema.schemata
            (catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema,
             default_character_set_name, sql_path)
as
-- missing source code
;

create view information_schema.sequences
            (sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix,
             numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option)
as
-- missing source code
;

create view information_schema.table_constraints
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             constraint_type, is_deferrable, initially_deferred, enforced)
as
-- missing source code
;

create view information_schema.table_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
-- missing source code
;

create view information_schema.tables
            (table_catalog, table_schema, table_name, table_type, self_referencing_column_name, reference_generation,
             user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, is_insertable_into, is_typed,
             commit_action)
as
-- missing source code
;

create view information_schema.transforms
            (udt_catalog, udt_schema, udt_name, specific_catalog, specific_schema, specific_name, group_name,
             transform_type) as
-- missing source code
;

create view information_schema.triggered_update_columns
            (trigger_catalog, trigger_schema, trigger_name, event_object_catalog, event_object_schema,
             event_object_table, event_object_column)
as
-- missing source code
;

create view information_schema.triggers
            (trigger_catalog, trigger_schema, trigger_name, event_manipulation, event_object_catalog,
             event_object_schema, event_object_table, action_order, action_condition, action_statement,
             action_orientation, action_timing, action_reference_old_table, action_reference_new_table,
             action_reference_old_row, action_reference_new_row, created)
as
-- missing source code
;

create view information_schema.udt_privileges
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.usage_privileges
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.user_defined_types
            (user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, user_defined_type_category,
             is_instantiable, is_final, ordering_form, ordering_category, ordering_routine_catalog,
             ordering_routine_schema, ordering_routine_name, reference_type, data_type, character_maximum_length,
             character_octet_length, character_set_catalog, character_set_schema, character_set_name, collation_catalog,
             collation_schema, collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
             datetime_precision, interval_type, interval_precision, source_dtd_identifier, ref_dtd_identifier)
as
-- missing source code
;

create view information_schema.user_mapping_options
            (authorization_identifier, foreign_server_catalog, foreign_server_name, option_name, option_value) as
-- missing source code
;

create view information_schema.user_mappings(authorization_identifier, foreign_server_catalog, foreign_server_name) as
-- missing source code
;

create view information_schema.view_column_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.view_routine_usage
            (table_catalog, table_schema, table_name, specific_catalog, specific_schema, specific_name) as
-- missing source code
;

create view information_schema.view_table_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name) as
-- missing source code
;

create view information_schema.views
            (table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into,
             is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into)
as
-- missing source code
;

create function pg_catalog."RI_FKey_cascade_del"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_del"() is 'referential integrity ON DELETE CASCADE';

create function pg_catalog."RI_FKey_cascade_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_upd"() is 'referential integrity ON UPDATE CASCADE';

create function pg_catalog."RI_FKey_check_ins"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_ins"() is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_check_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_upd"() is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_noaction_del"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_del"() is 'referential integrity ON DELETE NO ACTION';

create function pg_catalog."RI_FKey_noaction_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_upd"() is 'referential integrity ON UPDATE NO ACTION';

create function pg_catalog."RI_FKey_restrict_del"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_del"() is 'referential integrity ON DELETE RESTRICT';

create function pg_catalog."RI_FKey_restrict_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_upd"() is 'referential integrity ON UPDATE RESTRICT';

create function pg_catalog."RI_FKey_setdefault_del"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_del"() is 'referential integrity ON DELETE SET DEFAULT';

create function pg_catalog."RI_FKey_setdefault_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_upd"() is 'referential integrity ON UPDATE SET DEFAULT';

create function pg_catalog."RI_FKey_setnull_del"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_del"() is 'referential integrity ON DELETE SET NULL';

create function pg_catalog."RI_FKey_setnull_upd"() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_upd"() is 'referential integrity ON UPDATE SET NULL';

create function information_schema._pg_char_max_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_char_octet_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_datetime_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer) returns SETOF record
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_index_position(oid, smallint) returns integer
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_interval_type(typid oid, mod integer) returns text
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_precision_radix(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_scale(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_truetypid(pg_attribute, pg_type) returns oid
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function information_schema._pg_truetypmod(pg_attribute, pg_type) returns integer
    immutable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

create function pg_catalog.aclcontains(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclcontains(unknown, unknown) is 'contains';

create function pg_catalog.acldefault(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acldefault(unknown, unknown) is 'show hardwired default privileges, primarily for use by the information schema';

create function pg_catalog.aclexplode(acl unknown, out grantor unknown, out grantee unknown, out privilege_type unknown, out is_grantable unknown) returns setof unknown
    stable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclexplode(unknown, out unknown, out unknown, out unknown, out unknown) is 'convert ACL item array to table, primarily for use by information schema';

create function pg_catalog.aclinsert(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclinsert(unknown, unknown) is 'add/update ACL item';

create function pg_catalog.aclitemeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemeq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.aclitemin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemin(unknown) is 'I/O';

create function pg_catalog.aclitemout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemout(unknown) is 'I/O';

create function pg_catalog.aclremove(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclremove(unknown, unknown) is 'remove ACL item';

create function pg_catalog.acos(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acos(unknown) is 'arccosine';

create function pg_catalog.acosd(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosd(unknown) is 'arccosine, degrees';

create function pg_catalog.acosh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosh(unknown) is 'inverse hyperbolic cosine';

create function pg_catalog.amvalidate(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.amvalidate(unknown) is 'validate an operator class';

create function pg_catalog.any_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_in(unknown) is 'I/O';

create function pg_catalog.any_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_out(unknown) is 'I/O';

create function pg_catalog.anyarray_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_in(unknown) is 'I/O';

create function pg_catalog.anyarray_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_out(unknown) is 'I/O';

create function pg_catalog.anyarray_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_recv(unknown) is 'I/O';

create function pg_catalog.anyarray_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_send(unknown) is 'I/O';

create function pg_catalog.anycompatible_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_in(unknown) is 'I/O';

create function pg_catalog.anycompatible_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_out(unknown) is 'I/O';

create function pg_catalog.anycompatiblearray_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_in(unknown) is 'I/O';

create function pg_catalog.anycompatiblearray_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_out(unknown) is 'I/O';

create function pg_catalog.anycompatiblearray_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_recv(unknown) is 'I/O';

create function pg_catalog.anycompatiblearray_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_send(unknown) is 'I/O';

create function pg_catalog.anycompatiblemultirange_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblemultirange_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.anycompatiblemultirange_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblemultirange_out(unknown) is 'I/O';

create function pg_catalog.anycompatiblenonarray_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_in(unknown) is 'I/O';

create function pg_catalog.anycompatiblenonarray_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_out(unknown) is 'I/O';

create function pg_catalog.anycompatiblerange_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.anycompatiblerange_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_out(unknown) is 'I/O';

create function pg_catalog.anyelement_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_in(unknown) is 'I/O';

create function pg_catalog.anyelement_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_out(unknown) is 'I/O';

create function pg_catalog.anyenum_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_in(unknown) is 'I/O';

create function pg_catalog.anyenum_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_out(unknown) is 'I/O';

create function pg_catalog.anymultirange_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anymultirange_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.anymultirange_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anymultirange_out(unknown) is 'I/O';

create function pg_catalog.anynonarray_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_in(unknown) is 'I/O';

create function pg_catalog.anynonarray_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_out(unknown) is 'I/O';

create function pg_catalog.anyrange_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.anyrange_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_out(unknown) is 'I/O';

create function pg_catalog.anytextcat(anynonarray, text) returns text
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.anytextcat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.areajoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areajoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for area-comparison operators';

create function pg_catalog.areasel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areasel(unknown, unknown, unknown, unknown) is 'restriction selectivity for area-comparison operators';

create function pg_catalog.array_agg_array_finalfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_finalfn(unknown, unknown) is 'aggregate final function';

create function pg_catalog.array_agg_array_transfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_transfn(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.array_agg_finalfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_finalfn(unknown, unknown) is 'aggregate final function';

create function pg_catalog.array_agg_transfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_transfn(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.array_append(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_append(unknown, unknown) is 'append element onto end of array';

create function pg_catalog.array_cat(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_cat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.array_dims(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_dims(unknown) is 'array dimensions';

create function pg_catalog.array_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.array_fill(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(unknown, unknown) is 'array constructor with value';

create function pg_catalog.array_fill(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(unknown, unknown, unknown) is 'array constructor with value';

create function pg_catalog.array_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.array_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.array_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.array_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.array_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.array_length(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_length(unknown, unknown) is 'array length';

create function pg_catalog.array_lower(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lower(unknown, unknown) is 'array lower dimension';

create function pg_catalog.array_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.array_ndims(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ndims(unknown) is 'number of array dimensions';

create function pg_catalog.array_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.array_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_out(unknown) is 'I/O';

create function pg_catalog.array_position(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(unknown, unknown) is 'returns an offset of value in array';

create function pg_catalog.array_position(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(unknown, unknown, unknown) is 'returns an offset of value in array with start index';

create function pg_catalog.array_positions(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_positions(unknown, unknown) is 'returns an array of offsets of some value in array';

create function pg_catalog.array_prepend(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_prepend(unknown, unknown) is 'prepend element onto front of array';

create function pg_catalog.array_recv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.array_remove(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_remove(unknown, unknown) is 'remove any occurrences of an element from an array';

create function pg_catalog.array_replace(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_replace(unknown, unknown, unknown) is 'replace any occurrences of an element in an array';

create function pg_catalog.array_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_send(unknown) is 'I/O';

create function pg_catalog.array_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.array_subscript_handler(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_subscript_handler(unknown) is 'standard array subscripting support';

create function pg_catalog.array_to_json(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(unknown) is 'map array to json';

create function pg_catalog.array_to_json(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(unknown, unknown) is 'map array to json with optional pretty printing';

create function pg_catalog.array_to_string(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(unknown, unknown) is 'concatenate array elements, using delimiter, into text';

create function pg_catalog.array_to_string(unknown, unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(unknown, unknown, unknown) is 'concatenate array elements, using delimiter and null string, into text';

create function pg_catalog.array_to_tsvector(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_tsvector(unknown) is 'build tsvector from array of lexemes';

create function pg_catalog.array_typanalyze(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_typanalyze(unknown) is 'array typanalyze';

create function pg_catalog.array_unnest_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_unnest_support(unknown) is 'planner support for array_unnest';

create function pg_catalog.array_upper(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_upper(unknown, unknown) is 'array upper dimension';

create function pg_catalog.arraycontained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.arraycontains(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontains(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.arraycontjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for array-containment operators';

create function pg_catalog.arraycontsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontsel(unknown, unknown, unknown, unknown) is 'restriction selectivity for array-containment operators';

create function pg_catalog.arrayoverlap(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arrayoverlap(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.ascii(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii(unknown) is 'convert first char to int4';

create function pg_catalog.asin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asin(unknown) is 'arcsine';

create function pg_catalog.asind(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asind(unknown) is 'arcsine, degrees';

create function pg_catalog.asinh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asinh(unknown) is 'inverse hyperbolic sine';

create function pg_catalog.atan(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan(unknown) is 'arctangent';

create function pg_catalog.atan2(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2(unknown, unknown) is 'arctangent, two arguments';

create function pg_catalog.atan2d(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2d(unknown, unknown) is 'arctangent, two arguments, degrees';

create function pg_catalog.atand(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atand(unknown) is 'arctangent, degrees';

create function pg_catalog.atanh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atanh(unknown) is 'inverse hyperbolic tangent';

create function pg_catalog.bernoulli(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bernoulli(unknown) is 'BERNOULLI tablesample method handler';

create function pg_catalog.big5_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for BIG5 to EUC_TW';

create function pg_catalog.big5_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for BIG5 to MULE_INTERNAL';

create function pg_catalog.big5_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for BIG5 to UTF8';

create function pg_catalog.binary_upgrade_create_empty_extension(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_create_empty_extension(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_missing_value(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_missing_value(unknown, unknown, unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_multirange_array_pg_type_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_multirange_array_pg_type_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_multirange_pg_type_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_multirange_pg_type_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(unknown) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_record_init_privs(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(unknown) is 'for use by pg_upgrade';

create function pg_catalog.bit(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(unknown, unknown, unknown) is 'adjust bit() to typmod length';

create function pg_catalog.bit_in(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.bit_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_out(unknown) is 'I/O';

create function pg_catalog.bit_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.bit_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_send(unknown) is 'I/O';

create function pg_catalog.bitand(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitand(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.bitcat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.bitcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.biteq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.biteq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.bitge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.bitgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.bitle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.bitlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.bitne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.bitnot(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitnot(unknown) is 'implementation of ~ operator';

create function pg_catalog.bitor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitor(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.bitshiftleft(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftleft(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.bitshiftright(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftright(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.bittypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodin(unknown) is 'I/O typmod';

create function pg_catalog.bittypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodout(unknown) is 'I/O typmod';

create function pg_catalog.bitxor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitxor(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.bool_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.bool_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.bool_alltrue(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_alltrue(unknown) is 'aggregate final function';

create function pg_catalog.bool_anytrue(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_anytrue(unknown) is 'aggregate final function';

create function pg_catalog.booland_statefunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booland_statefunc(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.booleq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booleq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.boolge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.boolgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.boolin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolin(unknown) is 'I/O';

create function pg_catalog.boolle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.boollt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boollt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.boolne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.boolor_statefunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolor_statefunc(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.boolout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolout(unknown) is 'I/O';

create function pg_catalog.boolrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolrecv(unknown) is 'I/O';

create function pg_catalog.boolsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolsend(unknown) is 'I/O';

create function pg_catalog.bound_box(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bound_box(unknown, unknown) is 'bounding box of two boxes';

create function pg_catalog.box(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(unknown, unknown) is 'convert points to box';

create function pg_catalog.box_above(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above(unknown, unknown) is 'implementation of |>> operator';

create function pg_catalog.box_above_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above_eq(unknown, unknown) is 'implementation of >^ operator';

create function pg_catalog.box_add(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_add(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.box_below(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below(unknown, unknown) is 'implementation of <<| operator';

create function pg_catalog.box_below_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below_eq(unknown, unknown) is 'implementation of <^ operator';

create function pg_catalog.box_center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_center(unknown) is 'implementation of @@ operator';

create function pg_catalog.box_contain(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.box_contain_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain_pt(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.box_contained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.box_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.box_div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.box_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.box_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.box_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.box_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_in(unknown) is 'I/O';

create function pg_catalog.box_intersect(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_intersect(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.box_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.box_left(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_left(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.box_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.box_mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.box_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_out(unknown) is 'I/O';

create function pg_catalog.box_overabove(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overabove(unknown, unknown) is 'implementation of |&> operator';

create function pg_catalog.box_overbelow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overbelow(unknown, unknown) is 'implementation of &<| operator';

create function pg_catalog.box_overlap(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overlap(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.box_overleft(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overleft(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.box_overright(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overright(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.box_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_recv(unknown) is 'I/O';

create function pg_catalog.box_right(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_right(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.box_same(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_same(unknown, unknown) is 'implementation of ~= operator';

create function pg_catalog.box_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_send(unknown) is 'I/O';

create function pg_catalog.box_sub(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_sub(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.bpchar(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(unknown, unknown, unknown) is 'adjust char() to typmod length';

create function pg_catalog.bpchar_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.bpchar_pattern_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_ge(unknown, unknown) is 'implementation of ~>=~ operator';

create function pg_catalog.bpchar_pattern_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_gt(unknown, unknown) is 'implementation of ~>~ operator';

create function pg_catalog.bpchar_pattern_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_le(unknown, unknown) is 'implementation of ~<=~ operator';

create function pg_catalog.bpchar_pattern_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_lt(unknown, unknown) is 'implementation of ~<~ operator';

create function pg_catalog.bpchar_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.bpchar_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_sortsupport(unknown) is 'sort support';

create function pg_catalog.bpcharcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.bpchareq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchareq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.bpcharge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.bpchargt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchargt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.bpchariclike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchariclike(unknown, unknown) is 'implementation of ~~* operator';

create function pg_catalog.bpcharicnlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicnlike(unknown, unknown) is 'implementation of !~~* operator';

create function pg_catalog.bpcharicregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexeq(unknown, unknown) is 'implementation of ~* operator';

create function pg_catalog.bpcharicregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexne(unknown, unknown) is 'implementation of !~* operator';

create function pg_catalog.bpcharin(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharin(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.bpcharle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.bpcharlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlike(unknown, unknown) is 'implementation of ~~ operator';

create function pg_catalog.bpcharlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.bpcharne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.bpcharnlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharnlike(unknown, unknown) is 'implementation of !~~ operator';

create function pg_catalog.bpcharout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharout(unknown) is 'I/O';

create function pg_catalog.bpcharrecv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharrecv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.bpcharregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexeq(unknown, unknown) is 'implementation of ~ operator';

create function pg_catalog.bpcharregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexne(unknown, unknown) is 'implementation of !~ operator';

create function pg_catalog.bpcharsend(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharsend(unknown) is 'I/O';

create function pg_catalog.bpchartypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodin(unknown) is 'I/O typmod';

create function pg_catalog.bpchartypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodout(unknown) is 'I/O typmod';

create function pg_catalog.brin_bloom_add_value(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_add_value(unknown, unknown, unknown, unknown) is 'BRIN bloom support';

create function pg_catalog.brin_bloom_consistent(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_consistent(unknown, unknown, unknown, unknown) is 'BRIN bloom support';

create function pg_catalog.brin_bloom_opcinfo(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_opcinfo(unknown) is 'BRIN bloom support';

create function pg_catalog.brin_bloom_options(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_options(unknown) is 'BRIN bloom support';

create function pg_catalog.brin_bloom_summary_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_in(unknown) is 'I/O';

create function pg_catalog.brin_bloom_summary_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_out(unknown) is 'I/O';

create function pg_catalog.brin_bloom_summary_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_recv(unknown) is 'I/O';

create function pg_catalog.brin_bloom_summary_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_send(unknown) is 'I/O';

create function pg_catalog.brin_bloom_union(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_union(unknown, unknown, unknown) is 'BRIN bloom support';

create function pg_catalog.brin_desummarize_range(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_desummarize_range(unknown, unknown) is 'brin: desummarize page range';

create function pg_catalog.brin_inclusion_add_value(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_add_value(unknown, unknown, unknown, unknown) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_consistent(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_consistent(unknown, unknown, unknown) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_opcinfo(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_opcinfo(unknown) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_union(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_union(unknown, unknown, unknown) is 'BRIN inclusion support';

create function pg_catalog.brin_minmax_add_value(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_add_value(unknown, unknown, unknown, unknown) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_consistent(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_consistent(unknown, unknown, unknown) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_multi_add_value(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_add_value(unknown, unknown, unknown, unknown) is 'BRIN multi minmax support';

create function pg_catalog.brin_minmax_multi_consistent(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_consistent(unknown, unknown, unknown, unknown) is 'BRIN multi minmax support';

create function pg_catalog.brin_minmax_multi_distance_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_date(unknown, unknown) is 'BRIN multi minmax date distance';

create function pg_catalog.brin_minmax_multi_distance_float4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_float4(unknown, unknown) is 'BRIN multi minmax float4 distance';

create function pg_catalog.brin_minmax_multi_distance_float8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_float8(unknown, unknown) is 'BRIN multi minmax float8 distance';

create function pg_catalog.brin_minmax_multi_distance_inet(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_inet(unknown, unknown) is 'BRIN multi minmax inet distance';

create function pg_catalog.brin_minmax_multi_distance_int2(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int2(unknown, unknown) is 'BRIN multi minmax int2 distance';

create function pg_catalog.brin_minmax_multi_distance_int4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int4(unknown, unknown) is 'BRIN multi minmax int4 distance';

create function pg_catalog.brin_minmax_multi_distance_int8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int8(unknown, unknown) is 'BRIN multi minmax int8 distance';

create function pg_catalog.brin_minmax_multi_distance_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_interval(unknown, unknown) is 'BRIN multi minmax interval distance';

create function pg_catalog.brin_minmax_multi_distance_macaddr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_macaddr(unknown, unknown) is 'BRIN multi minmax macaddr distance';

create function pg_catalog.brin_minmax_multi_distance_macaddr8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_macaddr8(unknown, unknown) is 'BRIN multi minmax macaddr8 distance';

create function pg_catalog.brin_minmax_multi_distance_numeric(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_numeric(unknown, unknown) is 'BRIN multi minmax numeric distance';

create function pg_catalog.brin_minmax_multi_distance_pg_lsn(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_pg_lsn(unknown, unknown) is 'BRIN multi minmax pg_lsn distance';

create function pg_catalog.brin_minmax_multi_distance_tid(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_tid(unknown, unknown) is 'BRIN multi minmax tid distance';

create function pg_catalog.brin_minmax_multi_distance_time(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_time(unknown, unknown) is 'BRIN multi minmax time distance';

create function pg_catalog.brin_minmax_multi_distance_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_timestamp(unknown, unknown) is 'BRIN multi minmax timestamp distance';

create function pg_catalog.brin_minmax_multi_distance_timetz(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_timetz(unknown, unknown) is 'BRIN multi minmax timetz distance';

create function pg_catalog.brin_minmax_multi_distance_uuid(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_uuid(unknown, unknown) is 'BRIN multi minmax uuid distance';

create function pg_catalog.brin_minmax_multi_opcinfo(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_opcinfo(unknown) is 'BRIN multi minmax support';

create function pg_catalog.brin_minmax_multi_options(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_options(unknown) is 'BRIN multi minmax support';

create function pg_catalog.brin_minmax_multi_summary_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_in(unknown) is 'I/O';

create function pg_catalog.brin_minmax_multi_summary_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_out(unknown) is 'I/O';

create function pg_catalog.brin_minmax_multi_summary_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_recv(unknown) is 'I/O';

create function pg_catalog.brin_minmax_multi_summary_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_send(unknown) is 'I/O';

create function pg_catalog.brin_minmax_multi_union(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_union(unknown, unknown, unknown) is 'BRIN multi minmax support';

create function pg_catalog.brin_minmax_opcinfo(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_opcinfo(unknown) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_union(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_union(unknown, unknown, unknown) is 'BRIN minmax support';

create function pg_catalog.brin_summarize_new_values(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_new_values(unknown) is 'brin: standalone scan new table pages';

create function pg_catalog.brin_summarize_range(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_range(unknown, unknown) is 'brin: standalone scan new table pages';

create function pg_catalog.brinhandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brinhandler(unknown) is 'brin index access method handler';

create function pg_catalog.broadcast(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.broadcast(unknown) is 'broadcast address of network';

create function pg_catalog.btarraycmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btarraycmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btboolcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btboolcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btbpchar_pattern_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btbpchar_pattern_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_sortsupport(unknown) is 'sort support';

create function pg_catalog.btcharcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btcharcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btequalimage(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btequalimage(unknown) is 'equal image';

create function pg_catalog.btfloat48cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat48cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btfloat4cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btfloat4sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4sortsupport(unknown) is 'sort support';

create function pg_catalog.btfloat84cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat84cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btfloat8cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btfloat8sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8sortsupport(unknown) is 'sort support';

create function pg_catalog.bthandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bthandler(unknown) is 'btree index access method handler';

create function pg_catalog.btint24cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint24cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint28cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint28cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint2cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint2sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2sortsupport(unknown) is 'sort support';

create function pg_catalog.btint42cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint42cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint48cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint48cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint4cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint4sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4sortsupport(unknown) is 'sort support';

create function pg_catalog.btint82cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint82cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint84cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint84cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint8cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btint8sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8sortsupport(unknown) is 'sort support';

create function pg_catalog.btnamecmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamecmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btnamesortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamesortsupport(unknown) is 'sort support';

create function pg_catalog.btnametextcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnametextcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btoidcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btoidsortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidsortsupport(unknown) is 'sort support';

create function pg_catalog.btoidvectorcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidvectorcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btrecordcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btrecordimagecmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordimagecmp(unknown, unknown) is 'less-equal-greater based on byte images';

create function pg_catalog.btrim(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(unknown) is 'trim spaces from both ends of string';

create function pg_catalog.bttext_pattern_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.bttext_pattern_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_sortsupport(unknown) is 'sort support';

create function pg_catalog.bttextcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.bttextnamecmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextnamecmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.bttextsortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextsortsupport(unknown) is 'sort support';

create function pg_catalog.bttidcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttidcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.btvarstrequalimage(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btvarstrequalimage(unknown) is 'equal image';

create function pg_catalog.bytea_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_sortsupport(unknown) is 'sort support';

create function pg_catalog.bytea_string_agg_finalfn(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_finalfn(unknown) is 'aggregate final function';

create function pg_catalog.bytea_string_agg_transfn(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_transfn(unknown, unknown, unknown) is 'aggregate transition function';

create function pg_catalog.byteacat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.byteacmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.byteaeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaeq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.byteage(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteage(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.byteagt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteagt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.byteain(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteain(unknown) is 'I/O';

create function pg_catalog.byteale(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteale(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.bytealike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealike(unknown, unknown) is 'implementation of ~~ operator';

create function pg_catalog.bytealt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.byteane(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteane(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.byteanlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteanlike(unknown, unknown) is 'implementation of !~~ operator';

create function pg_catalog.byteaout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaout(unknown) is 'I/O';

create function pg_catalog.bytearecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytearecv(unknown) is 'I/O';

create function pg_catalog.byteasend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteasend(unknown) is 'I/O';

create function pg_catalog.cardinality(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cardinality(unknown) is 'array cardinality';

create function pg_catalog.cash_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.cash_div_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_cash(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_div_flt4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt4(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_div_flt8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt8(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_div_int2(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int2(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_div_int4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int4(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_div_int8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int8(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.cash_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.cash_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.cash_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.cash_in(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_in(unknown) is 'I/O';

create function pg_catalog.cash_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.cash_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.cash_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.cash_mul_flt4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt4(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.cash_mul_flt8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt8(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.cash_mul_int2(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int2(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.cash_mul_int4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int4(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.cash_mul_int8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int8(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.cash_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.cash_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_out(unknown) is 'I/O';

create function pg_catalog.cash_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.cash_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_recv(unknown) is 'I/O';

create function pg_catalog.cash_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_send(unknown) is 'I/O';

create function pg_catalog.cash_words(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_words(unknown) is 'output money amount as words';

create function pg_catalog.cashlarger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashlarger(unknown, unknown) is 'larger of two';

create function pg_catalog.cashsmaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashsmaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.cbrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cbrt(unknown) is 'cube root';

create function pg_catalog.chareq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chareq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.charge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.chargt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chargt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.charin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charin(unknown) is 'I/O';

create function pg_catalog.charle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.charlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.charne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.charout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charout(unknown) is 'I/O';

create function pg_catalog.charrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charrecv(unknown) is 'I/O';

create function pg_catalog.charsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charsend(unknown) is 'I/O';

create function pg_catalog.chr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chr(unknown) is 'convert int4 to char';

create function pg_catalog.cideq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cideq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.cidin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidin(unknown) is 'I/O';

create function pg_catalog.cidout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidout(unknown) is 'I/O';

create function pg_catalog.cidr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr(unknown) is 'convert inet to cidr';

create function pg_catalog.cidr_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_in(unknown) is 'I/O';

create function pg_catalog.cidr_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_out(unknown) is 'I/O';

create function pg_catalog.cidr_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_recv(unknown) is 'I/O';

create function pg_catalog.cidr_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_send(unknown) is 'I/O';

create function pg_catalog.cidrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidrecv(unknown) is 'I/O';

create function pg_catalog.cidsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidsend(unknown) is 'I/O';

create function pg_catalog.circle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(unknown, unknown) is 'convert point and radius to circle';

create function pg_catalog.circle_above(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_above(unknown, unknown) is 'implementation of |>> operator';

create function pg_catalog.circle_add_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_add_pt(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.circle_below(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_below(unknown, unknown) is 'implementation of <<| operator';

create function pg_catalog.circle_center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_center(unknown) is 'implementation of @@ operator';

create function pg_catalog.circle_contain(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.circle_contain_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain_pt(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.circle_contained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.circle_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.circle_div_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_div_pt(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.circle_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.circle_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.circle_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.circle_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_in(unknown) is 'I/O';

create function pg_catalog.circle_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.circle_left(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_left(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.circle_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.circle_mul_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_mul_pt(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.circle_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.circle_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_out(unknown) is 'I/O';

create function pg_catalog.circle_overabove(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overabove(unknown, unknown) is 'implementation of |&> operator';

create function pg_catalog.circle_overbelow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overbelow(unknown, unknown) is 'implementation of &<| operator';

create function pg_catalog.circle_overlap(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overlap(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.circle_overleft(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overleft(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.circle_overright(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overright(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.circle_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_recv(unknown) is 'I/O';

create function pg_catalog.circle_right(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_right(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.circle_same(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_same(unknown, unknown) is 'implementation of ~= operator';

create function pg_catalog.circle_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_send(unknown) is 'I/O';

create function pg_catalog.circle_sub_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_sub_pt(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.clock_timestamp() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.clock_timestamp() is 'current clock time';

create function pg_catalog.close_lb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lb(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_ls(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ls(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_lseg(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lseg(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_pb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pb(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pl(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_ps(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ps(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_sb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sb(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.close_sl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sl(unknown, unknown) is 'implementation of ## operator';

create function pg_catalog.col_description(oid, integer) returns text
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.col_description(unknown, unknown) is 'get description for table column';

create function pg_catalog.concat(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat(unknown) is 'concatenate values';

create function pg_catalog.concat_ws(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat_ws(unknown, unknown) is 'concatenate values with separators';

create function pg_catalog.contjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for containment comparison operators';

create function pg_catalog.contsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contsel(unknown, unknown, unknown, unknown) is 'restriction selectivity for containment comparison operators';

create function pg_catalog.convert(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert(unknown, unknown, unknown) is 'convert string with specified encoding names';

create function pg_catalog.convert_from(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_from(unknown, unknown) is 'convert string with specified source encoding name';

create function pg_catalog.convert_to(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_to(unknown, unknown) is 'convert string with specified destination encoding name';

create function pg_catalog.cos(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cos(unknown) is 'cosine';

create function pg_catalog.cosd(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosd(unknown) is 'cosine, degrees';

create function pg_catalog.cosh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosh(unknown) is 'hyperbolic cosine';

create function pg_catalog.cot(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cot(unknown) is 'cotangent';

create function pg_catalog.cotd(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cotd(unknown) is 'cotangent, degrees';

create function pg_catalog.cstring_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_in(unknown) is 'I/O';

create function pg_catalog.cstring_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_out(unknown) is 'I/O';

create function pg_catalog.cstring_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_recv(unknown) is 'I/O';

create function pg_catalog.cstring_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_send(unknown) is 'I/O';

create function pg_catalog.cume_dist() returns unknown
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist() is 'fractional row number within partition';

create function pg_catalog.cume_dist_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.current_database() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_database() is 'name of the current database';

create function pg_catalog.current_query() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_query() is 'get the currently executing query';

create function pg_catalog."current_schema"() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_schema"() is 'current schema name';

create function pg_catalog.current_schemas(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_schemas(unknown) is 'current schema search list';

create function pg_catalog.current_setting(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(unknown) is 'SHOW X as a function';

create function pg_catalog.current_setting(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(unknown, unknown) is 'SHOW X as a function, optionally no error for missing variable';

create function pg_catalog."current_user"() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_user"() is 'current user name';

create function pg_catalog.currtid2(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid2(unknown, unknown) is 'latest tid of a tuple';

create function pg_catalog.currval(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currval(unknown) is 'sequence current value';

create function pg_catalog.cursor_to_xml(cursor unknown, count unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xml(unknown, unknown, unknown, unknown, unknown) is 'map rows from cursor to XML';

create function pg_catalog.cursor_to_xmlschema(cursor unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xmlschema(unknown, unknown, unknown, unknown) is 'map cursor structure to XML Schema';

create function pg_catalog.database_to_xml(nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml(unknown, unknown, unknown) is 'map database contents to XML';

create function pg_catalog.database_to_xml_and_xmlschema(nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml_and_xmlschema(unknown, unknown, unknown) is 'map database contents and structure to XML and XML Schema';

create function pg_catalog.database_to_xmlschema(nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xmlschema(unknown, unknown, unknown) is 'map database structure to XML Schema';

create function pg_catalog.date_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.date_cmp_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.date_cmp_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamptz(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.date_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.date_eq_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamp(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.date_eq_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamptz(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.date_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.date_ge_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamp(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.date_ge_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamptz(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.date_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.date_gt_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamp(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.date_gt_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamptz(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.date_in(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_in(unknown) is 'I/O';

create function pg_catalog.date_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.date_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.date_le_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamp(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.date_le_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamptz(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.date_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.date_lt_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamp(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.date_lt_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamptz(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.date_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.date_mi_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi_interval(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.date_mii(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mii(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.date_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.date_ne_timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamp(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.date_ne_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamptz(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.date_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_out(unknown) is 'I/O';

create function pg_catalog.date_pl_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pl_interval(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.date_pli(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pli(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.date_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_recv(unknown) is 'I/O';

create function pg_catalog.date_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_send(unknown) is 'I/O';

create function pg_catalog.date_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.date_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_sortsupport(unknown) is 'sort support';

create function pg_catalog.date_trunc(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(unknown, unknown, unknown) is 'truncate timestamp with time zone to specified units in specified time zone';

create function pg_catalog.datemultirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange() is 'datemultirange constructor';

create function pg_catalog.daterange(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(unknown, unknown) is 'daterange constructor';

create function pg_catalog.daterange(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(unknown, unknown, unknown) is 'daterange constructor';

create function pg_catalog.daterange_canonical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_canonical(unknown) is 'convert a date range to canonical form';

create function pg_catalog.daterange_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_subdiff(unknown, unknown) is 'float8 difference of two date values';

create function pg_catalog.datetime_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetime_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.datetimetz_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetimetz_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.dcbrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dcbrt(unknown) is 'implementation of ||/ operator';

create function pg_catalog.decode(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.decode(unknown, unknown) is 'convert ascii-encoded text string into bytea value';

create function pg_catalog.degrees(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.degrees(unknown) is 'radians to degrees';

create function pg_catalog.dense_rank() returns unknown
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank() is 'integer rank without gaps';

create function pg_catalog.dense_rank_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.dexp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dexp(unknown) is 'natural exponential (e^x)';

create function pg_catalog.diagonal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diagonal(unknown) is 'box diagonal';

create function pg_catalog.diameter(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diameter(unknown) is 'diameter of circle';

create function pg_catalog.dispell_init(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_init(unknown) is '(internal)';

create function pg_catalog.dispell_lexize(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_lexize(unknown, unknown, unknown, unknown) is '(internal)';

create function pg_catalog.dist_bl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bl(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_bp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bp(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_bs(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bs(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_cpoint(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoint(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_cpoly(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoly(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_lb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lb(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_lp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lp(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_ls(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ls(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_pathp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pathp(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_pb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pb(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_pc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pc(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pl(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_polyc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyc(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_polyp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyp(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_ppath(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppath(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_ppoly(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppoly(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_ps(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ps(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_sb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sb(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_sl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sl(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.dist_sp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sp(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.div(unknown, unknown) is 'trunc(x/y)';

create function pg_catalog.dlog1(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog1(unknown) is 'natural logarithm';

create function pg_catalog.dlog10(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog10(unknown) is 'base 10 logarithm';

create function pg_catalog.domain_in(unknown, unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.domain_recv(unknown, unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.dpow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dpow(unknown, unknown) is 'implementation of ^ operator';

create function pg_catalog.dround(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dround(unknown) is 'round to nearest integer';

create function pg_catalog.dsimple_init(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_init(unknown) is '(internal)';

create function pg_catalog.dsimple_lexize(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_lexize(unknown, unknown, unknown, unknown) is '(internal)';

create function pg_catalog.dsnowball_init(unknown) returns unknown
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.dsnowball_lexize(unknown, unknown, unknown, unknown) returns unknown
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.dsqrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsqrt(unknown) is 'implementation of |/ operator';

create function pg_catalog.dsynonym_init(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_init(unknown) is '(internal)';

create function pg_catalog.dsynonym_lexize(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_lexize(unknown, unknown, unknown, unknown) is '(internal)';

create function pg_catalog.dtrunc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dtrunc(unknown) is 'truncate to integer';

create function pg_catalog.elem_contained_by_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_multirange(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.elem_contained_by_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_range(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.encode(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.encode(unknown, unknown) is 'convert bytea value into some ascii-only text string';

create function pg_catalog.enum_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.enum_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.enum_first(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_first(unknown) is 'first value of the input enum type';

create function pg_catalog.enum_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.enum_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.enum_in(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_in(unknown, unknown) is 'I/O';

create function pg_catalog.enum_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.enum_last(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_last(unknown) is 'last value of the input enum type';

create function pg_catalog.enum_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.enum_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.enum_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.enum_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_out(unknown) is 'I/O';

create function pg_catalog.enum_range(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(unknown) is 'range of the given enum type, as an ordered array';

create function pg_catalog.enum_range(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(unknown, unknown) is 'range between the two given enum values, as an ordered array';

create function pg_catalog.enum_recv(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_recv(unknown, unknown) is 'I/O';

create function pg_catalog.enum_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_send(unknown) is 'I/O';

create function pg_catalog.enum_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.eqjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of = and related operators';

create function pg_catalog.eqsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of = and related operators';

create function pg_catalog.euc_cn_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_CN to MULE_INTERNAL';

create function pg_catalog.euc_cn_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_CN to UTF8';

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

create function pg_catalog.euc_jis_2004_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_JIS_2004 to UTF8';

create function pg_catalog.euc_jp_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_JP to MULE_INTERNAL';

create function pg_catalog.euc_jp_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_JP to SJIS';

create function pg_catalog.euc_jp_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_JP to UTF8';

create function pg_catalog.euc_kr_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_KR to MULE_INTERNAL';

create function pg_catalog.euc_kr_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_KR to UTF8';

create function pg_catalog.euc_tw_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_TW to BIG5';

create function pg_catalog.euc_tw_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_TW to MULE_INTERNAL';

create function pg_catalog.euc_tw_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for EUC_TW to UTF8';

create function pg_catalog.event_trigger_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_in(unknown) is 'I/O';

create function pg_catalog.event_trigger_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_out(unknown) is 'I/O';

create function pg_catalog.factorial(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.factorial(unknown) is 'factorial';

create function pg_catalog.family(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.family(unknown) is 'address family (4 for IPv4, 6 for IPv6)';

create function pg_catalog.fdw_handler_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_in(unknown) is 'I/O';

create function pg_catalog.fdw_handler_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_out(unknown) is 'I/O';

create function pg_catalog.first_value(unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.first_value(unknown) is 'fetch the first row value';

create function pg_catalog.float48div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.float48eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.float48ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.float48gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.float48le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.float48lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.float48mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.float48mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.float48ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.float48pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.float4_accum(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.float4abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4abs(unknown) is 'implementation of @ operator';

create function pg_catalog.float4div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.float4eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.float4ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.float4gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.float4in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4in(unknown) is 'I/O';

create function pg_catalog.float4larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4larger(unknown, unknown) is 'larger of two';

create function pg_catalog.float4le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.float4lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.float4mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.float4mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.float4ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.float4out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4out(unknown) is 'I/O';

create function pg_catalog.float4pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.float4recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4recv(unknown) is 'I/O';

create function pg_catalog.float4send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4send(unknown) is 'I/O';

create function pg_catalog.float4smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.float4um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4um(unknown) is 'implementation of - operator';

create function pg_catalog.float4up(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4up(unknown) is 'implementation of + operator';

create function pg_catalog.float84div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.float84eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.float84ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.float84gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.float84le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.float84lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.float84mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.float84mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.float84ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.float84pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.float8_accum(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.float8_avg(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_avg(unknown) is 'aggregate final function';

create function pg_catalog.float8_combine(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.float8_corr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_corr(unknown) is 'aggregate final function';

create function pg_catalog.float8_covar_pop(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_pop(unknown) is 'aggregate final function';

create function pg_catalog.float8_covar_samp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_samp(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_accum(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_accum(unknown, unknown, unknown) is 'aggregate transition function';

create function pg_catalog.float8_regr_avgx(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgx(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_avgy(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgy(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_combine(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.float8_regr_intercept(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_intercept(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_r2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_r2(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_slope(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_slope(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_sxx(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxx(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_sxy(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxy(unknown) is 'aggregate final function';

create function pg_catalog.float8_regr_syy(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_syy(unknown) is 'aggregate final function';

create function pg_catalog.float8_stddev_pop(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_pop(unknown) is 'aggregate final function';

create function pg_catalog.float8_stddev_samp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_samp(unknown) is 'aggregate final function';

create function pg_catalog.float8_var_pop(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_pop(unknown) is 'aggregate final function';

create function pg_catalog.float8_var_samp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_samp(unknown) is 'aggregate final function';

create function pg_catalog.float8abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8abs(unknown) is 'implementation of @ operator';

create function pg_catalog.float8div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.float8eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.float8ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.float8gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.float8in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8in(unknown) is 'I/O';

create function pg_catalog.float8larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8larger(unknown, unknown) is 'larger of two';

create function pg_catalog.float8le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.float8lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.float8mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.float8mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.float8ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.float8out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8out(unknown) is 'I/O';

create function pg_catalog.float8pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.float8recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8recv(unknown) is 'I/O';

create function pg_catalog.float8send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8send(unknown) is 'I/O';

create function pg_catalog.float8smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.float8um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8um(unknown) is 'implementation of - operator';

create function pg_catalog.float8up(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8up(unknown) is 'implementation of + operator';

create function pg_catalog.flt4_mul_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt4_mul_cash(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.flt8_mul_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt8_mul_cash(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.fmgr_c_validator(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_c_validator(unknown) is '(internal)';

create function pg_catalog.fmgr_internal_validator(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_internal_validator(unknown) is '(internal)';

create function pg_catalog.fmgr_sql_validator(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_sql_validator(unknown) is '(internal)';

create function pg_catalog.format(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(unknown) is 'format text message';

create function pg_catalog.format(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(unknown, unknown) is 'format text message';

create function pg_catalog.format_type(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format_type(unknown, unknown) is 'format a type oid and atttypmod to canonical SQL';

create function pg_catalog.gb18030_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gb18030_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for GB18030 to UTF8';

create function pg_catalog.gbk_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gbk_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for GBK to UTF8';

create function pg_catalog.gen_random_uuid() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gen_random_uuid() is 'generate random UUID';

create function pg_catalog.generate_series_int4_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int4_support(unknown) is 'planner support for generate_series';

create function pg_catalog.generate_series_int8_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int8_support(unknown) is 'planner support for generate_series';

create function pg_catalog.generate_subscripts(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_subscripts(unknown, unknown) is 'array subscripts generator';

create function pg_catalog.generate_subscripts(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_subscripts(unknown, unknown, unknown) is 'array subscripts generator';

create function pg_catalog.get_byte(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_byte(unknown, unknown) is 'get byte';

create function pg_catalog.get_current_ts_config() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_current_ts_config() is 'get current tsearch configuration';

create function pg_catalog.getdatabaseencoding() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getdatabaseencoding() is 'encoding name of current database';

create function pg_catalog.getpgusername() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getpgusername() is 'deprecated, use current_user instead';

create function pg_catalog.gin_clean_pending_list(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_clean_pending_list(unknown) is 'clean up GIN pending list';

create function pg_catalog.gin_cmp_prefix(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_prefix(unknown, unknown, unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.gin_cmp_tslexeme(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_tslexeme(unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.gin_compare_jsonb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_compare_jsonb(unknown, unknown) is 'GIN support';

create function pg_catalog.gin_consistent_jsonb(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_consistent_jsonb_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_extract_jsonb(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb(unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_path(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_path(unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsvector(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(unknown, unknown) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsvector(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(unknown, unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.gin_triconsistent_jsonb(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_triconsistent_jsonb_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb_path(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN support';

create function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_tsquery_triconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_triconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.ginarrayconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN array support';

create function pg_catalog.ginarrayextract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(unknown, unknown) is 'GIN array support (obsolete)';

create function pg_catalog.ginarrayextract(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(unknown, unknown, unknown) is 'GIN array support';

create function pg_catalog.ginarraytriconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarraytriconsistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN array support';

create function pg_catalog.ginhandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginhandler(unknown) is 'gin index access method handler';

create function pg_catalog.ginqueryarrayextract(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginqueryarrayextract(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN array support';

create function pg_catalog.gist_box_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_box_distance(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_distance(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_box_penalty(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_penalty(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_box_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_picksplit(unknown, unknown) is 'GiST support';

create function pg_catalog.gist_box_same(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_same(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_box_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_union(unknown, unknown) is 'GiST support';

create function pg_catalog.gist_circle_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_compress(unknown) is 'GiST support';

create function pg_catalog.gist_circle_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_circle_distance(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_distance(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_point_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_compress(unknown) is 'GiST support';

create function pg_catalog.gist_point_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_point_distance(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_distance(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_point_fetch(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_fetch(unknown) is 'GiST support';

create function pg_catalog.gist_point_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_sortsupport(unknown) is 'sort support';

create function pg_catalog.gist_poly_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_compress(unknown) is 'GiST support';

create function pg_catalog.gist_poly_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gist_poly_distance(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_distance(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.gisthandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gisthandler(unknown) is 'gist index access method handler';

create function pg_catalog.gtsquery_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_compress(unknown) is 'GiST tsquery support';

create function pg_catalog.gtsquery_penalty(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_penalty(unknown, unknown, unknown) is 'GiST tsquery support';

create function pg_catalog.gtsquery_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_picksplit(unknown, unknown) is 'GiST tsquery support';

create function pg_catalog.gtsquery_same(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_same(unknown, unknown, unknown) is 'GiST tsquery support';

create function pg_catalog.gtsquery_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_union(unknown, unknown) is 'GiST tsquery support';

create function pg_catalog.gtsvector_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_compress(unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_decompress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_decompress(unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_options(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_options(unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_penalty(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_penalty(unknown, unknown, unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_picksplit(unknown, unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_same(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_same(unknown, unknown, unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_union(unknown, unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvectorin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorin(unknown) is 'I/O';

create function pg_catalog.gtsvectorout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorout(unknown) is 'I/O';

create function pg_catalog.hash_aclitem(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem(unknown) is 'hash';

create function pg_catalog.hash_aclitem_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem_extended(unknown, unknown) is 'hash';

create function pg_catalog.hash_array(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array(unknown) is 'hash';

create function pg_catalog.hash_array_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array_extended(unknown, unknown) is 'hash';

create function pg_catalog.hash_multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_multirange(unknown) is 'hash a multirange';

create function pg_catalog.hash_multirange_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_multirange_extended(unknown, unknown) is 'hash a multirange';

create function pg_catalog.hash_numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric(unknown) is 'hash';

create function pg_catalog.hash_numeric_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric_extended(unknown, unknown) is 'hash';

create function pg_catalog.hash_range(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range(unknown) is 'hash a range';

create function pg_catalog.hash_range_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range_extended(unknown, unknown) is 'hash a range';

create function pg_catalog.hash_record(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_record(unknown) is 'hash';

create function pg_catalog.hash_record_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_record_extended(unknown, unknown) is 'hash';

create function pg_catalog.hashbpchar(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpchar(unknown) is 'hash';

create function pg_catalog.hashbpcharextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpcharextended(unknown, unknown) is 'hash';

create function pg_catalog.hashchar(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashchar(unknown) is 'hash';

create function pg_catalog.hashcharextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashcharextended(unknown, unknown) is 'hash';

create function pg_catalog.hashenum(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenum(unknown) is 'hash';

create function pg_catalog.hashenumextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenumextended(unknown, unknown) is 'hash';

create function pg_catalog.hashfloat4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4(unknown) is 'hash';

create function pg_catalog.hashfloat4extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4extended(unknown, unknown) is 'hash';

create function pg_catalog.hashfloat8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8(unknown) is 'hash';

create function pg_catalog.hashfloat8extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8extended(unknown, unknown) is 'hash';

create function pg_catalog.hashhandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashhandler(unknown) is 'hash index access method handler';

create function pg_catalog.hashinet(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinet(unknown) is 'hash';

create function pg_catalog.hashinetextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinetextended(unknown, unknown) is 'hash';

create function pg_catalog.hashint2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2(unknown) is 'hash';

create function pg_catalog.hashint2extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2extended(unknown, unknown) is 'hash';

create function pg_catalog.hashint4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4(unknown) is 'hash';

create function pg_catalog.hashint4extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4extended(unknown, unknown) is 'hash';

create function pg_catalog.hashint8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8(unknown) is 'hash';

create function pg_catalog.hashint8extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8extended(unknown, unknown) is 'hash';

create function pg_catalog.hashmacaddr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr(unknown) is 'hash';

create function pg_catalog.hashmacaddr8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8(unknown) is 'hash';

create function pg_catalog.hashmacaddr8extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8extended(unknown, unknown) is 'hash';

create function pg_catalog.hashmacaddrextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddrextended(unknown, unknown) is 'hash';

create function pg_catalog.hashname(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashname(unknown) is 'hash';

create function pg_catalog.hashnameextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashnameextended(unknown, unknown) is 'hash';

create function pg_catalog.hashoid(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoid(unknown) is 'hash';

create function pg_catalog.hashoidextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidextended(unknown, unknown) is 'hash';

create function pg_catalog.hashoidvector(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvector(unknown) is 'hash';

create function pg_catalog.hashoidvectorextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvectorextended(unknown, unknown) is 'hash';

create function pg_catalog.hashtext(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtext(unknown) is 'hash';

create function pg_catalog.hashtextextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtextextended(unknown, unknown) is 'hash';

create function pg_catalog.hashtid(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtid(unknown) is 'hash';

create function pg_catalog.hashtidextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtidextended(unknown, unknown) is 'hash';

create function pg_catalog.hashvarlena(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlena(unknown) is 'hash';

create function pg_catalog.hashvarlenaextended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlenaextended(unknown, unknown) is 'hash';

create function pg_catalog.heap_tableam_handler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.heap_tableam_handler(unknown) is 'row-oriented heap table access method handler';

create function pg_catalog.height(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.height(unknown) is 'box height';

create function pg_catalog.host(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.host(unknown) is 'show address octets only';

create function pg_catalog.hostmask(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hostmask(unknown) is 'hostmask of address';

create function pg_catalog.iclikejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of ILIKE';

create function pg_catalog.iclikesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of ILIKE';

create function pg_catalog.icnlikejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of NOT ILIKE';

create function pg_catalog.icnlikesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of NOT ILIKE';

create function pg_catalog.icregexeqjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of case-insensitive regex match';

create function pg_catalog.icregexeqsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of case-insensitive regex match';

create function pg_catalog.icregexnejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of case-insensitive regex non-match';

create function pg_catalog.icregexnesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of case-insensitive regex non-match';

create function pg_catalog.index_am_handler_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_in(unknown) is 'I/O';

create function pg_catalog.index_am_handler_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_out(unknown) is 'I/O';

create function pg_catalog.inet_client_addr() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_addr() is 'inet address of the client';

create function pg_catalog.inet_client_port() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_port() is 'client''s port number for this connection';

create function pg_catalog.inet_gist_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_compress(unknown) is 'GiST support';

create function pg_catalog.inet_gist_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.inet_gist_fetch(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_fetch(unknown) is 'GiST support';

create function pg_catalog.inet_gist_penalty(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_penalty(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.inet_gist_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_picksplit(unknown, unknown) is 'GiST support';

create function pg_catalog.inet_gist_same(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_same(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.inet_gist_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_union(unknown, unknown) is 'GiST support';

create function pg_catalog.inet_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_in(unknown) is 'I/O';

create function pg_catalog.inet_merge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_merge(unknown, unknown) is 'the smallest network which includes both of the given networks';

create function pg_catalog.inet_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_out(unknown) is 'I/O';

create function pg_catalog.inet_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_recv(unknown) is 'I/O';

create function pg_catalog.inet_same_family(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_same_family(unknown, unknown) is 'are the addresses from the same family?';

create function pg_catalog.inet_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_send(unknown) is 'I/O';

create function pg_catalog.inet_server_addr() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_addr() is 'inet address of the server';

create function pg_catalog.inet_server_port() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_port() is 'server''s port number for this connection';

create function pg_catalog.inet_spg_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_choose(unknown, unknown) is 'SP-GiST support';

create function pg_catalog.inet_spg_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_config(unknown, unknown) is 'SP-GiST support';

create function pg_catalog.inet_spg_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_inner_consistent(unknown, unknown) is 'SP-GiST support';

create function pg_catalog.inet_spg_leaf_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_leaf_consistent(unknown, unknown) is 'SP-GiST support';

create function pg_catalog.inet_spg_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_picksplit(unknown, unknown) is 'SP-GiST support';

create function pg_catalog.inetand(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetand(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.inetmi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.inetmi_int8(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi_int8(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.inetnot(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetnot(unknown) is 'implementation of ~ operator';

create function pg_catalog.inetor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetor(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.inetpl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetpl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.initcap(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.initcap(unknown) is 'capitalize each word';

create function pg_catalog.int24div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int24eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int24ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int24gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int24le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int24lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int24mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int24mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int24ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int24pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int28div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int28eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int28ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int28gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int28le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int28lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int28mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int28mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int28ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int28pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int2_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int2_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int2_avg_accum(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int2_avg_accum_inv(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int2_mul_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_mul_cash(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int2_sum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_sum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int2abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2abs(unknown) is 'implementation of @ operator';

create function pg_catalog.int2and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2and(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.int2div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int2eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int2ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int2gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int2in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2in(unknown) is 'I/O';

create function pg_catalog.int2int4_sum(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2int4_sum(unknown) is 'aggregate final function';

create function pg_catalog.int2larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2larger(unknown, unknown) is 'larger of two';

create function pg_catalog.int2le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int2lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int2mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int2mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mod(unknown, unknown) is 'implementation of % operator';

create function pg_catalog.int2mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int2ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int2not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2not(unknown) is 'implementation of ~ operator';

create function pg_catalog.int2or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2or(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.int2out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2out(unknown) is 'I/O';

create function pg_catalog.int2pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int2recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2recv(unknown) is 'I/O';

create function pg_catalog.int2send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2send(unknown) is 'I/O';

create function pg_catalog.int2shl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shl(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.int2shr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shr(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.int2smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.int2um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2um(unknown) is 'implementation of - operator';

create function pg_catalog.int2up(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2up(unknown) is 'implementation of + operator';

create function pg_catalog.int2vectorin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorin(unknown) is 'I/O';

create function pg_catalog.int2vectorout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorout(unknown) is 'I/O';

create function pg_catalog.int2vectorrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorrecv(unknown) is 'I/O';

create function pg_catalog.int2vectorsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorsend(unknown) is 'I/O';

create function pg_catalog.int2xor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2xor(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.int42div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int42eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int42ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int42gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int42le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int42lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int42mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int42mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int42ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int42pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int48div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int48eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int48ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int48gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int48le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int48lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int48mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int48mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int48ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int48pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int4_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int4_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int4_avg_accum(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int4_avg_accum_inv(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int4_avg_combine(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.int4_mul_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_mul_cash(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int4_sum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_sum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int4abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4abs(unknown) is 'implementation of @ operator';

create function pg_catalog.int4and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4and(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.int4div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int4eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int4ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int4gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int4in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4in(unknown) is 'I/O';

create function pg_catalog.int4inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4inc(unknown) is 'increment';

create function pg_catalog.int4larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4larger(unknown, unknown) is 'larger of two';

create function pg_catalog.int4le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int4lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int4mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int4mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mod(unknown, unknown) is 'implementation of % operator';

create function pg_catalog.int4mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int4multirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange() is 'int4multirange constructor';

create function pg_catalog.int4ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int4not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4not(unknown) is 'implementation of ~ operator';

create function pg_catalog.int4or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4or(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.int4out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4out(unknown) is 'I/O';

create function pg_catalog.int4pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int4range(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(unknown, unknown) is 'int4range constructor';

create function pg_catalog.int4range(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(unknown, unknown, unknown) is 'int4range constructor';

create function pg_catalog.int4range_canonical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_canonical(unknown) is 'convert an int4 range to canonical form';

create function pg_catalog.int4range_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_subdiff(unknown, unknown) is 'float8 difference of two int4 values';

create function pg_catalog.int4recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4recv(unknown) is 'I/O';

create function pg_catalog.int4send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4send(unknown) is 'I/O';

create function pg_catalog.int4shl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shl(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.int4shr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shr(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.int4smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.int4um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4um(unknown) is 'implementation of - operator';

create function pg_catalog.int4up(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4up(unknown) is 'implementation of + operator';

create function pg_catalog.int4xor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4xor(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.int82div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int82eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int82ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int82gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int82le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int82lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int82mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int82mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int82ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int82pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int84div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int84eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int84ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int84gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int84le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int84lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int84mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int84mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int84ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int84pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int8_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8_avg(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg(unknown) is 'aggregate final function';

create function pg_catalog.int8_avg_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8_avg_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8_avg_combine(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.int8_avg_deserialize(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_deserialize(unknown, unknown) is 'aggregate deserial function';

create function pg_catalog.int8_avg_serialize(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_serialize(unknown) is 'aggregate serial function';

create function pg_catalog.int8_mul_cash(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_mul_cash(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int8_sum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_sum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8abs(unknown) is 'implementation of @ operator';

create function pg_catalog.int8and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8and(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.int8dec(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec(unknown) is 'decrement';

create function pg_catalog.int8dec_any(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec_any(unknown, unknown) is 'decrement, ignores second argument';

create function pg_catalog.int8div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.int8eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.int8ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.int8gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.int8in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8in(unknown) is 'I/O';

create function pg_catalog.int8inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc(unknown) is 'increment';

create function pg_catalog.int8inc_any(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_any(unknown, unknown) is 'increment, ignores second argument';

create function pg_catalog.int8inc_float8_float8(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_float8_float8(unknown, unknown, unknown) is 'aggregate transition function';

create function pg_catalog.int8larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8larger(unknown, unknown) is 'larger of two';

create function pg_catalog.int8le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.int8lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.int8mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.int8mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mod(unknown, unknown) is 'implementation of % operator';

create function pg_catalog.int8mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.int8multirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange() is 'int8multirange constructor';

create function pg_catalog.int8ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.int8not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8not(unknown) is 'implementation of ~ operator';

create function pg_catalog.int8or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8or(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.int8out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8out(unknown) is 'I/O';

create function pg_catalog.int8pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int8pl_inet(bigint, inet) returns inet
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl_inet(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.int8range(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(unknown, unknown) is 'int8range constructor';

create function pg_catalog.int8range(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(unknown, unknown, unknown) is 'int8range constructor';

create function pg_catalog.int8range_canonical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_canonical(unknown) is 'convert an int8 range to canonical form';

create function pg_catalog.int8range_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_subdiff(unknown, unknown) is 'float8 difference of two int8 values';

create function pg_catalog.int8recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8recv(unknown) is 'I/O';

create function pg_catalog.int8send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8send(unknown) is 'I/O';

create function pg_catalog.int8shl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shl(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.int8shr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shr(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.int8smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.int8um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8um(unknown) is 'implementation of - operator';

create function pg_catalog.int8up(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8up(unknown) is 'implementation of + operator';

create function pg_catalog.int8xor(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8xor(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.integer_pl_date(integer, date) returns date
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.integer_pl_date(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.inter_lb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_lb(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.inter_sb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sb(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.inter_sl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sl(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.internal_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_in(unknown) is 'I/O';

create function pg_catalog.internal_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_out(unknown) is 'I/O';

create function pg_catalog.interval(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(unknown) is 'convert time to interval';

create function pg_catalog.interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(unknown, unknown) is 'adjust interval precision';

create function pg_catalog.interval_accum(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.interval_accum_inv(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.interval_avg(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_avg(unknown) is 'aggregate final function';

create function pg_catalog.interval_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.interval_combine(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.interval_div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.interval_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.interval_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.interval_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.interval_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash(unknown) is 'hash';

create function pg_catalog.interval_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.interval_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.interval_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.interval_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.interval_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.interval_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.interval_mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.interval_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.interval_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_out(unknown) is 'I/O';

create function pg_catalog.interval_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_pl_date(interval, date) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_date(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_pl_time(interval, time without time zone) returns time without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_time(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamp(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamptz(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_pl_timetz(interval, time with time zone) returns time with time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timetz(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.interval_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.interval_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_send(unknown) is 'I/O';

create function pg_catalog.interval_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.interval_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_support(unknown) is 'planner support for interval length coercion';

create function pg_catalog.interval_um(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_um(unknown) is 'implementation of - operator';

create function pg_catalog.intervaltypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodin(unknown) is 'I/O typmod';

create function pg_catalog.intervaltypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodout(unknown) is 'I/O typmod';

create function pg_catalog.is_normalized(unknown, unknown default 'NFC'::text) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.is_normalized(unknown, unknown) is 'check Unicode normalization';

create function pg_catalog.isclosed(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isclosed(unknown) is 'path closed?';

create function pg_catalog.ishorizontal(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(unknown, unknown) is 'horizontally aligned';

create function pg_catalog.iso8859_1_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_1_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN1 to UTF8';

create function pg_catalog.iso8859_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for ISO-8859 2-16 to UTF8';

create function pg_catalog.iso_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for ISO-8859-5 to KOI8R';

create function pg_catalog.iso_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

create function pg_catalog.iso_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for ISO-8859-5 to WIN1251';

create function pg_catalog.iso_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for ISO-8859-5 to WIN866';

create function pg_catalog.isopen(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isopen(unknown) is 'path open?';

create function pg_catalog.isvertical(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(unknown, unknown) is 'vertically aligned';

create function pg_catalog.johab_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.johab_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for JOHAB to UTF8';

create function pg_catalog.json_agg_finalfn(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_finalfn(unknown) is 'json aggregate final function';

create function pg_catalog.json_agg_transfn(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_transfn(unknown, unknown) is 'json aggregate transition function';

create function pg_catalog.json_array_element(from_json unknown, element_index unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element(unknown, unknown) is 'implementation of -> operator';

create function pg_catalog.json_array_element_text(from_json unknown, element_index unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element_text(unknown, unknown) is 'implementation of ->> operator';

create function pg_catalog.json_array_elements(from_json unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_elements(unknown, out unknown) is 'key value pairs of a json object';

create function pg_catalog.json_array_elements_text(from_json unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_elements_text(unknown, out unknown) is 'elements of json array';

create function pg_catalog.json_array_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_length(unknown) is 'length of json array';

create function pg_catalog.json_build_array() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array() is 'build an empty json array';

create function pg_catalog.json_build_array(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array(unknown) is 'build a json array from any inputs';

create function pg_catalog.json_build_object() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object() is 'build an empty json object';

create function pg_catalog.json_build_object(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object(unknown) is 'build a json object from pairwise key/value inputs';

create function pg_catalog.json_each(from_json unknown, out key unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_each(unknown, out unknown, out unknown) is 'key value pairs of a json object';

create function pg_catalog.json_each_text(from_json unknown, out key unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_each_text(unknown, out unknown, out unknown) is 'key value pairs of a json object';

create function pg_catalog.json_extract_path(from_json unknown, path_elems unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path(unknown, unknown) is 'get value from json with path elements';

create function pg_catalog.json_extract_path_text(from_json unknown, path_elems unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path_text(unknown, unknown) is 'get value from json as text with path elements';

create function pg_catalog.json_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_in(unknown) is 'I/O';

create function pg_catalog.json_object(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(unknown) is 'map text array of key value pairs to json object';

create function pg_catalog.json_object(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(unknown, unknown) is 'map text arrays of keys and values to json object';

create function pg_catalog.json_object_agg_finalfn(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_finalfn(unknown) is 'json object aggregate final function';

create function pg_catalog.json_object_agg_transfn(unknown, unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_transfn(unknown, unknown, unknown) is 'json object aggregate transition function';

create function pg_catalog.json_object_field(from_json unknown, field_name unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field(unknown, unknown) is 'implementation of -> operator';

create function pg_catalog.json_object_field_text(from_json unknown, field_name unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field_text(unknown, unknown) is 'implementation of ->> operator';

create function pg_catalog.json_object_keys(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_keys(unknown) is 'get json object keys';

create function pg_catalog.json_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_out(unknown) is 'I/O';

create function pg_catalog.json_populate_record(base unknown, from_json unknown, use_json_as_text unknown default false) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_record(unknown, unknown, unknown) is 'get record fields from a json object';

create function pg_catalog.json_populate_recordset(base unknown, from_json unknown, use_json_as_text unknown default false) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_recordset(unknown, unknown, unknown) is 'get set of records with fields from a json array of objects';

create function pg_catalog.json_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_recv(unknown) is 'I/O';

create function pg_catalog.json_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_send(unknown) is 'I/O';

create function pg_catalog.json_strip_nulls(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_strip_nulls(unknown) is 'remove object fields with null values from json';

create function pg_catalog.json_to_record(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_record(unknown) is 'get record fields from a json object';

create function pg_catalog.json_to_recordset(unknown) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_recordset(unknown) is 'get set of records with fields from a json array of objects';

create function pg_catalog.json_to_tsvector(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(unknown, unknown) is 'transform specified values from json to tsvector';

create function pg_catalog.json_to_tsvector(unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(unknown, unknown, unknown) is 'transform specified values from json to tsvector';

create function pg_catalog.json_typeof(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_typeof(unknown) is 'get the type of a json value';

create function pg_catalog.jsonb_agg_finalfn(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_finalfn(unknown) is 'jsonb aggregate final function';

create function pg_catalog.jsonb_agg_transfn(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_transfn(unknown, unknown) is 'jsonb aggregate transition function';

create function pg_catalog.jsonb_array_element(from_json unknown, element_index unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element(unknown, unknown) is 'implementation of -> operator';

create function pg_catalog.jsonb_array_element_text(from_json unknown, element_index unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element_text(unknown, unknown) is 'implementation of ->> operator';

create function pg_catalog.jsonb_array_elements(from_json unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_elements(unknown, out unknown) is 'elements of a jsonb array';

create function pg_catalog.jsonb_array_elements_text(from_json unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_elements_text(unknown, out unknown) is 'elements of jsonb array';

create function pg_catalog.jsonb_array_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_length(unknown) is 'length of jsonb array';

create function pg_catalog.jsonb_build_array() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array() is 'build an empty jsonb array';

create function pg_catalog.jsonb_build_array(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array(unknown) is 'build a jsonb array from any inputs';

create function pg_catalog.jsonb_build_object() returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object() is 'build an empty jsonb object';

create function pg_catalog.jsonb_build_object(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object(unknown) is 'build a jsonb object from pairwise key/value inputs';

create function pg_catalog.jsonb_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.jsonb_concat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_concat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.jsonb_contained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.jsonb_contains(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contains(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.jsonb_delete_path(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete_path(unknown, unknown) is 'implementation of #- operator';

create function pg_catalog.jsonb_each(from_json unknown, out key unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_each(unknown, out unknown, out unknown) is 'key value pairs of a jsonb object';

create function pg_catalog.jsonb_each_text(from_json unknown, out key unknown, out value unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_each_text(unknown, out unknown, out unknown) is 'key value pairs of a jsonb object';

create function pg_catalog.jsonb_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.jsonb_exists(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists(unknown, unknown) is 'implementation of ? operator';

create function pg_catalog.jsonb_exists_all(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_all(unknown, unknown) is 'implementation of ?& operator';

create function pg_catalog.jsonb_exists_any(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_any(unknown, unknown) is 'implementation of ?| operator';

create function pg_catalog.jsonb_extract_path(from_json unknown, path_elems unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path(unknown, unknown) is 'get value from jsonb with path elements';

create function pg_catalog.jsonb_extract_path_text(from_json unknown, path_elems unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path_text(unknown, unknown) is 'get value from jsonb as text with path elements';

create function pg_catalog.jsonb_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.jsonb_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.jsonb_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash(unknown) is 'hash';

create function pg_catalog.jsonb_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.jsonb_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_in(unknown) is 'I/O';

create function pg_catalog.jsonb_insert(jsonb_in unknown, path unknown, replacement unknown, insert_after unknown default false) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_insert(unknown, unknown, unknown, unknown) is 'Insert value into a jsonb';

create function pg_catalog.jsonb_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.jsonb_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.jsonb_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.jsonb_object(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(unknown) is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_object(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(unknown, unknown) is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_object_agg_finalfn(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_finalfn(unknown) is 'jsonb object aggregate final function';

create function pg_catalog.jsonb_object_agg_transfn(unknown, unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_transfn(unknown, unknown, unknown) is 'jsonb object aggregate transition function';

create function pg_catalog.jsonb_object_field(from_json unknown, field_name unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field(unknown, unknown) is 'implementation of -> operator';

create function pg_catalog.jsonb_object_field_text(from_json unknown, field_name unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field_text(unknown, unknown) is 'implementation of ->> operator';

create function pg_catalog.jsonb_object_keys(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_keys(unknown) is 'get jsonb object keys';

create function pg_catalog.jsonb_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_out(unknown) is 'I/O';

create function pg_catalog.jsonb_path_exists(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists(unknown, unknown, unknown, unknown) is 'jsonpath exists test';

create function pg_catalog.jsonb_path_exists_opr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_opr(unknown, unknown) is 'implementation of @? operator';

create function pg_catalog.jsonb_path_exists_tz(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_tz(unknown, unknown, unknown, unknown) is 'jsonpath exists test with timezone';

create function pg_catalog.jsonb_path_match(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match(unknown, unknown, unknown, unknown) is 'jsonpath match';

create function pg_catalog.jsonb_path_match_opr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_opr(unknown, unknown) is 'implementation of @@ operator';

create function pg_catalog.jsonb_path_match_tz(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_tz(unknown, unknown, unknown, unknown) is 'jsonpath match with timezone';

create function pg_catalog.jsonb_path_query(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query(unknown, unknown, unknown, unknown) is 'jsonpath query';

create function pg_catalog.jsonb_path_query_array(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array(unknown, unknown, unknown, unknown) is 'jsonpath query wrapped into array';

create function pg_catalog.jsonb_path_query_array_tz(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array_tz(unknown, unknown, unknown, unknown) is 'jsonpath query wrapped into array with timezone';

create function pg_catalog.jsonb_path_query_first(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first(unknown, unknown, unknown, unknown) is 'jsonpath query first item';

create function pg_catalog.jsonb_path_query_first_tz(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first_tz(unknown, unknown, unknown, unknown) is 'jsonpath query first item with timezone';

create function pg_catalog.jsonb_path_query_tz(target unknown, path unknown, vars unknown default '{}'::jsonb, silent unknown default false) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_tz(unknown, unknown, unknown, unknown) is 'jsonpath query with timezone';

create function pg_catalog.jsonb_populate_record(unknown, unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_record(unknown, unknown) is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_populate_recordset(unknown, unknown) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_recordset(unknown, unknown) is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.jsonb_pretty(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_pretty(unknown) is 'Indented text from jsonb';

create function pg_catalog.jsonb_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_recv(unknown) is 'I/O';

create function pg_catalog.jsonb_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_send(unknown) is 'I/O';

create function pg_catalog.jsonb_set(jsonb_in unknown, path unknown, replacement unknown, create_if_missing unknown default true) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set(unknown, unknown, unknown, unknown) is 'Set part of a jsonb';

create function pg_catalog.jsonb_set_lax(jsonb_in unknown, path unknown, replacement unknown, create_if_missing unknown default true, null_value_treatment unknown default 'use_json_null'::text) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set_lax(unknown, unknown, unknown, unknown, unknown) is 'Set part of a jsonb, handle NULL value';

create function pg_catalog.jsonb_strip_nulls(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_strip_nulls(unknown) is 'remove object fields with null values from jsonb';

create function pg_catalog.jsonb_subscript_handler(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_subscript_handler(unknown) is 'jsonb subscripting logic';

create function pg_catalog.jsonb_to_record(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_record(unknown) is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_to_recordset(unknown) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_recordset(unknown) is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.jsonb_to_tsvector(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(unknown, unknown) is 'transform specified values from jsonb to tsvector';

create function pg_catalog.jsonb_to_tsvector(unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(unknown, unknown, unknown) is 'transform specified values from jsonb to tsvector';

create function pg_catalog.jsonb_typeof(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_typeof(unknown) is 'get the type of a jsonb value';

create function pg_catalog.jsonpath_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_in(unknown) is 'I/O';

create function pg_catalog.jsonpath_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_out(unknown) is 'I/O';

create function pg_catalog.jsonpath_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_recv(unknown) is 'I/O';

create function pg_catalog.jsonpath_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_send(unknown) is 'I/O';

create function pg_catalog.justify_days(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_days(unknown) is 'promote groups of 30 days to numbers of months';

create function pg_catalog.justify_hours(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_hours(unknown) is 'promote groups of 24 hours to numbers of days';

create function pg_catalog.justify_interval(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_interval(unknown) is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

create function pg_catalog.koi8r_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8R to ISO-8859-5';

create function pg_catalog.koi8r_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8R to MULE_INTERNAL';

create function pg_catalog.koi8r_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8R to UTF8';

create function pg_catalog.koi8r_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8R to WIN1251';

create function pg_catalog.koi8r_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8R to WIN866';

create function pg_catalog.koi8u_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8u_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for KOI8U to UTF8';

create function pg_catalog.lag(unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(unknown) is 'fetch the preceding row value';

create function pg_catalog.lag(unknown, unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(unknown, unknown) is 'fetch the Nth preceding row value';

create function pg_catalog.lag(unknown, unknown, unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(unknown, unknown, unknown) is 'fetch the Nth preceding row value with default';

create function pg_catalog.language_handler_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_in(unknown) is 'I/O';

create function pg_catalog.language_handler_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_out(unknown) is 'I/O';

create function pg_catalog.last_value(unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.last_value(unknown) is 'fetch the last row value';

create function pg_catalog.lastval() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lastval() is 'current value from last used sequence';

create function pg_catalog.latin1_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin1_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN1 to MULE_INTERNAL';

create function pg_catalog.latin2_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN2 to MULE_INTERNAL';

create function pg_catalog.latin2_to_win1250(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_win1250(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN2 to WIN1250';

create function pg_catalog.latin3_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin3_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN3 to MULE_INTERNAL';

create function pg_catalog.latin4_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin4_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for LATIN4 to MULE_INTERNAL';

create function pg_catalog.lead(unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(unknown) is 'fetch the following row value';

create function pg_catalog.lead(unknown, unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(unknown, unknown) is 'fetch the Nth following row value';

create function pg_catalog.lead(unknown, unknown, unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(unknown, unknown, unknown) is 'fetch the Nth following row value with default';

create function pg_catalog."left"(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."left"(unknown, unknown) is 'extract the first n characters';

create function pg_catalog.length(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown, unknown) is 'length of string in specified encoding';

create function pg_catalog.likejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of LIKE';

create function pg_catalog.likesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of LIKE';

create function pg_catalog.line(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line(unknown, unknown) is 'construct line from points';

create function pg_catalog.line_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.line_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.line_horizontal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_horizontal(unknown) is 'implementation of ?- operator';

create function pg_catalog.line_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_in(unknown) is 'I/O';

create function pg_catalog.line_interpt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_interpt(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.line_intersect(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_intersect(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.line_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_out(unknown) is 'I/O';

create function pg_catalog.line_parallel(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_parallel(unknown, unknown) is 'implementation of ?|| operator';

create function pg_catalog.line_perp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_perp(unknown, unknown) is 'implementation of ?-| operator';

create function pg_catalog.line_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_recv(unknown) is 'I/O';

create function pg_catalog.line_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_send(unknown) is 'I/O';

create function pg_catalog.line_vertical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_vertical(unknown) is 'implementation of ?| operator';

create function pg_catalog.lo_close(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_close(unknown) is 'large object close';

create function pg_catalog.lo_creat(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_creat(unknown) is 'large object create';

create function pg_catalog.lo_create(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_create(unknown) is 'large object create';

create function pg_catalog.lo_export(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_export(unknown, unknown) is 'large object export';

create function pg_catalog.lo_from_bytea(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_from_bytea(unknown, unknown) is 'create new large object with given content';

create function pg_catalog.lo_get(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(unknown) is 'read entire large object';

create function pg_catalog.lo_get(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(unknown, unknown, unknown) is 'read large object from offset for length';

create function pg_catalog.lo_import(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(unknown) is 'large object import';

create function pg_catalog.lo_import(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(unknown, unknown) is 'large object import';

create function pg_catalog.lo_lseek(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek(unknown, unknown, unknown) is 'large object seek';

create function pg_catalog.lo_lseek64(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek64(unknown, unknown, unknown) is 'large object seek (64 bit)';

create function pg_catalog.lo_open(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_open(unknown, unknown) is 'large object open';

create function pg_catalog.lo_put(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_put(unknown, unknown, unknown) is 'write data at offset';

create function pg_catalog.lo_tell(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell(unknown) is 'large object position';

create function pg_catalog.lo_tell64(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell64(unknown) is 'large object position (64 bit)';

create function pg_catalog.lo_truncate(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate(unknown, unknown) is 'truncate large object';

create function pg_catalog.lo_truncate64(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate64(unknown, unknown) is 'truncate large object (64 bit)';

create function pg_catalog.lo_unlink(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_unlink(unknown) is 'large object unlink (delete)';

create function pg_catalog.log(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(unknown, unknown) is 'logarithm base m of n';

create function pg_catalog.loread(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.loread(unknown, unknown) is 'large object read';

create function pg_catalog.lowrite(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lowrite(unknown, unknown) is 'large object write';

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(unknown, unknown) is 'left-pad string to length';

create function pg_catalog.lpad(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(unknown, unknown, unknown) is 'left-pad string to length';

create function pg_catalog.lseg(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(unknown) is 'diagonal of';

create function pg_catalog.lseg(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(unknown, unknown) is 'convert points to line segment';

create function pg_catalog.lseg_center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_center(unknown) is 'implementation of @@ operator';

create function pg_catalog.lseg_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.lseg_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.lseg_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.lseg_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.lseg_horizontal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_horizontal(unknown) is 'implementation of ?- operator';

create function pg_catalog.lseg_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_in(unknown) is 'I/O';

create function pg_catalog.lseg_interpt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_interpt(unknown, unknown) is 'implementation of # operator';

create function pg_catalog.lseg_intersect(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_intersect(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.lseg_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.lseg_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_length(unknown) is 'implementation of @-@ operator';

create function pg_catalog.lseg_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.lseg_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.lseg_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_out(unknown) is 'I/O';

create function pg_catalog.lseg_parallel(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_parallel(unknown, unknown) is 'implementation of ?|| operator';

create function pg_catalog.lseg_perp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_perp(unknown, unknown) is 'implementation of ?-| operator';

create function pg_catalog.lseg_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_recv(unknown) is 'I/O';

create function pg_catalog.lseg_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_send(unknown) is 'I/O';

create function pg_catalog.lseg_vertical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_vertical(unknown) is 'implementation of ?| operator';

create function pg_catalog.ltrim(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(unknown) is 'trim spaces from left end of string';

create function pg_catalog.macaddr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr(unknown) is 'convert macaddr8 to macaddr';

create function pg_catalog.macaddr8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8(unknown) is 'convert macaddr to macaddr8';

create function pg_catalog.macaddr8_and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_and(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.macaddr8_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.macaddr8_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.macaddr8_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.macaddr8_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.macaddr8_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_in(unknown) is 'I/O';

create function pg_catalog.macaddr8_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.macaddr8_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.macaddr8_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.macaddr8_not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_not(unknown) is 'implementation of ~ operator';

create function pg_catalog.macaddr8_or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_or(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.macaddr8_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_out(unknown) is 'I/O';

create function pg_catalog.macaddr8_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_recv(unknown) is 'I/O';

create function pg_catalog.macaddr8_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_send(unknown) is 'I/O';

create function pg_catalog.macaddr8_set7bit(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_set7bit(unknown) is 'set 7th bit in macaddr8';

create function pg_catalog.macaddr_and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_and(unknown, unknown) is 'implementation of & operator';

create function pg_catalog.macaddr_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.macaddr_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.macaddr_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.macaddr_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.macaddr_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_in(unknown) is 'I/O';

create function pg_catalog.macaddr_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.macaddr_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.macaddr_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.macaddr_not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_not(unknown) is 'implementation of ~ operator';

create function pg_catalog.macaddr_or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_or(unknown, unknown) is 'implementation of | operator';

create function pg_catalog.macaddr_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_out(unknown) is 'I/O';

create function pg_catalog.macaddr_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_recv(unknown) is 'I/O';

create function pg_catalog.macaddr_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_send(unknown) is 'I/O';

create function pg_catalog.macaddr_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_sortsupport(unknown) is 'sort support';

create function pg_catalog.make_date(year unknown, month unknown, day unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_date(unknown, unknown, unknown) is 'construct date';

create function pg_catalog.make_interval(years unknown default 0, months unknown default 0, weeks unknown default 0, days unknown default 0, hours unknown default 0, mins unknown default 0, secs unknown default 0.0) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_interval(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'construct interval';

create function pg_catalog.make_time(hour unknown, min unknown, sec unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_time(unknown, unknown, unknown) is 'construct time';

create function pg_catalog.make_timestamp(year unknown, month unknown, mday unknown, hour unknown, min unknown, sec unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamp(unknown, unknown, unknown, unknown, unknown, unknown) is 'construct timestamp';

create function pg_catalog.make_timestamptz(year unknown, month unknown, mday unknown, hour unknown, min unknown, sec unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(unknown, unknown, unknown, unknown, unknown, unknown) is 'construct timestamp with time zone';

create function pg_catalog.make_timestamptz(year unknown, month unknown, mday unknown, hour unknown, min unknown, sec unknown, timezone unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'construct timestamp with time zone';

create function pg_catalog.makeaclitem(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.makeaclitem(unknown, unknown, unknown, unknown) is 'make ACL item';

create function pg_catalog.masklen(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.masklen(unknown) is 'netmask length';

create function pg_catalog.matchingjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for generic matching operators';

create function pg_catalog.matchingsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingsel(unknown, unknown, unknown, unknown) is 'restriction selectivity for generic matching operators';

create function pg_catalog.mic_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to BIG5';

create function pg_catalog.mic_to_euc_cn(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_cn(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to EUC_CN';

create function pg_catalog.mic_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to EUC_JP';

create function pg_catalog.mic_to_euc_kr(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_kr(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to EUC_KR';

create function pg_catalog.mic_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to EUC_TW';

create function pg_catalog.mic_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

create function pg_catalog.mic_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to KOI8R';

create function pg_catalog.mic_to_latin1(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin1(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to LATIN1';

create function pg_catalog.mic_to_latin2(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin2(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to LATIN2';

create function pg_catalog.mic_to_latin3(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin3(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to LATIN3';

create function pg_catalog.mic_to_latin4(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin4(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to LATIN4';

create function pg_catalog.mic_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to SJIS';

create function pg_catalog.mic_to_win1250(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1250(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to WIN1250';

create function pg_catalog.mic_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to WIN1251';

create function pg_catalog.mic_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for MULE_INTERNAL to WIN866';

create function pg_catalog.min_scale(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.min_scale(unknown) is 'minimum scale needed to represent the value';

create function pg_catalog.mode_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mode_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.mul_d_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mul_d_interval(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange(unknown) is 'anymultirange cast';

create function pg_catalog.multirange_adjacent_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_adjacent_multirange(unknown, unknown) is 'implementation of -|- operator';

create function pg_catalog.multirange_adjacent_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_adjacent_range(unknown, unknown) is 'implementation of -|- operator';

create function pg_catalog.multirange_after_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_after_multirange(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.multirange_after_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_after_range(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.multirange_before_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_before_multirange(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.multirange_before_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_before_range(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.multirange_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.multirange_contained_by_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contained_by_multirange(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.multirange_contained_by_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contained_by_range(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.multirange_contains_elem(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_elem(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.multirange_contains_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_multirange(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.multirange_contains_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_range(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.multirange_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.multirange_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.multirange_gist_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gist_compress(unknown) is 'GiST support';

create function pg_catalog.multirange_gist_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gist_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.multirange_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.multirange_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.multirange_intersect(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_intersect(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.multirange_intersect_agg_transfn(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_intersect_agg_transfn(unknown, unknown) is 'range aggregate by intersecting';

create function pg_catalog.multirange_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.multirange_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.multirange_minus(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_minus(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.multirange_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.multirange_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_out(unknown) is 'I/O';

create function pg_catalog.multirange_overlaps_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overlaps_multirange(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.multirange_overlaps_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overlaps_range(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.multirange_overleft_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overleft_multirange(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.multirange_overleft_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overleft_range(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.multirange_overright_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overright_multirange(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.multirange_overright_range(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overright_range(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.multirange_recv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.multirange_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_send(unknown) is 'I/O';

create function pg_catalog.multirange_typanalyze(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_typanalyze(unknown) is 'multirange typanalyze';

create function pg_catalog.multirange_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_union(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.multirangesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirangesel(unknown, unknown, unknown, unknown) is 'restriction selectivity for multirange operators';

create function pg_catalog.mxid_age(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mxid_age(unknown) is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

create function pg_catalog.nameconcatoid(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameconcatoid(unknown, unknown) is 'concatenate name and oid';

create function pg_catalog.nameeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.nameeqtext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeqtext(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.namege(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namege(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.namegetext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegetext(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.namegt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.namegttext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegttext(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.nameiclike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameiclike(unknown, unknown) is 'implementation of ~~* operator';

create function pg_catalog.nameicnlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicnlike(unknown, unknown) is 'implementation of !~~* operator';

create function pg_catalog.nameicregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexeq(unknown, unknown) is 'implementation of ~* operator';

create function pg_catalog.nameicregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexne(unknown, unknown) is 'implementation of !~* operator';

create function pg_catalog.namein(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namein(unknown) is 'I/O';

create function pg_catalog.namele(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namele(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.nameletext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameletext(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.namelike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelike(unknown, unknown) is 'implementation of ~~ operator';

create function pg_catalog.namelt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.namelttext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelttext(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.namene(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namene(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.namenetext(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenetext(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.namenlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenlike(unknown, unknown) is 'implementation of !~~ operator';

create function pg_catalog.nameout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameout(unknown) is 'I/O';

create function pg_catalog.namerecv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namerecv(unknown) is 'I/O';

create function pg_catalog.nameregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexeq(unknown, unknown) is 'implementation of ~ operator';

create function pg_catalog.nameregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexne(unknown, unknown) is 'implementation of !~ operator';

create function pg_catalog.namesend(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namesend(unknown) is 'I/O';

create function pg_catalog.neqjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of <> and related operators';

create function pg_catalog.neqsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of <> and related operators';

create function pg_catalog.netmask(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.netmask(unknown) is 'netmask of address';

create function pg_catalog.network(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network(unknown) is 'network part of address';

create function pg_catalog.network_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.network_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.network_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.network_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.network_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.network_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.network_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.network_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.network_overlap(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_overlap(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.network_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.network_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sortsupport(unknown) is 'sort support';

create function pg_catalog.network_sub(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sub(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.network_subeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subeq(unknown, unknown) is 'implementation of <<= operator';

create function pg_catalog.network_subset_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subset_support(unknown) is 'planner support for network_sub/superset';

create function pg_catalog.network_sup(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sup(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.network_supeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_supeq(unknown, unknown) is 'implementation of >>= operator';

create function pg_catalog.networkjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networkjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for network operators';

create function pg_catalog.networksel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networksel(unknown, unknown, unknown, unknown) is 'restriction selectivity for network operators';

create function pg_catalog.nextval(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nextval(unknown) is 'sequence next value';

create function pg_catalog.nlikejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of NOT LIKE';

create function pg_catalog.nlikesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of NOT LIKE';

create function pg_catalog.normalize(unknown, unknown default 'NFC'::text) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.normalize(unknown, unknown) is 'Unicode normalization';

create function pg_catalog.now() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.now() is 'current transaction time';

create function pg_catalog.nth_value(unknown, unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nth_value(unknown, unknown) is 'fetch the Nth row value';

create function pg_catalog.ntile(unknown) returns unknown
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ntile(unknown) is 'split rows into N groups';

create function pg_catalog.num_nonnulls(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nonnulls(unknown) is 'count the number of non-NULL arguments';

create function pg_catalog.num_nulls(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nulls(unknown) is 'count the number of NULL arguments';

create function pg_catalog.numeric(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown, unknown) is 'adjust numeric to typmod precision/scale';

create function pg_catalog.numeric_abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_abs(unknown) is 'implementation of @ operator';

create function pg_catalog.numeric_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.numeric_accum_inv(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum_inv(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.numeric_add(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_add(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.numeric_avg(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg(unknown) is 'aggregate final function';

create function pg_catalog.numeric_avg_accum(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_accum(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.numeric_avg_combine(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.numeric_avg_deserialize(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_deserialize(unknown, unknown) is 'aggregate deserial function';

create function pg_catalog.numeric_avg_serialize(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_serialize(unknown) is 'aggregate serial function';

create function pg_catalog.numeric_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.numeric_combine(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.numeric_deserialize(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_deserialize(unknown, unknown) is 'aggregate deserial function';

create function pg_catalog.numeric_div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.numeric_div_trunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div_trunc(unknown, unknown) is 'trunc(x/y)';

create function pg_catalog.numeric_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.numeric_exp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_exp(unknown) is 'natural exponential (e^x)';

create function pg_catalog.numeric_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.numeric_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.numeric_in(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.numeric_inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_inc(unknown) is 'increment by one';

create function pg_catalog.numeric_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.numeric_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.numeric_ln(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ln(unknown) is 'natural logarithm';

create function pg_catalog.numeric_log(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_log(unknown, unknown) is 'logarithm base m of n';

create function pg_catalog.numeric_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.numeric_mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mod(unknown, unknown) is 'implementation of % operator';

create function pg_catalog.numeric_mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.numeric_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.numeric_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_out(unknown) is 'I/O';

create function pg_catalog.numeric_pl_pg_lsn(numeric, pg_lsn) returns pg_lsn
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_pl_pg_lsn(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.numeric_poly_avg(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_avg(unknown) is 'aggregate final function';

create function pg_catalog.numeric_poly_combine(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_combine(unknown, unknown) is 'aggregate combine function';

create function pg_catalog.numeric_poly_deserialize(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_deserialize(unknown, unknown) is 'aggregate deserial function';

create function pg_catalog.numeric_poly_serialize(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_serialize(unknown) is 'aggregate serial function';

create function pg_catalog.numeric_poly_stddev_pop(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_pop(unknown) is 'aggregate final function';

create function pg_catalog.numeric_poly_stddev_samp(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_samp(unknown) is 'aggregate final function';

create function pg_catalog.numeric_poly_sum(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_sum(unknown) is 'aggregate final function';

create function pg_catalog.numeric_poly_var_pop(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_pop(unknown) is 'aggregate final function';

create function pg_catalog.numeric_poly_var_samp(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_samp(unknown) is 'aggregate final function';

create function pg_catalog.numeric_power(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_power(unknown, unknown) is 'implementation of ^ operator';

create function pg_catalog.numeric_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.numeric_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_send(unknown) is 'I/O';

create function pg_catalog.numeric_serialize(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_serialize(unknown) is 'aggregate serial function';

create function pg_catalog.numeric_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.numeric_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sortsupport(unknown) is 'sort support';

create function pg_catalog.numeric_sqrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sqrt(unknown) is 'square root';

create function pg_catalog.numeric_stddev_pop(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_pop(unknown) is 'aggregate final function';

create function pg_catalog.numeric_stddev_samp(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_samp(unknown) is 'aggregate final function';

create function pg_catalog.numeric_sub(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sub(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.numeric_sum(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sum(unknown) is 'aggregate final function';

create function pg_catalog.numeric_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_support(unknown) is 'planner support for numeric length coercion';

create function pg_catalog.numeric_uminus(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uminus(unknown) is 'implementation of - operator';

create function pg_catalog.numeric_uplus(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uplus(unknown) is 'implementation of + operator';

create function pg_catalog.numeric_var_pop(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_pop(unknown) is 'aggregate final function';

create function pg_catalog.numeric_var_samp(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_samp(unknown) is 'aggregate final function';

create function pg_catalog.numerictypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodin(unknown) is 'I/O typmod';

create function pg_catalog.numerictypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodout(unknown) is 'I/O typmod';

create function pg_catalog.nummultirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange() is 'nummultirange constructor';

create function pg_catalog.numnode(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numnode(unknown) is 'number of nodes';

create function pg_catalog.numrange(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(unknown, unknown) is 'numrange constructor';

create function pg_catalog.numrange(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(unknown, unknown, unknown) is 'numrange constructor';

create function pg_catalog.numrange_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange_subdiff(unknown, unknown) is 'float8 difference of two numeric values';

create function pg_catalog.obj_description(oid) returns text
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description(unknown) is 'deprecated, use two-argument form instead';

create function pg_catalog.obj_description(oid, name) returns text
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description(unknown, unknown) is 'get description for object id and catalog name';

create function pg_catalog.oid(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oid(unknown) is 'convert int8 to oid';

create function pg_catalog.oideq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oideq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.oidge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.oidgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.oidin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidin(unknown) is 'I/O';

create function pg_catalog.oidlarger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlarger(unknown, unknown) is 'larger of two';

create function pg_catalog.oidle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.oidlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.oidne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.oidout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidout(unknown) is 'I/O';

create function pg_catalog.oidrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidrecv(unknown) is 'I/O';

create function pg_catalog.oidsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsend(unknown) is 'I/O';

create function pg_catalog.oidsmaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsmaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.oidvectoreq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectoreq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.oidvectorge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.oidvectorgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.oidvectorin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorin(unknown) is 'I/O';

create function pg_catalog.oidvectorle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.oidvectorlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.oidvectorne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.oidvectorout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorout(unknown) is 'I/O';

create function pg_catalog.oidvectorrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorrecv(unknown) is 'I/O';

create function pg_catalog.oidvectorsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorsend(unknown) is 'I/O';

create function pg_catalog.oidvectortypes(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectortypes(unknown) is 'print type names of oidvector field';

create function pg_catalog.on_pb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pb(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.on_pl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pl(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.on_ppath(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ppath(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.on_ps(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ps(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.on_sb(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sb(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.on_sl(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sl(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.ordered_set_transition(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.ordered_set_transition_multi(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition_multi(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.parse_ident(str unknown, strict unknown default true) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.parse_ident(unknown, unknown) is 'parse qualified identifier to array of identifiers';

create function pg_catalog.path(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path(unknown) is 'convert polygon to path';

create function pg_catalog.path_add(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.path_add_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add_pt(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.path_center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_center(unknown) is 'implementation of @@ operator';

create function pg_catalog.path_contain_pt(path, point) returns boolean
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_contain_pt(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.path_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.path_div_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_div_pt(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.path_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_in(unknown) is 'I/O';

create function pg_catalog.path_inter(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_inter(unknown, unknown) is 'implementation of ?# operator';

create function pg_catalog.path_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_length(unknown) is 'implementation of @-@ operator';

create function pg_catalog.path_mul_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_mul_pt(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.path_n_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.path_n_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.path_n_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.path_n_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.path_n_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.path_npoints(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_npoints(unknown) is 'implementation of # operator';

create function pg_catalog.path_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_out(unknown) is 'I/O';

create function pg_catalog.path_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_recv(unknown) is 'I/O';

create function pg_catalog.path_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_send(unknown) is 'I/O';

create function pg_catalog.path_sub_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_sub_pt(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.pclose(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pclose(unknown) is 'close path';

create function pg_catalog.percent_rank() returns unknown
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank() is 'fractional rank within partition';

create function pg_catalog.percent_rank_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_multi_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_multi_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_multi_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_multi_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_disc_final(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_final(unknown, unknown, unknown) is 'aggregate final function';

create function pg_catalog.percentile_disc_multi_final(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_multi_final(unknown, unknown, unknown) is 'aggregate final function';

create function pg_catalog.pg_advisory_lock(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(unknown) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(unknown, unknown) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(unknown) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_lock_shared(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(unknown, unknown) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_unlock(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(unknown) is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(unknown, unknown) is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock_all() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_all() is 'release all advisory locks';

create function pg_catalog.pg_advisory_unlock_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(unknown) is 'release shared advisory lock';

create function pg_catalog.pg_advisory_unlock_shared(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(unknown, unknown) is 'release shared advisory lock';

create function pg_catalog.pg_advisory_xact_lock(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(unknown) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(unknown, unknown) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(unknown) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(unknown, unknown) is 'obtain shared advisory lock';

create function pg_catalog.pg_available_extension_versions(out name unknown, out version unknown, out superuser unknown, out trusted unknown, out relocatable unknown, out schema unknown, out requires unknown, out comment unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_available_extension_versions(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'list available extension versions';

create function pg_catalog.pg_available_extensions(out name unknown, out default_version unknown, out comment unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_available_extensions(out unknown, out unknown, out unknown) is 'list available extensions';

create function pg_catalog.pg_backend_pid() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backend_pid() is 'statistics: current backend PID';

create function pg_catalog.pg_backup_start_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backup_start_time() is 'start time of an online backup';

create function pg_catalog.pg_blocking_pids(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_blocking_pids(unknown) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

create function pg_catalog.pg_cancel_backend(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cancel_backend(unknown) is 'cancel a server process'' current query';

create function pg_catalog.pg_char_to_encoding(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_char_to_encoding(unknown) is 'convert encoding name to encoding id';

create function pg_catalog.pg_client_encoding() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_client_encoding() is 'encoding name of current database';

create function pg_catalog.pg_collation_actual_version(unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_actual_version(unknown) is 'get actual version of collation from operating system';

create function pg_catalog.pg_collation_for(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_for(unknown) is 'collation of the argument; implementation of the COLLATION FOR expression';

create function pg_catalog.pg_collation_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_is_visible(unknown) is 'is collation visible in search path?';

create function pg_catalog.pg_column_compression(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_compression(unknown) is 'compression method for the compressed datum';

create function pg_catalog.pg_column_is_updatable(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_is_updatable(unknown, unknown, unknown) is 'is a column updatable';

create function pg_catalog.pg_column_size(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_size(unknown) is 'bytes required to store the value, perhaps with compression';

create function pg_catalog.pg_conf_load_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conf_load_time() is 'configuration load time';

create function pg_catalog.pg_config(out name unknown, out setting unknown) returns setof unknown
    stable
    strict
    cost 1
    rows 23
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_config(out unknown, out unknown) is 'pg_config binary as a function';

create function pg_catalog.pg_control_checkpoint(out checkpoint_lsn unknown, out redo_lsn unknown, out redo_wal_file unknown, out timeline_id unknown, out prev_timeline_id unknown, out full_page_writes unknown, out next_xid unknown, out next_oid unknown, out next_multixact_id unknown, out next_multi_offset unknown, out oldest_xid unknown, out oldest_xid_dbid unknown, out oldest_active_xid unknown, out oldest_multi_xid unknown, out oldest_multi_dbid unknown, out oldest_commit_ts_xid unknown, out newest_commit_ts_xid unknown, out checkpoint_time unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_checkpoint(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'pg_controldata checkpoint state information as a function';

create function pg_catalog.pg_control_init(out max_data_alignment unknown, out database_block_size unknown, out blocks_per_segment unknown, out wal_block_size unknown, out bytes_per_wal_segment unknown, out max_identifier_length unknown, out max_index_columns unknown, out max_toast_chunk_size unknown, out large_object_chunk_size unknown, out float8_pass_by_value unknown, out data_page_checksum_version unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_init(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'pg_controldata init state information as a function';

create function pg_catalog.pg_control_recovery(out min_recovery_end_lsn unknown, out min_recovery_end_timeline unknown, out backup_start_lsn unknown, out backup_end_lsn unknown, out end_of_backup_record_required unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_recovery(out unknown, out unknown, out unknown, out unknown, out unknown) is 'pg_controldata recovery state information as a function';

create function pg_catalog.pg_control_system(out pg_control_version unknown, out catalog_version_no unknown, out system_identifier unknown, out pg_control_last_modified unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_system(out unknown, out unknown, out unknown, out unknown) is 'pg_controldata general state information as a function';

create function pg_catalog.pg_conversion_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conversion_is_visible(unknown) is 'is conversion visible in search path?';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name unknown, dst_slot_name unknown, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(unknown, unknown, out unknown, out unknown) is 'copy a logical replication slot';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name unknown, dst_slot_name unknown, temporary unknown, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(unknown, unknown, unknown, out unknown, out unknown) is 'copy a logical replication slot, changing temporality';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name unknown, dst_slot_name unknown, temporary unknown, plugin unknown, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(unknown, unknown, unknown, unknown, out unknown, out unknown) is 'copy a logical replication slot, changing temporality and plugin';

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name unknown, dst_slot_name unknown, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(unknown, unknown, out unknown, out unknown) is 'copy a physical replication slot';

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name unknown, dst_slot_name unknown, temporary unknown, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(unknown, unknown, unknown, out unknown, out unknown) is 'copy a physical replication slot, changing temporality';

create function pg_catalog.pg_create_logical_replication_slot(slot_name unknown, plugin unknown, temporary unknown default false, twophase unknown default false, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_logical_replication_slot(unknown, unknown, unknown, unknown, out unknown, out unknown) is 'set up a logical replication slot';

create function pg_catalog.pg_create_physical_replication_slot(slot_name unknown, immediately_reserve unknown default false, temporary unknown default false, out slot_name unknown, out lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_physical_replication_slot(unknown, unknown, unknown, out unknown, out unknown) is 'create a physical replication slot';

create function pg_catalog.pg_create_restore_point(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_restore_point(unknown) is 'create a named restore point';

create function pg_catalog.pg_current_logfile() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile() is 'current logging collector file location';

create function pg_catalog.pg_current_logfile(unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile(unknown) is 'current logging collector file location';

create function pg_catalog.pg_current_snapshot() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_snapshot() is 'get current snapshot';

create function pg_catalog.pg_current_wal_flush_lsn() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_flush_lsn() is 'current wal flush location';

create function pg_catalog.pg_current_wal_insert_lsn() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_insert_lsn() is 'current wal insert location';

create function pg_catalog.pg_current_wal_lsn() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_lsn() is 'current wal write location';

create function pg_catalog.pg_current_xact_id() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id() is 'get current transaction ID';

create function pg_catalog.pg_current_xact_id_if_assigned() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id_if_assigned() is 'get current transaction ID';

create function pg_catalog.pg_cursor(out name unknown, out statement unknown, out is_holdable unknown, out is_binary unknown, out is_scrollable unknown, out creation_time unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cursor(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'get the open cursors for this session';

create function pg_catalog.pg_ddl_command_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_in(unknown) is 'I/O';

create function pg_catalog.pg_ddl_command_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_out(unknown) is 'I/O';

create function pg_catalog.pg_ddl_command_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_recv(unknown) is 'I/O';

create function pg_catalog.pg_ddl_command_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_send(unknown) is 'I/O';

create function pg_catalog.pg_dependencies_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_in(unknown) is 'I/O';

create function pg_catalog.pg_dependencies_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_out(unknown) is 'I/O';

create function pg_catalog.pg_dependencies_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_recv(unknown) is 'I/O';

create function pg_catalog.pg_dependencies_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_send(unknown) is 'I/O';

create function pg_catalog.pg_describe_object(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_describe_object(unknown, unknown, unknown) is 'get identification of SQL object';

create function pg_catalog.pg_drop_replication_slot(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_drop_replication_slot(unknown) is 'drop a replication slot';

create function pg_catalog.pg_encoding_max_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_max_length(unknown) is 'maximum octet length of a character in given encoding';

create function pg_catalog.pg_encoding_to_char(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_to_char(unknown) is 'convert encoding id to encoding name';

create function pg_catalog.pg_event_trigger_ddl_commands(out classid unknown, out objid unknown, out objsubid unknown, out command_tag unknown, out object_type unknown, out schema_name unknown, out object_identity unknown, out in_extension unknown, out command unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'list DDL actions being executed by the current command';

create function pg_catalog.pg_event_trigger_dropped_objects(out classid unknown, out objid unknown, out objsubid unknown, out original unknown, out normal unknown, out is_temporary unknown, out object_type unknown, out schema_name unknown, out object_name unknown, out object_identity unknown, out address_names unknown, out address_args unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'list objects dropped by the current command';

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out unknown) is 'return Oid of the table getting rewritten';

create function pg_catalog.pg_event_trigger_table_rewrite_reason() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason() is 'return reason code for table getting rewritten';

create function pg_catalog.pg_export_snapshot() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_export_snapshot() is 'export a snapshot';

create function pg_catalog.pg_extension_config_dump(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_config_dump(unknown, unknown) is 'flag an extension''s table contents to be emitted by pg_dump';

create function pg_catalog.pg_extension_update_paths(name unknown, out source unknown, out target unknown, out path unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_update_paths(unknown, out unknown, out unknown, out unknown) is 'list an extension''s version update paths';

create function pg_catalog.pg_filenode_relation(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_filenode_relation(unknown, unknown) is 'relation OID for filenode and tablespace';

create function pg_catalog.pg_function_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_function_is_visible(unknown) is 'is function visible in search path?';

create function pg_catalog.pg_get_backend_memory_contexts(out name unknown, out ident unknown, out parent unknown, out level unknown, out total_bytes unknown, out total_nblocks unknown, out free_bytes unknown, out free_chunks unknown, out used_bytes unknown) returns setof unknown
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_backend_memory_contexts(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'information about all memory contexts of local backend';

create function pg_catalog.pg_get_catalog_foreign_keys(out fktable unknown, out fkcols unknown, out pktable unknown, out pkcols unknown, out is_array unknown, out is_opt unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 250
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_catalog_foreign_keys(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'list of catalog foreign key relationships';

create function pg_catalog.pg_get_constraintdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(unknown) is 'constraint description';

create function pg_catalog.pg_get_constraintdef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(unknown, unknown) is 'constraint description with pretty-print option';

create function pg_catalog.pg_get_expr(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(unknown, unknown) is 'deparse an encoded expression';

create function pg_catalog.pg_get_expr(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(unknown, unknown, unknown) is 'deparse an encoded expression with pretty-print option';

create function pg_catalog.pg_get_function_arg_default(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arg_default(unknown, unknown) is 'function argument default';

create function pg_catalog.pg_get_function_arguments(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arguments(unknown) is 'argument list of a function';

create function pg_catalog.pg_get_function_identity_arguments(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_identity_arguments(unknown) is 'identity argument list of a function';

create function pg_catalog.pg_get_function_result(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_result(unknown) is 'result type of a function';

create function pg_catalog.pg_get_function_sqlbody(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_sqlbody(unknown) is 'function SQL body';

create function pg_catalog.pg_get_functiondef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_functiondef(unknown) is 'definition of a function';

create function pg_catalog.pg_get_indexdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(unknown) is 'index description';

create function pg_catalog.pg_get_indexdef(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(unknown, unknown, unknown) is 'index description (full create statement or single expression) with pretty-print option';

create function pg_catalog.pg_get_keywords(out word unknown, out catcode unknown, out barelabel unknown, out catdesc unknown, out baredesc unknown) returns setof unknown
    stable
    strict
    cost 10
    rows 500
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_keywords(out unknown, out unknown, out unknown, out unknown, out unknown) is 'list of SQL keywords';

create function pg_catalog.pg_get_multixact_members(multixid unknown, out xid unknown, out mode unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_multixact_members(unknown, out unknown, out unknown) is 'view members of a multixactid';

create function pg_catalog.pg_get_object_address(type unknown, object_names unknown, object_args unknown, out classid unknown, out objid unknown, out objsubid unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_object_address(unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'get OID-based object address from name/args arrays';

create function pg_catalog.pg_get_partition_constraintdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partition_constraintdef(unknown) is 'partition constraint description';

create function pg_catalog.pg_get_partkeydef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partkeydef(unknown) is 'partition key description';

create function pg_catalog.pg_get_publication_tables(pubname unknown, out relid unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_publication_tables(unknown, out unknown) is 'get OIDs of tables in a publication';

create function pg_catalog.pg_get_replica_identity_index(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replica_identity_index(unknown) is 'oid of replica identity index if any';

create function pg_catalog.pg_get_replication_slots(out slot_name unknown, out plugin unknown, out slot_type unknown, out datoid unknown, out temporary unknown, out active unknown, out active_pid unknown, out xmin unknown, out catalog_xmin unknown, out restart_lsn unknown, out confirmed_flush_lsn unknown, out wal_status unknown, out safe_wal_size unknown, out two_phase unknown) returns setof unknown
    stable
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replication_slots(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'information about replication slots currently in use';

create function pg_catalog.pg_get_ruledef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(unknown) is 'source text of a rule';

create function pg_catalog.pg_get_ruledef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(unknown, unknown) is 'source text of a rule with pretty-print option';

create function pg_catalog.pg_get_serial_sequence(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_serial_sequence(unknown, unknown) is 'name of sequence for a serial column';

create function pg_catalog.pg_get_shmem_allocations(out name unknown, out "off" unknown, out size unknown, out allocated_size unknown) returns setof unknown
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_shmem_allocations(out unknown, out unknown, out unknown, out unknown) is 'allocations from the main shared memory segment';

create function pg_catalog.pg_get_statisticsobjdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef(unknown) is 'extended statistics object description';

create function pg_catalog.pg_get_statisticsobjdef_columns(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef_columns(unknown) is 'extended statistics columns';

create function pg_catalog.pg_get_statisticsobjdef_expressions(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef_expressions(unknown) is 'extended statistics expressions';

create function pg_catalog.pg_get_triggerdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(unknown) is 'trigger description';

create function pg_catalog.pg_get_triggerdef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(unknown, unknown) is 'trigger description with pretty-print option';

create function pg_catalog.pg_get_userbyid(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_userbyid(unknown) is 'role name by OID (with fallback)';

create function pg_catalog.pg_get_wal_replay_pause_state() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_wal_replay_pause_state() is 'get wal replay pause state';

create function pg_catalog.pg_hba_file_rules(out line_number unknown, out type unknown, out database unknown, out user_name unknown, out address unknown, out netmask unknown, out auth_method unknown, out options unknown, out error unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_hba_file_rules(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'show pg_hba.conf rules';

create function pg_catalog.pg_identify_object(classid unknown, objid unknown, objsubid unknown, out type unknown, out schema unknown, out name unknown, out identity unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object(unknown, unknown, unknown, out unknown, out unknown, out unknown, out unknown) is 'get machine-parseable identification of SQL object';

create function pg_catalog.pg_identify_object_as_address(classid unknown, objid unknown, objsubid unknown, out type unknown, out object_names unknown, out object_args unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object_as_address(unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'get identification of SQL object for pg_get_object_address()';

create function pg_catalog.pg_import_system_collations(unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_import_system_collations(unknown) is 'import collations from operating system';

create function pg_catalog.pg_index_column_has_property(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_column_has_property(unknown, unknown, unknown) is 'test property of an index column';

create function pg_catalog.pg_index_has_property(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_has_property(unknown, unknown) is 'test property of an index';

create function pg_catalog.pg_indexam_has_property(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_has_property(unknown, unknown) is 'test property of an index access method';

create function pg_catalog.pg_indexam_progress_phasename(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_progress_phasename(unknown, unknown) is 'return name of given index build phase';

create function pg_catalog.pg_indexes_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexes_size(unknown) is 'disk space usage for all indexes attached to the specified table';

create function pg_catalog.pg_is_in_backup() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_backup() is 'true if server is in online backup';

create function pg_catalog.pg_is_in_recovery() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_recovery() is 'true if server is in recovery';

create function pg_catalog.pg_is_other_temp_schema(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_other_temp_schema(unknown) is 'is schema another session''s temp schema?';

create function pg_catalog.pg_is_wal_replay_paused() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_wal_replay_paused() is 'true if wal replay is paused';

create function pg_catalog.pg_isolation_test_session_is_blocked(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_isolation_test_session_is_blocked(unknown, unknown) is 'isolationtester support function';

create function pg_catalog.pg_jit_available() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_jit_available() is 'Is JIT compilation available in this session?';

create function pg_catalog.pg_last_committed_xact(out xid unknown, out timestamp unknown, out roident unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_committed_xact(out unknown, out unknown, out unknown) is 'get transaction Id, commit timestamp and replication origin of latest transaction commit';

create function pg_catalog.pg_last_wal_receive_lsn() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_receive_lsn() is 'current wal flush location';

create function pg_catalog.pg_last_wal_replay_lsn() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_replay_lsn() is 'last wal replay location';

create function pg_catalog.pg_last_xact_replay_timestamp() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_xact_replay_timestamp() is 'timestamp of last replay xact';

create function pg_catalog.pg_listening_channels() returns setof unknown
    stable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_listening_channels() is 'get the channels that the current backend listens to';

create function pg_catalog.pg_lock_status(out locktype unknown, out database unknown, out relation unknown, out page unknown, out tuple unknown, out virtualxid unknown, out transactionid unknown, out classid unknown, out objid unknown, out objsubid unknown, out virtualtransaction unknown, out pid unknown, out mode unknown, out granted unknown, out fastpath unknown, out waitstart unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lock_status(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'view system lock information';

create function pg_catalog.pg_log_backend_memory_contexts(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_log_backend_memory_contexts(unknown) is 'log memory contexts of the specified backend';

create function pg_catalog.pg_logical_slot_get_binary_changes(slot_name unknown, upto_lsn unknown, upto_nchanges unknown, options unknown default '{}'::text[], out lsn unknown, out xid unknown, out data unknown) returns setof unknown
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(unknown, unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'get binary changes from replication slot';

create function pg_catalog.pg_logical_slot_get_changes(slot_name unknown, upto_lsn unknown, upto_nchanges unknown, options unknown default '{}'::text[], out lsn unknown, out xid unknown, out data unknown) returns setof unknown
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_get_changes(unknown, unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'get changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name unknown, upto_lsn unknown, upto_nchanges unknown, options unknown default '{}'::text[], out lsn unknown, out xid unknown, out data unknown) returns setof unknown
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(unknown, unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'peek at binary changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_changes(slot_name unknown, upto_lsn unknown, upto_nchanges unknown, options unknown default '{}'::text[], out lsn unknown, out xid unknown, out data unknown) returns setof unknown
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_peek_changes(unknown, unknown, unknown, unknown, out unknown, out unknown, out unknown) is 'peek at changes from replication slot';

create function pg_catalog.pg_ls_archive_statusdir(out name unknown, out size unknown, out modification unknown) returns setof unknown
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_archive_statusdir(out unknown, out unknown, out unknown) is 'list of files in the archive_status directory';

create function pg_catalog.pg_ls_dir(unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_dir(unknown) is 'list all files in a directory';

create function pg_catalog.pg_ls_dir(unknown, unknown, unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_dir(unknown, unknown, unknown) is 'list all files in a directory';

create function pg_catalog.pg_ls_logdir(out name unknown, out size unknown, out modification unknown) returns setof unknown
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_logdir(out unknown, out unknown, out unknown) is 'list files in the log directory';

create function pg_catalog.pg_ls_tmpdir(out name unknown, out size unknown, out modification unknown) returns setof unknown
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_tmpdir(out unknown, out unknown, out unknown) is 'list files in the pgsql_tmp directory';

create function pg_catalog.pg_ls_tmpdir(tablespace unknown, out name unknown, out size unknown, out modification unknown) returns setof unknown
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_tmpdir(unknown, out unknown, out unknown, out unknown) is 'list files in the pgsql_tmp directory';

create function pg_catalog.pg_ls_waldir(out name unknown, out size unknown, out modification unknown) returns setof unknown
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_waldir(out unknown, out unknown, out unknown) is 'list of files in the WAL directory';

create function pg_catalog.pg_lsn(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn(unknown) is 'convert numeric to pg_lsn';

create function pg_catalog.pg_lsn_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.pg_lsn_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.pg_lsn_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.pg_lsn_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.pg_lsn_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash(unknown) is 'hash';

create function pg_catalog.pg_lsn_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.pg_lsn_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_in(unknown) is 'I/O';

create function pg_catalog.pg_lsn_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.pg_lsn_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.pg_lsn_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.pg_lsn_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.pg_lsn_mii(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mii(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.pg_lsn_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.pg_lsn_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_out(unknown) is 'I/O';

create function pg_catalog.pg_lsn_pli(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_pli(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.pg_lsn_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_recv(unknown) is 'I/O';

create function pg_catalog.pg_lsn_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_send(unknown) is 'I/O';

create function pg_catalog.pg_lsn_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.pg_mcv_list_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_in(unknown) is 'I/O';

create function pg_catalog.pg_mcv_list_items(mcv_list unknown, out index unknown, out values unknown, out nulls unknown, out frequency unknown, out base_frequency unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_items(unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'details about MCV list items';

create function pg_catalog.pg_mcv_list_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_out(unknown) is 'I/O';

create function pg_catalog.pg_mcv_list_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_recv(unknown) is 'I/O';

create function pg_catalog.pg_mcv_list_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_send(unknown) is 'I/O';

create function pg_catalog.pg_my_temp_schema() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_my_temp_schema() is 'get OID of current session''s temp schema, if any';

create function pg_catalog.pg_ndistinct_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_in(unknown) is 'I/O';

create function pg_catalog.pg_ndistinct_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_out(unknown) is 'I/O';

create function pg_catalog.pg_ndistinct_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_recv(unknown) is 'I/O';

create function pg_catalog.pg_ndistinct_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_send(unknown) is 'I/O';

create function pg_catalog.pg_nextoid(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_nextoid(unknown, unknown, unknown) is 'return the next oid for a system table';

create function pg_catalog.pg_node_tree_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_in(unknown) is 'I/O';

create function pg_catalog.pg_node_tree_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_out(unknown) is 'I/O';

create function pg_catalog.pg_node_tree_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_recv(unknown) is 'I/O';

create function pg_catalog.pg_node_tree_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_send(unknown) is 'I/O';

create function pg_catalog.pg_notification_queue_usage() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notification_queue_usage() is 'get the fraction of the asynchronous notification queue currently in use';

create function pg_catalog.pg_notify(unknown, unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notify(unknown, unknown) is 'send a notification event';

create function pg_catalog.pg_opclass_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opclass_is_visible(unknown) is 'is opclass visible in search path?';

create function pg_catalog.pg_operator_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_operator_is_visible(unknown) is 'is operator visible in search path?';

create function pg_catalog.pg_opfamily_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opfamily_is_visible(unknown) is 'is opfamily visible in search path?';

create function pg_catalog.pg_options_to_table(options_array unknown, out option_name unknown, out option_value unknown) returns setof unknown
    stable
    strict
    cost 1
    rows 3
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_options_to_table(unknown, out unknown, out unknown) is 'convert generic options array to name/value table';

create function pg_catalog.pg_partition_ancestors(partitionid unknown, out relid unknown) returns setof unknown
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_ancestors(unknown, out unknown) is 'view ancestors of the partition';

create function pg_catalog.pg_partition_root(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_root(unknown) is 'get top-most partition root parent';

create function pg_catalog.pg_partition_tree(rootrelid unknown, out relid unknown, out parentrelid unknown, out isleaf unknown, out level unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_tree(unknown, out unknown, out unknown, out unknown, out unknown) is 'view partition tree tables';

create function pg_catalog.pg_postmaster_start_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_postmaster_start_time() is 'postmaster start time';

create function pg_catalog.pg_prepared_statement(out name unknown, out statement unknown, out prepare_time unknown, out parameter_types unknown, out from_sql unknown, out generic_plans unknown, out custom_plans unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_prepared_statement(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'get the prepared statements for this session';

create function pg_catalog.pg_prepared_xact(out transaction unknown, out gid unknown, out prepared unknown, out ownerid unknown, out dbid unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_prepared_xact(out unknown, out unknown, out unknown, out unknown, out unknown) is 'view two-phase transactions';

create function pg_catalog.pg_promote(wait unknown default true, wait_seconds unknown default 60) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_promote(unknown, unknown) is 'promote standby server';

create function pg_catalog.pg_read_binary_file(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(unknown) is 'read bytea from a file';

create function pg_catalog.pg_read_binary_file(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(unknown, unknown, unknown) is 'read bytea from a file';

create function pg_catalog.pg_read_binary_file(unknown, unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(unknown, unknown, unknown, unknown) is 'read bytea from a file';

create function pg_catalog.pg_read_file(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(unknown) is 'read text from a file';

create function pg_catalog.pg_read_file(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(unknown, unknown, unknown) is 'read text from a file';

create function pg_catalog.pg_read_file(unknown, unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(unknown, unknown, unknown, unknown) is 'read text from a file';

create function pg_catalog.pg_read_file_old(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file_old(unknown, unknown, unknown) is 'read text from a file - old version for adminpack 1.0';

create function pg_catalog.pg_relation_filenode(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filenode(unknown) is 'filenode identifier of relation';

create function pg_catalog.pg_relation_filepath(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filepath(unknown) is 'file path of relation';

create function pg_catalog.pg_relation_is_publishable(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_publishable(unknown) is 'returns whether a relation can be part of a publication';

create function pg_catalog.pg_relation_is_updatable(unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_updatable(unknown, unknown) is 'is a relation insertable/updatable/deletable';

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size(unknown) is 'disk space usage for the main fork of the specified table or index';

create function pg_catalog.pg_relation_size(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size(unknown, unknown) is 'disk space usage for the specified fork of a table or index';

create function pg_catalog.pg_reload_conf() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_reload_conf() is 'reload configuration files';

create function pg_catalog.pg_replication_origin_advance(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_advance(unknown, unknown) is 'advance replication origin to specific location';

create function pg_catalog.pg_replication_origin_create(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_create(unknown) is 'create a replication origin';

create function pg_catalog.pg_replication_origin_drop(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_drop(unknown) is 'drop replication origin identified by its name';

create function pg_catalog.pg_replication_origin_oid(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_oid(unknown) is 'translate the replication origin''s name to its id';

create function pg_catalog.pg_replication_origin_progress(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_progress(unknown, unknown) is 'get an individual replication origin''s replication progress';

create function pg_catalog.pg_replication_origin_session_is_setup() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_is_setup() is 'is a replication origin configured in this session';

create function pg_catalog.pg_replication_origin_session_progress(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_progress(unknown) is 'get the replication progress of the current session';

create function pg_catalog.pg_replication_origin_session_reset() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_reset() is 'teardown configured replication progress tracking';

create function pg_catalog.pg_replication_origin_session_setup(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_setup(unknown) is 'configure session to maintain replication progress tracking for the passed in origin';

create function pg_catalog.pg_replication_origin_xact_reset() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_reset() is 'reset the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_origin_xact_setup(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_setup(unknown, unknown) is 'setup the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_slot_advance(slot_name unknown, upto_lsn unknown, out slot_name unknown, out end_lsn unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_slot_advance(unknown, unknown, out unknown, out unknown) is 'advance logical replication slot';

create function pg_catalog.pg_rotate_logfile() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile() is 'rotate log file';

create function pg_catalog.pg_rotate_logfile_old() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile_old() is 'rotate log file - old version for adminpack 1.0';

create function pg_catalog.pg_safe_snapshot_blocking_pids(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids(unknown) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

create function pg_catalog.pg_sequence_last_value(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_last_value(unknown) is 'sequence last value';

create function pg_catalog.pg_sequence_parameters(sequence_oid unknown, out start_value unknown, out minimum_value unknown, out maximum_value unknown, out increment unknown, out cycle_option unknown, out cache_size unknown, out data_type unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_parameters(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'sequence parameters, for use by information schema';

create function pg_catalog.pg_show_all_file_settings(out sourcefile unknown, out sourceline unknown, out seqno unknown, out name unknown, out setting unknown, out applied unknown, out error unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_all_file_settings(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'show config file settings';

create function pg_catalog.pg_show_all_settings(out name unknown, out setting unknown, out unit unknown, out category unknown, out short_desc unknown, out extra_desc unknown, out context unknown, out vartype unknown, out source unknown, out min_val unknown, out max_val unknown, out enumvals unknown, out boot_val unknown, out reset_val unknown, out sourcefile unknown, out sourceline unknown, out pending_restart unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_all_settings(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'SHOW ALL as a function';

create function pg_catalog.pg_show_replication_origin_status(out local_id unknown, out external_id unknown, out remote_lsn unknown, out local_lsn unknown) returns setof unknown
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_replication_origin_status(out unknown, out unknown, out unknown, out unknown) is 'get progress for all replication origins';

create function pg_catalog.pg_size_bytes(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_bytes(unknown) is 'convert a size in human-readable format with size units into bytes';

create function pg_catalog.pg_sleep(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep(unknown) is 'sleep for the specified time in seconds';

create function pg_catalog.pg_sleep_for(interval) returns void
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_for(unknown) is 'sleep for the specified interval';

create function pg_catalog.pg_sleep_until(timestamp with time zone) returns void
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_until(unknown) is 'sleep until the specified time';

create function pg_catalog.pg_snapshot_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_in(unknown) is 'I/O';

create function pg_catalog.pg_snapshot_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_out(unknown) is 'I/O';

create function pg_catalog.pg_snapshot_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_recv(unknown) is 'I/O';

create function pg_catalog.pg_snapshot_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_send(unknown) is 'I/O';

create function pg_catalog.pg_snapshot_xip(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xip(unknown) is 'get set of in-progress transactions in snapshot';

create function pg_catalog.pg_snapshot_xmax(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmax(unknown) is 'get xmax of snapshot';

create function pg_catalog.pg_snapshot_xmin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmin(unknown) is 'get xmin of snapshot';

create function pg_catalog.pg_start_backup(label unknown, fast unknown default false, exclusive unknown default true) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_start_backup(unknown, unknown, unknown) is 'prepare for taking an online backup';

create function pg_catalog.pg_stat_clear_snapshot() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_clear_snapshot() is 'statistics: discard current transaction''s statistics snapshot';

create function pg_catalog.pg_stat_file(filename unknown, out size unknown, out access unknown, out modification unknown, out change unknown, out creation unknown, out isdir unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'get information about file';

create function pg_catalog.pg_stat_file(filename unknown, missing_ok unknown, out size unknown, out access unknown, out modification unknown, out change unknown, out creation unknown, out isdir unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(unknown, unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'get information about file';

create function pg_catalog.pg_stat_get_activity(pid unknown, out datid unknown, out pid unknown, out usesysid unknown, out application_name unknown, out state unknown, out query unknown, out wait_event_type unknown, out wait_event unknown, out xact_start unknown, out query_start unknown, out backend_start unknown, out state_change unknown, out client_addr unknown, out client_hostname unknown, out client_port unknown, out backend_xid unknown, out backend_xmin unknown, out backend_type unknown, out ssl unknown, out sslversion unknown, out sslcipher unknown, out sslbits unknown, out ssl_client_dn unknown, out ssl_client_serial unknown, out ssl_issuer_dn unknown, out gss_auth unknown, out gss_princ unknown, out gss_enc unknown, out leader_pid unknown, out query_id unknown) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_activity(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about currently active backends';

create function pg_catalog.pg_stat_get_analyze_count(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_analyze_count(unknown) is 'statistics: number of manual analyzes for a table';

create function pg_catalog.pg_stat_get_archiver(out archived_count unknown, out last_archived_wal unknown, out last_archived_time unknown, out failed_count unknown, out last_failed_wal unknown, out last_failed_time unknown, out stats_reset unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_archiver(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about WAL archiver';

create function pg_catalog.pg_stat_get_autoanalyze_count(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(unknown) is 'statistics: number of auto analyzes for a table';

create function pg_catalog.pg_stat_get_autovacuum_count(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autovacuum_count(unknown) is 'statistics: number of auto vacuums for a table';

create function pg_catalog.pg_stat_get_backend_activity(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity(unknown) is 'statistics: current query of backend';

create function pg_catalog.pg_stat_get_backend_activity_start(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity_start(unknown) is 'statistics: start time for current query of backend';

create function pg_catalog.pg_stat_get_backend_client_addr(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_addr(unknown) is 'statistics: address of client connected to backend';

create function pg_catalog.pg_stat_get_backend_client_port(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_port(unknown) is 'statistics: port number of client connected to backend';

create function pg_catalog.pg_stat_get_backend_dbid(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_dbid(unknown) is 'statistics: database ID of backend';

create function pg_catalog.pg_stat_get_backend_idset() returns setof unknown
    stable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_idset() is 'statistics: currently active backend IDs';

create function pg_catalog.pg_stat_get_backend_pid(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_pid(unknown) is 'statistics: PID of backend';

create function pg_catalog.pg_stat_get_backend_start(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_start(unknown) is 'statistics: start time for current backend session';

create function pg_catalog.pg_stat_get_backend_userid(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_userid(unknown) is 'statistics: user ID of backend';

create function pg_catalog.pg_stat_get_backend_wait_event(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event(unknown) is 'statistics: wait event on which backend is currently waiting';

create function pg_catalog.pg_stat_get_backend_wait_event_type(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(unknown) is 'statistics: wait event type on which backend is currently waiting';

create function pg_catalog.pg_stat_get_backend_xact_start(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_xact_start(unknown) is 'statistics: start time for backend''s current transaction';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() is 'statistics: number of buffers written by the bgwriter during checkpoints';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() is 'statistics: number of backend requested checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() is 'statistics: last reset for the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() is 'statistics: number of timed checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_blocks_fetched(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_fetched(unknown) is 'statistics: number of blocks fetched';

create function pg_catalog.pg_stat_get_blocks_hit(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_hit(unknown) is 'statistics: number of blocks found in cache';

create function pg_catalog.pg_stat_get_buf_alloc() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_alloc() is 'statistics: number of buffer allocations';

create function pg_catalog.pg_stat_get_buf_fsync_backend() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend() is 'statistics: number of backend buffer writes that did their own fsync';

create function pg_catalog.pg_stat_get_buf_written_backend() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_written_backend() is 'statistics: number of buffers written by backends';

create function pg_catalog.pg_stat_get_checkpoint_sync_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time() is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

create function pg_catalog.pg_stat_get_checkpoint_write_time() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time() is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

create function pg_catalog.pg_stat_get_db_active_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_active_time(unknown) is 'statistics: session active time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blk_read_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(unknown) is 'statistics: block read time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blk_write_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(unknown) is 'statistics: block write time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blocks_fetched(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(unknown) is 'statistics: blocks fetched for database';

create function pg_catalog.pg_stat_get_db_blocks_hit(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(unknown) is 'statistics: blocks found in cache for database';

create function pg_catalog.pg_stat_get_db_checksum_failures(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_failures(unknown) is 'statistics: checksum failures detected in database';

create function pg_catalog.pg_stat_get_db_checksum_last_failure(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_last_failure(unknown) is 'statistics: when last checksum failure was detected in database';

create function pg_catalog.pg_stat_get_db_conflict_all(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_all(unknown) is 'statistics: recovery conflicts in database';

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(unknown) is 'statistics: recovery conflicts in database caused by shared buffer pin';

create function pg_catalog.pg_stat_get_db_conflict_lock(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(unknown) is 'statistics: recovery conflicts in database caused by relation lock';

create function pg_catalog.pg_stat_get_db_conflict_snapshot(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(unknown) is 'statistics: recovery conflicts in database caused by snapshot expiry';

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(unknown) is 'statistics: recovery conflicts in database caused by buffer deadlock';

create function pg_catalog.pg_stat_get_db_conflict_tablespace(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(unknown) is 'statistics: recovery conflicts in database caused by drop tablespace';

create function pg_catalog.pg_stat_get_db_deadlocks(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_deadlocks(unknown) is 'statistics: deadlocks detected in database';

create function pg_catalog.pg_stat_get_db_idle_in_transaction_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_idle_in_transaction_time(unknown) is 'statistics: session idle in transaction time, in milliseconds';

create function pg_catalog.pg_stat_get_db_numbackends(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_numbackends(unknown) is 'statistics: number of backends in database';

create function pg_catalog.pg_stat_get_db_session_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_session_time(unknown) is 'statistics: session time, in milliseconds';

create function pg_catalog.pg_stat_get_db_sessions(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions(unknown) is 'statistics: total number of sessions';

create function pg_catalog.pg_stat_get_db_sessions_abandoned(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_abandoned(unknown) is 'statistics: number of sessions disconnected by the client closing the network connection';

create function pg_catalog.pg_stat_get_db_sessions_fatal(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_fatal(unknown) is 'statistics: number of sessions disconnected by fatal errors';

create function pg_catalog.pg_stat_get_db_sessions_killed(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_killed(unknown) is 'statistics: number of sessions killed by administrative action';

create function pg_catalog.pg_stat_get_db_stat_reset_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(unknown) is 'statistics: last reset for a database';

create function pg_catalog.pg_stat_get_db_temp_bytes(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(unknown) is 'statistics: number of bytes in temporary files written';

create function pg_catalog.pg_stat_get_db_temp_files(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_files(unknown) is 'statistics: number of temporary files written';

create function pg_catalog.pg_stat_get_db_tuples_deleted(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(unknown) is 'statistics: tuples deleted in database';

create function pg_catalog.pg_stat_get_db_tuples_fetched(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(unknown) is 'statistics: tuples fetched for database';

create function pg_catalog.pg_stat_get_db_tuples_inserted(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(unknown) is 'statistics: tuples inserted in database';

create function pg_catalog.pg_stat_get_db_tuples_returned(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(unknown) is 'statistics: tuples returned for database';

create function pg_catalog.pg_stat_get_db_tuples_updated(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(unknown) is 'statistics: tuples updated in database';

create function pg_catalog.pg_stat_get_db_xact_commit(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_commit(unknown) is 'statistics: transactions committed';

create function pg_catalog.pg_stat_get_db_xact_rollback(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(unknown) is 'statistics: transactions rolled back';

create function pg_catalog.pg_stat_get_dead_tuples(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_dead_tuples(unknown) is 'statistics: number of dead tuples';

create function pg_catalog.pg_stat_get_function_calls(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_calls(unknown) is 'statistics: number of function calls';

create function pg_catalog.pg_stat_get_function_self_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_self_time(unknown) is 'statistics: self execution time of function, in milliseconds';

create function pg_catalog.pg_stat_get_function_total_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_total_time(unknown) is 'statistics: total execution time of function, in milliseconds';

create function pg_catalog.pg_stat_get_ins_since_vacuum(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_ins_since_vacuum(unknown) is 'statistics: number of tuples inserted since last vacuum';

create function pg_catalog.pg_stat_get_last_analyze_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_analyze_time(unknown) is 'statistics: last manual analyze time for a table';

create function pg_catalog.pg_stat_get_last_autoanalyze_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(unknown) is 'statistics: last auto analyze time for a table';

create function pg_catalog.pg_stat_get_last_autovacuum_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(unknown) is 'statistics: last auto vacuum time for a table';

create function pg_catalog.pg_stat_get_last_vacuum_time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(unknown) is 'statistics: last manual vacuum time for a table';

create function pg_catalog.pg_stat_get_live_tuples(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_live_tuples(unknown) is 'statistics: number of live tuples';

create function pg_catalog.pg_stat_get_mod_since_analyze(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(unknown) is 'statistics: number of tuples changed since last analyze';

create function pg_catalog.pg_stat_get_numscans(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_numscans(unknown) is 'statistics: number of scans done for table/index';

create function pg_catalog.pg_stat_get_progress_info(cmdtype unknown, out pid unknown, out datid unknown, out relid unknown, out param1 unknown, out param2 unknown, out param3 unknown, out param4 unknown, out param5 unknown, out param6 unknown, out param7 unknown, out param8 unknown, out param9 unknown, out param10 unknown, out param11 unknown, out param12 unknown, out param13 unknown, out param14 unknown, out param15 unknown, out param16 unknown, out param17 unknown, out param18 unknown, out param19 unknown, out param20 unknown) returns setof unknown
    stable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_progress_info(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about progress of backends running maintenance command';

create function pg_catalog.pg_stat_get_replication_slot(slot_name unknown, out slot_name unknown, out spill_txns unknown, out spill_count unknown, out spill_bytes unknown, out stream_txns unknown, out stream_count unknown, out stream_bytes unknown, out total_txns unknown, out total_bytes unknown, out stats_reset unknown) returns setof unknown
    stable
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_replication_slot(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about replication slot';

create function pg_catalog.pg_stat_get_slru(out name unknown, out blks_zeroed unknown, out blks_hit unknown, out blks_read unknown, out blks_written unknown, out blks_exists unknown, out flushes unknown, out truncates unknown, out stats_reset unknown) returns setof unknown
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_slru(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about SLRU caches';

create function pg_catalog.pg_stat_get_snapshot_timestamp() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp() is 'statistics: timestamp of the current statistics snapshot';

create function pg_catalog.pg_stat_get_subscription(subid unknown, out subid unknown, out relid unknown, out pid unknown, out received_lsn unknown, out last_msg_send_time unknown, out last_msg_receipt_time unknown, out latest_end_lsn unknown, out latest_end_time unknown) returns setof unknown
    stable
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_subscription(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about subscription';

create function pg_catalog.pg_stat_get_tuples_deleted(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_deleted(unknown) is 'statistics: number of tuples deleted';

create function pg_catalog.pg_stat_get_tuples_fetched(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_fetched(unknown) is 'statistics: number of tuples fetched by idxscan';

create function pg_catalog.pg_stat_get_tuples_hot_updated(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(unknown) is 'statistics: number of tuples hot updated';

create function pg_catalog.pg_stat_get_tuples_inserted(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_inserted(unknown) is 'statistics: number of tuples inserted';

create function pg_catalog.pg_stat_get_tuples_returned(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_returned(unknown) is 'statistics: number of tuples read by seqscan';

create function pg_catalog.pg_stat_get_tuples_updated(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_updated(unknown) is 'statistics: number of tuples updated';

create function pg_catalog.pg_stat_get_vacuum_count(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_vacuum_count(unknown) is 'statistics: number of manual vacuums for a table';

create function pg_catalog.pg_stat_get_wal(out wal_records unknown, out wal_fpi unknown, out wal_bytes unknown, out wal_buffers_full unknown, out wal_write unknown, out wal_sync unknown, out wal_write_time unknown, out wal_sync_time unknown, out stats_reset unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about WAL activity';

create function pg_catalog.pg_stat_get_wal_receiver(out pid unknown, out status unknown, out receive_start_lsn unknown, out receive_start_tli unknown, out written_lsn unknown, out flushed_lsn unknown, out received_tli unknown, out last_msg_send_time unknown, out last_msg_receipt_time unknown, out latest_end_lsn unknown, out latest_end_time unknown, out slot_name unknown, out sender_host unknown, out sender_port unknown, out conninfo unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_receiver(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about WAL receiver';

create function pg_catalog.pg_stat_get_wal_senders(out pid unknown, out state unknown, out sent_lsn unknown, out write_lsn unknown, out flush_lsn unknown, out replay_lsn unknown, out write_lag unknown, out flush_lag unknown, out replay_lag unknown, out sync_priority unknown, out sync_state unknown, out reply_time unknown) returns setof unknown
    stable
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_senders(out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'statistics: information about currently active replication';

create function pg_catalog.pg_stat_get_xact_blocks_fetched(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(unknown) is 'statistics: number of blocks fetched in current transaction';

create function pg_catalog.pg_stat_get_xact_blocks_hit(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(unknown) is 'statistics: number of blocks found in cache in current transaction';

create function pg_catalog.pg_stat_get_xact_function_calls(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_calls(unknown) is 'statistics: number of function calls in current transaction';

create function pg_catalog.pg_stat_get_xact_function_self_time(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(unknown) is 'statistics: self execution time of function in current transaction, in milliseconds';

create function pg_catalog.pg_stat_get_xact_function_total_time(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(unknown) is 'statistics: total execution time of function in current transaction, in milliseconds';

create function pg_catalog.pg_stat_get_xact_numscans(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_numscans(unknown) is 'statistics: number of scans done for table/index in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_deleted(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(unknown) is 'statistics: number of tuples deleted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_fetched(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(unknown) is 'statistics: number of tuples fetched by idxscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(unknown) is 'statistics: number of tuples hot updated in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_inserted(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(unknown) is 'statistics: number of tuples inserted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_returned(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(unknown) is 'statistics: number of tuples read by seqscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_updated(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(unknown) is 'statistics: number of tuples updated in current transaction';

create function pg_catalog.pg_stat_reset() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset() is 'statistics: reset collected statistics for current database';

create function pg_catalog.pg_stat_reset_replication_slot(unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_replication_slot(unknown) is 'statistics: reset collected statistics for a single replication slot';

create function pg_catalog.pg_stat_reset_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_shared(unknown) is 'statistics: reset collected statistics shared across the cluster';

create function pg_catalog.pg_stat_reset_single_function_counters(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_function_counters(unknown) is 'statistics: reset collected statistics for a single function in the current database';

create function pg_catalog.pg_stat_reset_single_table_counters(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_table_counters(unknown) is 'statistics: reset collected statistics for a single table or index in the current database';

create function pg_catalog.pg_stat_reset_slru(unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_slru(unknown) is 'statistics: reset collected statistics for a single SLRU';

create function pg_catalog.pg_statistics_obj_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_statistics_obj_is_visible(unknown) is 'is statistics object visible in search path?';

create function pg_catalog.pg_stop_backup() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup() is 'finish taking an online backup';

create function pg_catalog.pg_stop_backup(exclusive unknown, wait_for_archive unknown default true, out lsn unknown, out labelfile unknown, out spcmapfile unknown) returns setof unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup(unknown, unknown, out unknown, out unknown, out unknown) is 'finish taking an online backup';

create function pg_catalog.pg_switch_wal() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_switch_wal() is 'switch to new wal file';

create function pg_catalog.pg_table_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_is_visible(unknown) is 'is table visible in search path?';

create function pg_catalog.pg_table_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_size(unknown) is 'disk space usage for the specified table, including TOAST, free space and visibility map';

create function pg_catalog.pg_tablespace_databases(unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_databases(unknown) is 'get OIDs of databases in a tablespace';

create function pg_catalog.pg_tablespace_location(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_location(unknown) is 'tablespace location';

create function pg_catalog.pg_terminate_backend(pid unknown, timeout unknown default 0) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_terminate_backend(unknown, unknown) is 'terminate a server process';

create function pg_catalog.pg_timezone_abbrevs(out abbrev unknown, out utc_offset unknown, out is_dst unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_timezone_abbrevs(out unknown, out unknown, out unknown) is 'get the available time zone abbreviations';

create function pg_catalog.pg_timezone_names(out name unknown, out abbrev unknown, out utc_offset unknown, out is_dst unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_timezone_names(out unknown, out unknown, out unknown, out unknown) is 'get the available time zone names';

create function pg_catalog.pg_total_relation_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_total_relation_size(unknown) is 'total disk space usage for the specified table and associated indexes';

create function pg_catalog.pg_trigger_depth() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_trigger_depth() is 'current trigger depth';

create function pg_catalog.pg_try_advisory_lock(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(unknown) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(unknown, unknown) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(unknown) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(unknown, unknown) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(unknown) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(unknown, unknown) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(unknown) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(unknown, unknown) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_ts_config_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_config_is_visible(unknown) is 'is text search configuration visible in search path?';

create function pg_catalog.pg_ts_dict_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_dict_is_visible(unknown) is 'is text search dictionary visible in search path?';

create function pg_catalog.pg_ts_parser_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_parser_is_visible(unknown) is 'is text search parser visible in search path?';

create function pg_catalog.pg_ts_template_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_template_is_visible(unknown) is 'is text search template visible in search path?';

create function pg_catalog.pg_type_is_visible(unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_type_is_visible(unknown) is 'is type visible in search path?';

create function pg_catalog.pg_typeof(unknown) returns unknown
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_typeof(unknown) is 'type of the argument';

create function pg_catalog.pg_visible_in_snapshot(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_visible_in_snapshot(unknown, unknown) is 'is xid8 visible in snapshot?';

create function pg_catalog.pg_wal_lsn_diff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_lsn_diff(unknown, unknown) is 'difference in bytes, given two wal locations';

create function pg_catalog.pg_wal_replay_pause() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_pause() is 'pause wal replay';

create function pg_catalog.pg_wal_replay_resume() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_resume() is 'resume wal replay, if it was paused';

create function pg_catalog.pg_walfile_name(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name(unknown) is 'wal filename, given a wal location';

create function pg_catalog.pg_walfile_name_offset(lsn unknown, out file_name unknown, out file_offset unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name_offset(unknown, out unknown, out unknown) is 'wal filename and byte offset, given a wal location';

create function pg_catalog.pg_xact_commit_timestamp(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp(unknown) is 'get commit timestamp of a transaction';

create function pg_catalog.pg_xact_commit_timestamp_origin(xid unknown, out timestamp unknown, out roident unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp_origin(unknown, out unknown, out unknown) is 'get commit timestamp and replication origin of a transaction';

create function pg_catalog.pg_xact_status(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_status(unknown) is 'commit status of transaction';

create function pg_catalog.phraseto_tsquery(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(unknown) is 'transform to tsquery';

create function pg_catalog.phraseto_tsquery(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(unknown, unknown) is 'transform to tsquery';

create function pg_catalog.pi() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pi() is 'PI';

create function pg_catalog.plainto_tsquery(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(unknown) is 'transform to tsquery';

create function pg_catalog.plainto_tsquery(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(unknown, unknown) is 'transform to tsquery';

create function pg_catalog.plpgsql_call_handler() returns unknown
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.plpgsql_inline_handler(unknown) returns unknown
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.plpgsql_validator(unknown) returns unknown
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.point(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown, unknown) is 'convert x, y to point';

create function pg_catalog.point_above(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_above(unknown, unknown) is 'implementation of |>> operator';

create function pg_catalog.point_add(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_add(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.point_below(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_below(unknown, unknown) is 'implementation of <<| operator';

create function pg_catalog.point_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.point_div(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_div(unknown, unknown) is 'implementation of / operator';

create function pg_catalog.point_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_eq(unknown, unknown) is 'implementation of ~= operator';

create function pg_catalog.point_horiz(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_horiz(unknown, unknown) is 'implementation of ?- operator';

create function pg_catalog.point_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_in(unknown) is 'I/O';

create function pg_catalog.point_left(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_left(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.point_mul(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_mul(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.point_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.point_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_out(unknown) is 'I/O';

create function pg_catalog.point_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_recv(unknown) is 'I/O';

create function pg_catalog.point_right(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_right(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.point_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_send(unknown) is 'I/O';

create function pg_catalog.point_sub(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_sub(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.point_vert(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_vert(unknown, unknown) is 'implementation of ?| operator';

create function pg_catalog.poly_above(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_above(unknown, unknown) is 'implementation of |>> operator';

create function pg_catalog.poly_below(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_below(unknown, unknown) is 'implementation of <<| operator';

create function pg_catalog.poly_center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_center(unknown) is 'implementation of @@ operator';

create function pg_catalog.poly_contain(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.poly_contain_pt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain_pt(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.poly_contained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.poly_distance(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_distance(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.poly_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_in(unknown) is 'I/O';

create function pg_catalog.poly_left(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_left(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.poly_npoints(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_npoints(unknown) is 'implementation of # operator';

create function pg_catalog.poly_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_out(unknown) is 'I/O';

create function pg_catalog.poly_overabove(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overabove(unknown, unknown) is 'implementation of |&> operator';

create function pg_catalog.poly_overbelow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overbelow(unknown, unknown) is 'implementation of &<| operator';

create function pg_catalog.poly_overlap(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overlap(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.poly_overleft(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overleft(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.poly_overright(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overright(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.poly_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_recv(unknown) is 'I/O';

create function pg_catalog.poly_right(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_right(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.poly_same(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_same(unknown, unknown) is 'implementation of ~= operator';

create function pg_catalog.poly_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_send(unknown) is 'I/O';

create function pg_catalog.polygon(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(unknown, unknown) is 'convert vertex count and circle to polygon';

create function pg_catalog.popen(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.popen(unknown) is 'open path';

create function pg_catalog.positionjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity for position-comparison operators';

create function pg_catalog.positionsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionsel(unknown, unknown, unknown, unknown) is 'restriction selectivity for position-comparison operators';

create function pg_catalog.postgresql_fdw_validator(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.postgresql_fdw_validator(unknown, unknown) is '(internal)';

create function pg_catalog.prefixjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of exact prefix';

create function pg_catalog.prefixsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of exact prefix';

create function pg_catalog.prsd_end(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_end(unknown) is '(internal)';

create function pg_catalog.prsd_headline(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_headline(unknown, unknown, unknown) is '(internal)';

create function pg_catalog.prsd_lextype(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_lextype(unknown) is '(internal)';

create function pg_catalog.prsd_nexttoken(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_nexttoken(unknown, unknown, unknown) is '(internal)';

create function pg_catalog.prsd_start(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_start(unknown, unknown) is '(internal)';

create function pg_catalog.pt_contained_circle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_circle(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.pt_contained_poly(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_poly(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.query_to_xml(query unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml(unknown, unknown, unknown, unknown) is 'map query result to XML';

create function pg_catalog.query_to_xml_and_xmlschema(query unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml_and_xmlschema(unknown, unknown, unknown, unknown) is 'map query result and structure to XML and XML Schema';

create function pg_catalog.query_to_xmlschema(query unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xmlschema(unknown, unknown, unknown, unknown) is 'map query result structure to XML Schema';

create function pg_catalog.querytree(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.querytree(unknown) is 'show real useful query for GiST index';

create function pg_catalog.quote_ident(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_ident(unknown) is 'quote an identifier for usage in a querystring';

create function pg_catalog.radians(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radians(unknown) is 'degrees to radians';

create function pg_catalog.radius(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radius(unknown) is 'radius of circle';

create function pg_catalog.random() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.random() is 'random value';

create function pg_catalog.range_adjacent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent(unknown, unknown) is 'implementation of -|- operator';

create function pg_catalog.range_adjacent_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent_multirange(unknown, unknown) is 'implementation of -|- operator';

create function pg_catalog.range_after(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.range_after_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after_multirange(unknown, unknown) is 'implementation of >> operator';

create function pg_catalog.range_agg_finalfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_agg_finalfn(unknown, unknown) is 'aggregate final function';

create function pg_catalog.range_agg_transfn(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_agg_transfn(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.range_before(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.range_before_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before_multirange(unknown, unknown) is 'implementation of << operator';

create function pg_catalog.range_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.range_contained_by(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.range_contained_by_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by_multirange(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.range_contains(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.range_contains_elem(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_elem(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.range_contains_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_multirange(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.range_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.range_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.range_gist_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.range_gist_penalty(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_penalty(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.range_gist_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_picksplit(unknown, unknown) is 'GiST support';

create function pg_catalog.range_gist_same(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_same(unknown, unknown, unknown) is 'GiST support';

create function pg_catalog.range_gist_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_union(unknown, unknown) is 'GiST support';

create function pg_catalog.range_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.range_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.range_intersect(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect(unknown, unknown) is 'implementation of * operator';

create function pg_catalog.range_intersect_agg_transfn(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect_agg_transfn(unknown, unknown) is 'range aggregate by intersecting';

create function pg_catalog.range_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.range_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.range_merge(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge(unknown) is 'the smallest range which includes the whole multirange';

create function pg_catalog.range_merge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge(unknown, unknown) is 'the smallest range which includes both of the given ranges';

create function pg_catalog.range_minus(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_minus(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.range_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.range_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_out(unknown) is 'I/O';

create function pg_catalog.range_overlaps(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.range_overlaps_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps_multirange(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.range_overleft(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.range_overleft_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft_multirange(unknown, unknown) is 'implementation of &< operator';

create function pg_catalog.range_overright(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.range_overright_multirange(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright_multirange(unknown, unknown) is 'implementation of &> operator';

create function pg_catalog.range_recv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.range_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_send(unknown) is 'I/O';

create function pg_catalog.range_typanalyze(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_typanalyze(unknown) is 'range typanalyze';

create function pg_catalog.range_union(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_union(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.rangesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rangesel(unknown, unknown, unknown, unknown) is 'restriction selectivity for range operators';

create function pg_catalog.rank() returns unknown
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank() is 'integer rank with gaps';

create function pg_catalog.rank_final(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank_final(unknown, unknown) is 'aggregate final function';

create function pg_catalog.raw_array_subscript_handler(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.raw_array_subscript_handler(unknown) is 'raw array subscripting support';

create function pg_catalog.record_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.record_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.record_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.record_image_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_eq(unknown, unknown) is 'implementation of *= operator';

create function pg_catalog.record_image_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ge(unknown, unknown) is 'implementation of *>= operator';

create function pg_catalog.record_image_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_gt(unknown, unknown) is 'implementation of *> operator';

create function pg_catalog.record_image_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_le(unknown, unknown) is 'implementation of *<= operator';

create function pg_catalog.record_image_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_lt(unknown, unknown) is 'implementation of *< operator';

create function pg_catalog.record_image_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ne(unknown, unknown) is 'implementation of *<> operator';

create function pg_catalog.record_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.record_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.record_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.record_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.record_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_out(unknown) is 'I/O';

create function pg_catalog.record_recv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.record_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_send(unknown) is 'I/O';

create function pg_catalog.regclass(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclass(unknown) is 'convert text to regclass';

create function pg_catalog.regclassin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassin(unknown) is 'I/O';

create function pg_catalog.regclassout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassout(unknown) is 'I/O';

create function pg_catalog.regclassrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassrecv(unknown) is 'I/O';

create function pg_catalog.regclasssend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclasssend(unknown) is 'I/O';

create function pg_catalog.regcollationin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationin(unknown) is 'I/O';

create function pg_catalog.regcollationout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationout(unknown) is 'I/O';

create function pg_catalog.regcollationrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationrecv(unknown) is 'I/O';

create function pg_catalog.regcollationsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationsend(unknown) is 'I/O';

create function pg_catalog.regconfigin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigin(unknown) is 'I/O';

create function pg_catalog.regconfigout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigout(unknown) is 'I/O';

create function pg_catalog.regconfigrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigrecv(unknown) is 'I/O';

create function pg_catalog.regconfigsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigsend(unknown) is 'I/O';

create function pg_catalog.regdictionaryin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryin(unknown) is 'I/O';

create function pg_catalog.regdictionaryout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryout(unknown) is 'I/O';

create function pg_catalog.regdictionaryrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryrecv(unknown) is 'I/O';

create function pg_catalog.regdictionarysend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionarysend(unknown) is 'I/O';

create function pg_catalog.regexeqjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of regex match';

create function pg_catalog.regexeqsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of regex match';

create function pg_catalog.regexnejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of regex non-match';

create function pg_catalog.regexnesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of regex non-match';

create function pg_catalog.regexp_match(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(unknown, unknown) is 'find first match for regexp';

create function pg_catalog.regexp_match(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(unknown, unknown, unknown) is 'find first match for regexp';

create function pg_catalog.regexp_matches(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_matches(unknown, unknown) is 'find match(es) for regexp';

create function pg_catalog.regexp_matches(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_matches(unknown, unknown, unknown) is 'find match(es) for regexp';

create function pg_catalog.regexp_replace(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(unknown, unknown, unknown) is 'replace text using regexp';

create function pg_catalog.regexp_replace(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(unknown, unknown, unknown, unknown) is 'replace text using regexp';

create function pg_catalog.regexp_split_to_array(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(unknown, unknown) is 'split string by pattern';

create function pg_catalog.regexp_split_to_array(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(unknown, unknown, unknown) is 'split string by pattern';

create function pg_catalog.regexp_split_to_table(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_table(unknown, unknown) is 'split string by pattern';

create function pg_catalog.regexp_split_to_table(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_table(unknown, unknown, unknown) is 'split string by pattern';

create function pg_catalog.regnamespacein(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacein(unknown) is 'I/O';

create function pg_catalog.regnamespaceout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespaceout(unknown) is 'I/O';

create function pg_catalog.regnamespacerecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacerecv(unknown) is 'I/O';

create function pg_catalog.regnamespacesend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacesend(unknown) is 'I/O';

create function pg_catalog.regoperatorin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorin(unknown) is 'I/O';

create function pg_catalog.regoperatorout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorout(unknown) is 'I/O';

create function pg_catalog.regoperatorrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorrecv(unknown) is 'I/O';

create function pg_catalog.regoperatorsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorsend(unknown) is 'I/O';

create function pg_catalog.regoperin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperin(unknown) is 'I/O';

create function pg_catalog.regoperout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperout(unknown) is 'I/O';

create function pg_catalog.regoperrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperrecv(unknown) is 'I/O';

create function pg_catalog.regopersend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regopersend(unknown) is 'I/O';

create function pg_catalog.regprocedurein(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurein(unknown) is 'I/O';

create function pg_catalog.regprocedureout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedureout(unknown) is 'I/O';

create function pg_catalog.regprocedurerecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurerecv(unknown) is 'I/O';

create function pg_catalog.regproceduresend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regproceduresend(unknown) is 'I/O';

create function pg_catalog.regprocin(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocin(unknown) is 'I/O';

create function pg_catalog.regprocout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocout(unknown) is 'I/O';

create function pg_catalog.regprocrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocrecv(unknown) is 'I/O';

create function pg_catalog.regprocsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocsend(unknown) is 'I/O';

create function pg_catalog.regrolein(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolein(unknown) is 'I/O';

create function pg_catalog.regroleout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regroleout(unknown) is 'I/O';

create function pg_catalog.regrolerecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolerecv(unknown) is 'I/O';

create function pg_catalog.regrolesend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolesend(unknown) is 'I/O';

create function pg_catalog.regtypein(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypein(unknown) is 'I/O';

create function pg_catalog.regtypeout(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypeout(unknown) is 'I/O';

create function pg_catalog.regtyperecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtyperecv(unknown) is 'I/O';

create function pg_catalog.regtypesend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypesend(unknown) is 'I/O';

create function pg_catalog.repeat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.repeat(unknown, unknown) is 'replicate string n times';

create function pg_catalog.replace(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.replace(unknown, unknown, unknown) is 'replace all occurrences in string of old_substr with new_substr';

create function pg_catalog.reverse(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.reverse(unknown) is 'reverse text';

create function pg_catalog."right"(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."right"(unknown, unknown) is 'extract the last n characters';

create function pg_catalog.round(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(unknown, unknown) is 'value rounded to ''scale''';

create function pg_catalog.row_number() returns unknown
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_number() is 'row number within partition';

create function pg_catalog.row_to_json(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(unknown) is 'map row to json';

create function pg_catalog.row_to_json(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(unknown, unknown) is 'map row to json with optional pretty printing';

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(unknown, unknown) is 'right-pad string to length';

create function pg_catalog.rpad(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(unknown, unknown, unknown) is 'right-pad string to length';

create function pg_catalog.rtrim(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(unknown) is 'trim spaces from right end of string';

create function pg_catalog.satisfies_hash_partition(unknown, unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.satisfies_hash_partition(unknown, unknown, unknown, unknown) is 'hash partition CHECK constraint';

create function pg_catalog.scalargejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.scalargesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.scalargtjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of > and related operators on scalar datatypes';

create function pg_catalog.scalargtsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of > and related operators on scalar datatypes';

create function pg_catalog.scalarlejoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlejoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.scalarlesel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlesel(unknown, unknown, unknown, unknown) is 'restriction selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.scalarltjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scalarltsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scale(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scale(unknown) is 'number of decimal digits in the fractional part';

create function pg_catalog.schema_to_xml(schema unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml(unknown, unknown, unknown, unknown) is 'map schema contents to XML';

create function pg_catalog.schema_to_xml_and_xmlschema(schema unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml_and_xmlschema(unknown, unknown, unknown, unknown) is 'map schema contents and structure to XML and XML Schema';

create function pg_catalog.schema_to_xmlschema(schema unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xmlschema(unknown, unknown, unknown, unknown) is 'map schema structure to XML Schema';

create function pg_catalog."session_user"() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."session_user"() is 'session user name';

create function pg_catalog.set_byte(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_byte(unknown, unknown, unknown) is 'set byte';

create function pg_catalog.set_config(unknown, unknown, unknown) returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_config(unknown, unknown, unknown) is 'SET X as a function';

create function pg_catalog.setseed(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setseed(unknown) is 'set random seed';

create function pg_catalog.setval(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(unknown, unknown) is 'set sequence value';

create function pg_catalog.setval(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(unknown, unknown, unknown) is 'set sequence value and is_called status';

create function pg_catalog.setweight(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(unknown, unknown) is 'set given weight for whole tsvector';

create function pg_catalog.setweight(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(unknown, unknown, unknown) is 'set given weight for given lexemes';

create function pg_catalog.sha224(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha224(unknown) is 'SHA-224 hash';

create function pg_catalog.sha256(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha256(unknown) is 'SHA-256 hash';

create function pg_catalog.sha384(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha384(unknown) is 'SHA-384 hash';

create function pg_catalog.sha512(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha512(unknown) is 'SHA-512 hash';

create function pg_catalog.shell_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_in(unknown) is 'I/O';

create function pg_catalog.shell_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_out(unknown) is 'I/O';

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

create function pg_catalog.shift_jis_2004_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

create function pg_catalog.shobj_description(oid, name) returns text
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.shobj_description(unknown, unknown) is 'get description for object id and shared catalog name';

create function pg_catalog.similar_escape(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_escape(unknown, unknown) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.similar_to_escape(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(unknown) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.similar_to_escape(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(unknown, unknown) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.sin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sin(unknown) is 'sine';

create function pg_catalog.sind(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sind(unknown) is 'sine, degrees';

create function pg_catalog.sinh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sinh(unknown) is 'hyperbolic sine';

create function pg_catalog.sjis_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for SJIS to EUC_JP';

create function pg_catalog.sjis_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for SJIS to MULE_INTERNAL';

create function pg_catalog.sjis_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for SJIS to UTF8';

create function pg_catalog.slope(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.slope(unknown, unknown) is 'slope between points';

create function pg_catalog.spg_bbox_quad_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_bbox_quad_config(unknown, unknown) is 'SP-GiST support for quad tree over 2-D types represented by their bounding boxes';

create function pg_catalog.spg_box_quad_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_choose(unknown, unknown) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_config(unknown, unknown) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_inner_consistent(unknown, unknown) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_leaf_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_leaf_consistent(unknown, unknown) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_picksplit(unknown, unknown) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_kd_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_choose(unknown, unknown) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_config(unknown, unknown) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_inner_consistent(unknown, unknown) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_picksplit(unknown, unknown) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_poly_quad_compress(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_poly_quad_compress(unknown) is 'SP-GiST support for quad tree over polygons';

create function pg_catalog.spg_quad_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_choose(unknown, unknown) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_config(unknown, unknown) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_inner_consistent(unknown, unknown) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_leaf_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_leaf_consistent(unknown, unknown) is 'SP-GiST support for quad tree and k-d tree over point';

create function pg_catalog.spg_quad_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_picksplit(unknown, unknown) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_range_quad_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_choose(unknown, unknown) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_config(unknown, unknown) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_inner_consistent(unknown, unknown) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_leaf_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_leaf_consistent(unknown, unknown) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_picksplit(unknown, unknown) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_text_choose(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_choose(unknown, unknown) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_config(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_config(unknown, unknown) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_inner_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_inner_consistent(unknown, unknown) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_leaf_consistent(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_leaf_consistent(unknown, unknown) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_picksplit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_picksplit(unknown, unknown) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spghandler(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spghandler(unknown) is 'spgist index access method handler';

create function pg_catalog.split_part(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.split_part(unknown, unknown, unknown) is 'split string by field_sep and return field_num';

create function pg_catalog.starts_with(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.starts_with(unknown, unknown) is 'implementation of ^@ operator';

create function pg_catalog.statement_timestamp() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.statement_timestamp() is 'current statement time';

create function pg_catalog.string_agg_finalfn(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_finalfn(unknown) is 'aggregate final function';

create function pg_catalog.string_agg_transfn(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_transfn(unknown, unknown, unknown) is 'aggregate transition function';

create function pg_catalog.string_to_array(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(unknown, unknown) is 'split delimited text';

create function pg_catalog.string_to_array(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(unknown, unknown, unknown) is 'split delimited text, with null string';

create function pg_catalog.string_to_table(unknown, unknown) returns setof unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_table(unknown, unknown) is 'split delimited text';

create function pg_catalog.string_to_table(unknown, unknown, unknown) returns setof unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_table(unknown, unknown, unknown) is 'split delimited text, with null string';

create function pg_catalog.strip(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strip(unknown) is 'strip position information';

create function pg_catalog.strpos(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strpos(unknown, unknown) is 'position of substring';

create function pg_catalog.suppress_redundant_updates_trigger() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.suppress_redundant_updates_trigger() is 'trigger to suppress updates when new and old records match';

create function pg_catalog.system(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.system(unknown) is 'SYSTEM tablesample method handler';

create function pg_catalog.table_am_handler_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_in(unknown) is 'I/O';

create function pg_catalog.table_am_handler_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_out(unknown) is 'I/O';

create function pg_catalog.table_to_xml(tbl unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml(unknown, unknown, unknown, unknown) is 'map table contents to XML';

create function pg_catalog.table_to_xml_and_xmlschema(tbl unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml_and_xmlschema(unknown, unknown, unknown, unknown) is 'map table contents and structure to XML and XML Schema';

create function pg_catalog.table_to_xmlschema(tbl unknown, nulls unknown, tableforest unknown, targetns unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xmlschema(unknown, unknown, unknown, unknown) is 'map table structure to XML Schema';

create function pg_catalog.tan(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tan(unknown) is 'tangent';

create function pg_catalog.tand(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tand(unknown) is 'tangent, degrees';

create function pg_catalog.tanh(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tanh(unknown) is 'hyperbolic tangent';

create function pg_catalog.text_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.text_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.text_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.text_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.text_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.text_pattern_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_ge(unknown, unknown) is 'implementation of ~>=~ operator';

create function pg_catalog.text_pattern_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_gt(unknown, unknown) is 'implementation of ~>~ operator';

create function pg_catalog.text_pattern_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_le(unknown, unknown) is 'implementation of ~<=~ operator';

create function pg_catalog.text_pattern_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_lt(unknown, unknown) is 'implementation of ~<~ operator';

create function pg_catalog.text_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.textanycat(text, anynonarray) returns text
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.textanycat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.textcat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textcat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.texteq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.texteqname(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteqname(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.textgename(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgename(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.textgtname(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgtname(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.texticlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike(unknown, unknown) is 'implementation of ~~* operator';

create function pg_catalog.texticlike_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike_support(unknown) is 'planner support for texticlike';

create function pg_catalog.texticnlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticnlike(unknown, unknown) is 'implementation of !~~* operator';

create function pg_catalog.texticregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq(unknown, unknown) is 'implementation of ~* operator';

create function pg_catalog.texticregexeq_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq_support(unknown) is 'planner support for texticregexeq';

create function pg_catalog.texticregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexne(unknown, unknown) is 'implementation of !~* operator';

create function pg_catalog.textin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textin(unknown) is 'I/O';

create function pg_catalog.textlen(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlen(unknown) is 'length';

create function pg_catalog.textlename(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlename(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.textlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike(unknown, unknown) is 'implementation of ~~ operator';

create function pg_catalog.textlike_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike_support(unknown) is 'planner support for textlike';

create function pg_catalog.textltname(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textltname(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.textne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.textnename(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnename(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.textnlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnlike(unknown, unknown) is 'implementation of !~~ operator';

create function pg_catalog.textout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textout(unknown) is 'I/O';

create function pg_catalog.textrecv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textrecv(unknown) is 'I/O';

create function pg_catalog.textregexeq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq(unknown, unknown) is 'implementation of ~ operator';

create function pg_catalog.textregexeq_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq_support(unknown) is 'planner support for textregexeq';

create function pg_catalog.textregexne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexne(unknown, unknown) is 'implementation of !~ operator';

create function pg_catalog.textsend(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textsend(unknown) is 'I/O';

create function pg_catalog.thesaurus_init(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_init(unknown) is '(internal)';

create function pg_catalog.thesaurus_lexize(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_lexize(unknown, unknown, unknown, unknown) is '(internal)';

create function pg_catalog.tideq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tideq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.tidge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.tidgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.tidin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidin(unknown) is 'I/O';

create function pg_catalog.tidlarger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlarger(unknown, unknown) is 'larger of two';

create function pg_catalog.tidle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.tidlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.tidne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.tidout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidout(unknown) is 'I/O';

create function pg_catalog.tidrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidrecv(unknown) is 'I/O';

create function pg_catalog.tidsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsend(unknown) is 'I/O';

create function pg_catalog.tidsmaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsmaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.time(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(unknown, unknown) is 'adjust time precision';

create function pg_catalog.time_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.time_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.time_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.time_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.time_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash(unknown) is 'hash';

create function pg_catalog.time_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.time_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.time_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.time_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.time_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.time_mi_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_interval(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.time_mi_time(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_time(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.time_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.time_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_out(unknown) is 'I/O';

create function pg_catalog.time_pl_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_pl_interval(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.time_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.time_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_send(unknown) is 'I/O';

create function pg_catalog.time_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.time_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_support(unknown) is 'planner support for time length coercion';

create function pg_catalog.timedate_pl(time without time zone, date) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timedate_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.timeofday() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timeofday() is 'current date and time - increments during transactions';

create function pg_catalog.timestamp_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamp_cmp_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_date(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamp_cmp_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_timestamptz(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamp_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamp_eq_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_date(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamp_eq_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_timestamptz(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamp_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamp_ge_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_date(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamp_ge_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_timestamptz(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamp_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamp_gt_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_date(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamp_gt_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_timestamptz(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamp_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash(unknown) is 'hash';

create function pg_catalog.timestamp_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.timestamp_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timestamp_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.timestamp_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamp_le_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_date(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamp_le_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_timestamptz(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamp_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamp_lt_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_date(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamp_lt_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_timestamptz(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamp_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.timestamp_mi_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi_interval(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.timestamp_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamp_ne_date(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_date(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamp_ne_timestamptz(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_timestamptz(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamp_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_out(unknown) is 'I/O';

create function pg_catalog.timestamp_pl_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_pl_interval(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.timestamp_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timestamp_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_send(unknown) is 'I/O';

create function pg_catalog.timestamp_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.timestamp_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_sortsupport(unknown) is 'sort support';

create function pg_catalog.timestamp_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_support(unknown) is 'planner support for timestamp length coercion';

create function pg_catalog.timestamptypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodin(unknown) is 'I/O typmod';

create function pg_catalog.timestamptypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodout(unknown) is 'I/O typmod';

create function pg_catalog.timestamptz_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamptz_cmp_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_date(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamptz_cmp_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_timestamp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timestamptz_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamptz_eq_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_date(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamptz_eq_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_timestamp(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timestamptz_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamptz_ge_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_date(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamptz_ge_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_timestamp(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timestamptz_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamptz_gt_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_date(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamptz_gt_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_timestamp(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timestamptz_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timestamptz_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.timestamptz_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamptz_le_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_date(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamptz_le_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_timestamp(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timestamptz_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamptz_lt_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_date(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamptz_lt_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_timestamp(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timestamptz_mi(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.timestamptz_mi_interval(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi_interval(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.timestamptz_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamptz_ne_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_date(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamptz_ne_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_timestamp(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timestamptz_out(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_out(unknown) is 'I/O';

create function pg_catalog.timestamptz_pl_interval(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_pl_interval(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.timestamptz_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timestamptz_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_send(unknown) is 'I/O';

create function pg_catalog.timestamptz_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.timestamptztypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodin(unknown) is 'I/O typmod';

create function pg_catalog.timestamptztypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodout(unknown) is 'I/O typmod';

create function pg_catalog.timetypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodin(unknown) is 'I/O typmod';

create function pg_catalog.timetypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodout(unknown) is 'I/O typmod';

create function pg_catalog.timetz(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(unknown, unknown) is 'adjust time with time zone precision';

create function pg_catalog.timetz_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.timetz_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.timetz_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.timetz_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.timetz_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash(unknown) is 'hash';

create function pg_catalog.timetz_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.timetz_in(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timetz_larger(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_larger(unknown, unknown) is 'larger of two';

create function pg_catalog.timetz_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.timetz_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.timetz_mi_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_mi_interval(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.timetz_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.timetz_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_out(unknown) is 'I/O';

create function pg_catalog.timetz_pl_interval(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_pl_interval(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.timetz_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.timetz_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_send(unknown) is 'I/O';

create function pg_catalog.timetz_smaller(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_smaller(unknown, unknown) is 'smaller of two';

create function pg_catalog.timetzdate_pl(time with time zone, date) returns timestamp with time zone
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetzdate_pl(unknown, unknown) is 'implementation of + operator';

create function pg_catalog.timetztypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodin(unknown) is 'I/O typmod';

create function pg_catalog.timetztypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodout(unknown) is 'I/O typmod';

create function pg_catalog.to_ascii(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(unknown) is 'encode text from DB encoding to ASCII text';

create function pg_catalog.to_date(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_date(unknown, unknown) is 'convert text to date';

create function pg_catalog.to_json(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_json(unknown) is 'map input to json';

create function pg_catalog.to_jsonb(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_jsonb(unknown) is 'map input to jsonb';

create function pg_catalog.to_number(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_number(unknown, unknown) is 'convert text to numeric';

create function pg_catalog.to_regclass(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regclass(unknown) is 'convert classname to regclass';

create function pg_catalog.to_regcollation(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regcollation(unknown) is 'convert classname to regcollation';

create function pg_catalog.to_regnamespace(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regnamespace(unknown) is 'convert namespace name to regnamespace';

create function pg_catalog.to_regoper(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoper(unknown) is 'convert operator name to regoper';

create function pg_catalog.to_regoperator(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoperator(unknown) is 'convert operator name to regoperator';

create function pg_catalog.to_regproc(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regproc(unknown) is 'convert proname to regproc';

create function pg_catalog.to_regprocedure(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regprocedure(unknown) is 'convert proname to regprocedure';

create function pg_catalog.to_regrole(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regrole(unknown) is 'convert role name to regrole';

create function pg_catalog.to_regtype(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regtype(unknown) is 'convert type name to regtype';

create function pg_catalog.to_timestamp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(unknown) is 'convert UNIX epoch to timestamptz';

create function pg_catalog.to_timestamp(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(unknown, unknown) is 'convert text to timestamp with time zone';

create function pg_catalog.to_tsquery(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(unknown) is 'make tsquery';

create function pg_catalog.to_tsquery(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(unknown, unknown) is 'make tsquery';

create function pg_catalog.transaction_timestamp() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.transaction_timestamp() is 'current transaction time';

create function pg_catalog.translate(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.translate(unknown, unknown, unknown) is 'map a set of characters appearing in string';

create function pg_catalog.trigger_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_in(unknown) is 'I/O';

create function pg_catalog.trigger_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_out(unknown) is 'I/O';

create function pg_catalog.trim_array(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trim_array(unknown, unknown) is 'remove last N elements of array';

create function pg_catalog.trim_scale(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trim_scale(unknown) is 'numeric with minimum scale needed to represent the value';

create function pg_catalog.trunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(unknown, unknown) is 'value truncated to ''scale''';

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_debug(unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'debug function for current text search configuration';

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_debug(unknown, unknown, out unknown, out unknown, out unknown, out unknown, out unknown, out unknown) is 'debug function for text search configuration';

create function pg_catalog.ts_filter(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_filter(unknown, unknown) is 'delete lexemes that do not have one of the given weights';

create function pg_catalog.ts_lexize(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_lexize(unknown, unknown) is 'normalize one word by dictionary';

create function pg_catalog.ts_match_qv(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_qv(unknown, unknown) is 'implementation of @@ operator';

create function pg_catalog.ts_match_tq(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tq(unknown, unknown) is 'implementation of @@ operator';

create function pg_catalog.ts_match_tt(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tt(unknown, unknown) is 'implementation of @@ operator';

create function pg_catalog.ts_match_vq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_vq(unknown, unknown) is 'implementation of @@ operator';

create function pg_catalog.ts_rank(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(unknown, unknown) is 'relevance';

create function pg_catalog.ts_rank(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(unknown, unknown, unknown, unknown) is 'relevance';

create function pg_catalog.ts_rank_cd(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(unknown, unknown) is 'relevance';

create function pg_catalog.ts_rank_cd(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(unknown, unknown, unknown, unknown) is 'relevance';

create function pg_catalog.ts_rewrite(unknown, unknown) returns unknown
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(unknown, unknown) is 'rewrite tsquery';

create function pg_catalog.ts_rewrite(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(unknown, unknown, unknown) is 'rewrite tsquery';

create function pg_catalog.ts_stat(query unknown, out word unknown, out ndoc unknown, out nentry unknown) returns setof unknown
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_stat(unknown, out unknown, out unknown, out unknown) is 'statistics of tsvector column';

create function pg_catalog.ts_stat(query unknown, weights unknown, out word unknown, out ndoc unknown, out nentry unknown) returns setof unknown
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_stat(unknown, unknown, out unknown, out unknown, out unknown) is 'statistics of tsvector column';

create function pg_catalog.ts_typanalyze(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_typanalyze(unknown) is 'tsvector typanalyze';

create function pg_catalog.tsm_handler_in(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_in(unknown) is 'I/O';

create function pg_catalog.tsm_handler_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_out(unknown) is 'I/O';

create function pg_catalog.tsmatchjoinsel(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchjoinsel(unknown, unknown, unknown, unknown, unknown) is 'join selectivity of tsvector @@ tsquery';

create function pg_catalog.tsmatchsel(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchsel(unknown, unknown, unknown, unknown) is 'restriction selectivity of tsvector @@ tsquery';

create function pg_catalog.tsmultirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange() is 'tsmultirange constructor';

create function pg_catalog.tsq_mcontained(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontained(unknown, unknown) is 'implementation of <@ operator';

create function pg_catalog.tsq_mcontains(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontains(unknown, unknown) is 'implementation of @> operator';

create function pg_catalog.tsquery_and(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_and(unknown, unknown) is 'implementation of && operator';

create function pg_catalog.tsquery_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.tsquery_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.tsquery_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.tsquery_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.tsquery_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.tsquery_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.tsquery_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.tsquery_not(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_not(unknown) is 'implementation of !! operator';

create function pg_catalog.tsquery_or(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_or(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.tsquery_phrase(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(unknown, unknown) is 'implementation of <-> operator';

create function pg_catalog.tsquery_phrase(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(unknown, unknown, unknown) is 'phrase-concatenate with distance';

create function pg_catalog.tsqueryin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryin(unknown) is 'I/O';

create function pg_catalog.tsqueryout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryout(unknown) is 'I/O';

create function pg_catalog.tsqueryrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryrecv(unknown) is 'I/O';

create function pg_catalog.tsquerysend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquerysend(unknown) is 'I/O';

create function pg_catalog.tsrange(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(unknown, unknown) is 'tsrange constructor';

create function pg_catalog.tsrange(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(unknown, unknown, unknown) is 'tsrange constructor';

create function pg_catalog.tsrange_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange_subdiff(unknown, unknown) is 'float8 difference of two timestamp values';

create function pg_catalog.tstzmultirange() returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange() is 'tstzmultirange constructor';

create function pg_catalog.tstzrange(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(unknown, unknown) is 'tstzrange constructor';

create function pg_catalog.tstzrange(unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(unknown, unknown, unknown) is 'tstzrange constructor';

create function pg_catalog.tstzrange_subdiff(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange_subdiff(unknown, unknown) is 'float8 difference of two timestamp with time zone values';

create function pg_catalog.tsvector_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.tsvector_concat(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_concat(unknown, unknown) is 'implementation of || operator';

create function pg_catalog.tsvector_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.tsvector_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.tsvector_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.tsvector_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.tsvector_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.tsvector_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.tsvector_to_array(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_to_array(unknown) is 'convert tsvector to array of lexemes';

create function pg_catalog.tsvector_update_trigger() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger() is 'trigger for automatic update of tsvector column';

create function pg_catalog.tsvector_update_trigger_column() returns unknown
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger_column() is 'trigger for automatic update of tsvector column';

create function pg_catalog.tsvectorin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorin(unknown) is 'I/O';

create function pg_catalog.tsvectorout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorout(unknown) is 'I/O';

create function pg_catalog.tsvectorrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorrecv(unknown) is 'I/O';

create function pg_catalog.tsvectorsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorsend(unknown) is 'I/O';

create function pg_catalog.txid_current() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current() is 'get current transaction ID';

create function pg_catalog.txid_current_if_assigned() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_if_assigned() is 'get current transaction ID';

create function pg_catalog.txid_current_snapshot() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_snapshot() is 'get current snapshot';

create function pg_catalog.txid_snapshot_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_in(unknown) is 'I/O';

create function pg_catalog.txid_snapshot_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_out(unknown) is 'I/O';

create function pg_catalog.txid_snapshot_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_recv(unknown) is 'I/O';

create function pg_catalog.txid_snapshot_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_send(unknown) is 'I/O';

create function pg_catalog.txid_snapshot_xip(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xip(unknown) is 'get set of in-progress txids in snapshot';

create function pg_catalog.txid_snapshot_xmax(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmax(unknown) is 'get xmax of snapshot';

create function pg_catalog.txid_snapshot_xmin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmin(unknown) is 'get xmin of snapshot';

create function pg_catalog.txid_status(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_status(unknown) is 'commit status of transaction';

create function pg_catalog.txid_visible_in_snapshot(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_visible_in_snapshot(unknown, unknown) is 'is txid visible in snapshot?';

create function pg_catalog.uhc_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uhc_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UHC to UTF8';

create function pg_catalog.unique_key_recheck() returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unique_key_recheck() is 'deferred UNIQUE constraint check';

create function pg_catalog.unistr(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unistr(unknown) is 'unescape Unicode characters';

create function pg_catalog.unknownin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownin(unknown) is 'I/O';

create function pg_catalog.unknownout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownout(unknown) is 'I/O';

create function pg_catalog.unknownrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownrecv(unknown) is 'I/O';

create function pg_catalog.unknownsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownsend(unknown) is 'I/O';

create function pg_catalog.utf8_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_big5(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to BIG5';

create function pg_catalog.utf8_to_euc_cn(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_cn(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to EUC_CN';

create function pg_catalog.utf8_to_euc_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to EUC_JIS_2004';

create function pg_catalog.utf8_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jp(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to EUC_JP';

create function pg_catalog.utf8_to_euc_kr(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_kr(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to EUC_KR';

create function pg_catalog.utf8_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_tw(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to EUC_TW';

create function pg_catalog.utf8_to_gb18030(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gb18030(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to GB18030';

create function pg_catalog.utf8_to_gbk(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gbk(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to GBK';

create function pg_catalog.utf8_to_iso8859(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to ISO-8859 2-16';

create function pg_catalog.utf8_to_iso8859_1(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859_1(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to LATIN1';

create function pg_catalog.utf8_to_johab(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_johab(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to JOHAB';

create function pg_catalog.utf8_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to KOI8R';

create function pg_catalog.utf8_to_koi8u(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8u(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to KOI8U';

create function pg_catalog.utf8_to_shift_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_shift_jis_2004(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

create function pg_catalog.utf8_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_sjis(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to SJIS';

create function pg_catalog.utf8_to_uhc(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_uhc(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to UHC';

create function pg_catalog.utf8_to_win(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_win(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for UTF8 to WIN';

create function pg_catalog.uuid_cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.uuid_eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.uuid_ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.uuid_gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.uuid_hash(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash(unknown) is 'hash';

create function pg_catalog.uuid_hash_extended(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash_extended(unknown, unknown) is 'hash';

create function pg_catalog.uuid_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_in(unknown) is 'I/O';

create function pg_catalog.uuid_le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.uuid_lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.uuid_ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.uuid_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_out(unknown) is 'I/O';

create function pg_catalog.uuid_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_recv(unknown) is 'I/O';

create function pg_catalog.uuid_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_send(unknown) is 'I/O';

create function pg_catalog.uuid_sortsupport(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_sortsupport(unknown) is 'sort support';

create function pg_catalog.varbit(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit(unknown, unknown, unknown) is 'adjust varbit() to typmod length';

create function pg_catalog.varbit_in(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_in(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.varbit_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_out(unknown) is 'I/O';

create function pg_catalog.varbit_recv(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_recv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.varbit_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_send(unknown) is 'I/O';

create function pg_catalog.varbit_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_support(unknown) is 'planner support for varbit length coercion';

create function pg_catalog.varbitcmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitcmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.varbiteq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbiteq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.varbitge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.varbitgt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitgt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.varbitle(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitle(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.varbitlt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitlt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.varbitne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.varbittypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodin(unknown) is 'I/O typmod';

create function pg_catalog.varbittypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodout(unknown) is 'I/O typmod';

create function pg_catalog.varchar(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(unknown) is 'convert name to varchar';

create function pg_catalog.varchar(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(unknown, unknown, unknown) is 'adjust varchar() to typmod length';

create function pg_catalog.varchar_support(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar_support(unknown) is 'planner support for varchar length coercion';

create function pg_catalog.varcharin(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharin(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.varcharout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharout(unknown) is 'I/O';

create function pg_catalog.varcharrecv(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharrecv(unknown, unknown, unknown) is 'I/O';

create function pg_catalog.varcharsend(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharsend(unknown) is 'I/O';

create function pg_catalog.varchartypmodin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodin(unknown) is 'I/O typmod';

create function pg_catalog.varchartypmodout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodout(unknown) is 'I/O typmod';

create function pg_catalog.version() returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.version() is 'PostgreSQL version string';

create function pg_catalog.void_in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_in(unknown) is 'I/O';

create function pg_catalog.void_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_out(unknown) is 'I/O';

create function pg_catalog.void_recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_recv(unknown) is 'I/O';

create function pg_catalog.void_send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_send(unknown) is 'I/O';

create function pg_catalog.websearch_to_tsquery(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(unknown) is 'transform to tsquery';

create function pg_catalog.websearch_to_tsquery(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(unknown, unknown) is 'transform to tsquery';

create function pg_catalog.width(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width(unknown) is 'box width';

create function pg_catalog.width_bucket(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(unknown, unknown) is 'bucket number of operand given a sorted array of bucket lower bounds';

create function pg_catalog.win1250_to_latin2(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_latin2(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1250 to LATIN2';

create function pg_catalog.win1250_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1250 to MULE_INTERNAL';

create function pg_catalog.win1251_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1251 to ISO-8859-5';

create function pg_catalog.win1251_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1251 to KOI8R';

create function pg_catalog.win1251_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1251 to MULE_INTERNAL';

create function pg_catalog.win1251_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_win866(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN1251 to WIN866';

create function pg_catalog.win866_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_iso(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN866 to ISO-8859-5';

create function pg_catalog.win866_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_koi8r(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN866 to KOI8R';

create function pg_catalog.win866_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_mic(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN866 to MULE_INTERNAL';

create function pg_catalog.win866_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_win1251(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN866 to WIN1251';

create function pg_catalog.win_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win_to_utf8(unknown, unknown, unknown, unknown, unknown, unknown) is 'internal conversion function for WIN to UTF8';

create function pg_catalog.xid(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid(unknown) is 'convert xid8 to xid';

create function pg_catalog.xid8cmp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8cmp(unknown, unknown) is 'less-equal-greater';

create function pg_catalog.xid8eq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8eq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.xid8ge(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ge(unknown, unknown) is 'implementation of >= operator';

create function pg_catalog.xid8gt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8gt(unknown, unknown) is 'implementation of > operator';

create function pg_catalog.xid8in(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8in(unknown) is 'I/O';

create function pg_catalog.xid8le(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8le(unknown, unknown) is 'implementation of <= operator';

create function pg_catalog.xid8lt(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8lt(unknown, unknown) is 'implementation of < operator';

create function pg_catalog.xid8ne(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ne(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.xid8out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8out(unknown) is 'I/O';

create function pg_catalog.xid8recv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8recv(unknown) is 'I/O';

create function pg_catalog.xid8send(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8send(unknown) is 'I/O';

create function pg_catalog.xideq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideq(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.xideqint4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideqint4(unknown, unknown) is 'implementation of = operator';

create function pg_catalog.xidin(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidin(unknown) is 'I/O';

create function pg_catalog.xidneq(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneq(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.xidneqint4(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneqint4(unknown, unknown) is 'implementation of <> operator';

create function pg_catalog.xidout(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidout(unknown) is 'I/O';

create function pg_catalog.xidrecv(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidrecv(unknown) is 'I/O';

create function pg_catalog.xidsend(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidsend(unknown) is 'I/O';

create function pg_catalog.xml(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml(unknown) is 'perform a non-validating parse of a character string to produce an XML value';

create function pg_catalog.xml_in(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_in(unknown) is 'I/O';

create function pg_catalog.xml_is_well_formed(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed(unknown) is 'determine if a string is well formed XML';

create function pg_catalog.xml_is_well_formed_content(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_content(unknown) is 'determine if a string is well formed XML content';

create function pg_catalog.xml_is_well_formed_document(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_document(unknown) is 'determine if a string is well formed XML document';

create function pg_catalog.xml_out(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_out(unknown) is 'I/O';

create function pg_catalog.xml_recv(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_recv(unknown) is 'I/O';

create function pg_catalog.xml_send(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_send(unknown) is 'I/O';

create function pg_catalog.xmlcomment(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlcomment(unknown) is 'generate XML comment';

create function pg_catalog.xmlconcat2(unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlconcat2(unknown, unknown) is 'aggregate transition function';

create function pg_catalog.xmlexists(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlexists(unknown, unknown) is 'test XML value against XPath expression';

create function pg_catalog.xmlvalidate(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlvalidate(unknown, unknown) is 'validate an XML value';

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(unknown, unknown) is 'evaluate XPath expression';

create function pg_catalog.xpath(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(unknown, unknown, unknown) is 'evaluate XPath expression, with namespaces support';

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(unknown, unknown) is 'test XML value against XPath expression';

create function pg_catalog.xpath_exists(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(unknown, unknown, unknown) is 'test XML value against XPath expression, with namespace support';

create operator pg_catalog.!! (procedure = tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery) is 'NOT tsquery';

create operator pg_catalog.## (procedure = close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line) is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg) is 'closest point to A on B';

create operator pg_catalog.# (procedure = int8xor, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bigint, bigint) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = bitxor, leftarg = bit, rightarg = bit, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bit, bit) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box) is 'box intersection';

create operator pg_catalog.# (procedure = int4xor, leftarg = integer, rightarg = integer, commutator = pg_catalog.#);

comment on operator pg_catalog.#(integer, integer) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = line_interpt, leftarg = line, rightarg = line, commutator = pg_catalog.#);

comment on operator pg_catalog.#(line, line) is 'intersection point';

create operator pg_catalog.# (procedure = lseg_interpt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.#);

comment on operator pg_catalog.#(lseg, lseg) is 'intersection point';

create operator pg_catalog.# (procedure = int2xor, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(smallint, smallint) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path) is 'number of points';

create operator pg_catalog.# (procedure = poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon) is 'number of points';

create operator pg_catalog.#- (procedure = jsonb_delete_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#-(jsonb, text[]) is 'delete path';

create operator pg_catalog.#> (procedure = json_extract_path, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>(json, text[]) is 'get value from json with path elements';

create operator pg_catalog.#> (procedure = jsonb_extract_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>(jsonb, text[]) is 'get value from jsonb with path elements';

create operator pg_catalog.#>> (procedure = json_extract_path_text, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>>(json, text[]) is 'get value from json as text with path elements';

create operator pg_catalog.#>> (procedure = jsonb_extract_path_text, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>>(jsonb, text[]) is 'get value from jsonb as text with path elements';

create operator pg_catalog.% (procedure = int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint) is 'modulus';

create operator pg_catalog.% (procedure = int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer) is 'modulus';

create operator pg_catalog.% (procedure = numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric) is 'modulus';

create operator pg_catalog.% (procedure = int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint) is 'modulus';

create operator pg_catalog.&& (procedure = arrayoverlap, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.&&, join = arraycontjoinsel, restrict = arraycontsel);

comment on operator pg_catalog.&&(anyarray, anyarray) is 'overlaps';

create operator pg_catalog.&& (procedure = multirange_overlaps_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.&&, join = areajoinsel, restrict = multirangesel);

comment on operator pg_catalog.&&(anymultirange, anymultirange) is 'overlaps';

create operator pg_catalog.&& (procedure = multirange_overlaps_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.&&, join = areajoinsel, restrict = multirangesel);

comment on operator pg_catalog.&&(anymultirange, anyrange) is 'overlaps';

create operator pg_catalog.&& (procedure = range_overlaps_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.&&, join = areajoinsel, restrict = multirangesel);

comment on operator pg_catalog.&&(anyrange, anymultirange) is 'overlaps';

create operator pg_catalog.&& (procedure = range_overlaps, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.&&, join = areajoinsel, restrict = rangesel);

comment on operator pg_catalog.&&(anyrange, anyrange) is 'overlaps';

create operator pg_catalog.&& (procedure = box_overlap, leftarg = box, rightarg = box, commutator = pg_catalog.&&, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.&&(box, box) is 'overlaps';

create operator pg_catalog.&& (procedure = circle_overlap, leftarg = circle, rightarg = circle, commutator = pg_catalog.&&, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.&&(circle, circle) is 'overlaps';

create operator pg_catalog.&& (procedure = network_overlap, leftarg = inet, rightarg = inet, commutator = pg_catalog.&&, join = networkjoinsel, restrict = networksel);

comment on operator pg_catalog.&&(inet, inet) is 'overlaps (is subnet or supernet)';

create operator pg_catalog.&& (procedure = poly_overlap, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.&&, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.&&(polygon, polygon) is 'overlaps';

create operator pg_catalog.&& (procedure = tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery) is 'AND-concatenate';

create operator pg_catalog.& (procedure = int8and, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bigint, bigint) is 'bitwise and';

create operator pg_catalog.& (procedure = bitand, leftarg = bit, rightarg = bit, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bit, bit) is 'bitwise and';

create operator pg_catalog.& (procedure = inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet) is 'bitwise and';

create operator pg_catalog.& (procedure = int4and, leftarg = integer, rightarg = integer, commutator = pg_catalog.&);

comment on operator pg_catalog.&(integer, integer) is 'bitwise and';

create operator pg_catalog.& (procedure = macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr) is 'bitwise and';

create operator pg_catalog.& (procedure = macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8) is 'bitwise and';

create operator pg_catalog.& (procedure = int2and, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(smallint, smallint) is 'bitwise and';

create operator pg_catalog.&< (procedure = multirange_overleft_multirange, leftarg = anymultirange, rightarg = anymultirange, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&<(anymultirange, anymultirange) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = multirange_overleft_range, leftarg = anymultirange, rightarg = anyrange, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&<(anymultirange, anyrange) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = range_overleft_multirange, leftarg = anyrange, rightarg = anymultirange, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&<(anyrange, anymultirange) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = range_overleft, leftarg = anyrange, rightarg = anyrange, join = scalarltjoinsel, restrict = rangesel);

comment on operator pg_catalog.&<(anyrange, anyrange) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = box_overleft, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<(box, box) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = circle_overleft, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<(circle, circle) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = poly_overleft, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<(polygon, polygon) is 'overlaps or is left of';

create operator pg_catalog.&<| (procedure = box_overbelow, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<|(box, box) is 'overlaps or is below';

create operator pg_catalog.&<| (procedure = circle_overbelow, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<|(circle, circle) is 'overlaps or is below';

create operator pg_catalog.&<| (procedure = poly_overbelow, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&<|(polygon, polygon) is 'overlaps or is below';

create operator pg_catalog.&> (procedure = multirange_overright_multirange, leftarg = anymultirange, rightarg = anymultirange, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&>(anymultirange, anymultirange) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = multirange_overright_range, leftarg = anymultirange, rightarg = anyrange, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&>(anymultirange, anyrange) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = range_overright_multirange, leftarg = anyrange, rightarg = anymultirange, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.&>(anyrange, anymultirange) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = range_overright, leftarg = anyrange, rightarg = anyrange, join = scalargtjoinsel, restrict = rangesel);

comment on operator pg_catalog.&>(anyrange, anyrange) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = box_overright, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&>(box, box) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = circle_overright, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&>(circle, circle) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = poly_overright, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.&>(polygon, polygon) is 'overlaps or is right of';

create operator pg_catalog.* (procedure = multirange_intersect, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anymultirange, anymultirange) is 'multirange intersect';

create operator pg_catalog.* (procedure = range_intersect, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anyrange, anyrange) is 'range intersection';

create operator pg_catalog.* (procedure = int8mul, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, bigint) is 'multiply';

create operator pg_catalog.* (procedure = int84mul, leftarg = bigint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, integer) is 'multiply';

create operator pg_catalog.* (procedure = int8_mul_cash, leftarg = bigint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, money) is 'multiply';

create operator pg_catalog.* (procedure = int82mul, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, smallint) is 'multiply';

create operator pg_catalog.* (procedure = box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point) is 'multiply box by point (scale)';

create operator pg_catalog.* (procedure = circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point) is 'multiply';

create operator pg_catalog.* (procedure = float8mul, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, double precision) is 'multiply';

create operator pg_catalog.* (procedure = mul_d_interval, leftarg = double precision, rightarg = interval, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, interval) is 'multiply';

create operator pg_catalog.* (procedure = flt8_mul_cash, leftarg = double precision, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, money) is 'multiply';

create operator pg_catalog.* (procedure = float84mul, leftarg = double precision, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, real) is 'multiply';

create operator pg_catalog.* (procedure = int48mul, leftarg = integer, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, bigint) is 'multiply';

create operator pg_catalog.* (procedure = int4mul, leftarg = integer, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, integer) is 'multiply';

create operator pg_catalog.* (procedure = int4_mul_cash, leftarg = integer, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, money) is 'multiply';

create operator pg_catalog.* (procedure = int42mul, leftarg = integer, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, smallint) is 'multiply';

create operator pg_catalog.* (procedure = interval_mul, leftarg = interval, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(interval, double precision) is 'multiply';

create operator pg_catalog.* (procedure = cash_mul_int8, leftarg = money, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, bigint) is 'multiply';

create operator pg_catalog.* (procedure = cash_mul_flt8, leftarg = money, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, double precision) is 'multiply';

create operator pg_catalog.* (procedure = cash_mul_int4, leftarg = money, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, integer) is 'multiply';

create operator pg_catalog.* (procedure = cash_mul_flt4, leftarg = money, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, real) is 'multiply';

create operator pg_catalog.* (procedure = cash_mul_int2, leftarg = money, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, smallint) is 'multiply';

create operator pg_catalog.* (procedure = numeric_mul, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.*);

comment on operator pg_catalog.*(numeric, numeric) is 'multiply';

create operator pg_catalog.* (procedure = path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point) is 'multiply (rotate/scale path)';

create operator pg_catalog.* (procedure = point_mul, leftarg = point, rightarg = point, commutator = pg_catalog.*);

comment on operator pg_catalog.*(point, point) is 'multiply points (scale/rotate)';

create operator pg_catalog.* (procedure = float48mul, leftarg = real, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, double precision) is 'multiply';

create operator pg_catalog.* (procedure = flt4_mul_cash, leftarg = real, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, money) is 'multiply';

create operator pg_catalog.* (procedure = float4mul, leftarg = real, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, real) is 'multiply';

create operator pg_catalog.* (procedure = int28mul, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, bigint) is 'multiply';

create operator pg_catalog.* (procedure = int24mul, leftarg = smallint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, integer) is 'multiply';

create operator pg_catalog.* (procedure = int2_mul_cash, leftarg = smallint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, money) is 'multiply';

create operator pg_catalog.* (procedure = int2mul, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, smallint) is 'multiply';

create operator pg_catalog.+ (procedure = aclinsert, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem[], aclitem) is 'add/update ACL item';

create operator pg_catalog.+ (procedure = multirange_union, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anymultirange, anymultirange) is 'multirange union';

create operator pg_catalog.+ (procedure = range_union, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anyrange, anyrange) is 'range union';

create operator pg_catalog.+ (procedure = int8pl, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, bigint) is 'add';

create operator pg_catalog.+ (procedure = int8pl_inet, leftarg = bigint, rightarg = inet, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, inet) is 'add';

create operator pg_catalog.+ (procedure = int84pl, leftarg = bigint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, integer) is 'add';

create operator pg_catalog.+ (procedure = int82pl, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, smallint) is 'add';

create operator pg_catalog.+ (procedure = box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point) is 'add point to box (translate)';

create operator pg_catalog.+ (procedure = circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point) is 'add';

create operator pg_catalog.+ (procedure = integer_pl_date, leftarg = integer, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, date) is 'add';

create operator pg_catalog.+ (procedure = date_pli, leftarg = date, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, integer) is 'add';

create operator pg_catalog.+ (procedure = date_pl_interval, leftarg = date, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, interval) is 'add';

create operator pg_catalog.+ (procedure = datetimetz_pl, leftarg = date, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

create operator pg_catalog.+ (procedure = datetime_pl, leftarg = date, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time) is 'convert date and time to timestamp';

create operator pg_catalog.+ (procedure = float8pl, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, double precision) is 'add';

create operator pg_catalog.+ (procedure = float84pl, leftarg = double precision, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, real) is 'add';

create operator pg_catalog.+ (procedure = inetpl, leftarg = inet, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(inet, bigint) is 'add';

create operator pg_catalog.+ (procedure = int48pl, leftarg = integer, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, bigint) is 'add';

create operator pg_catalog.+ (procedure = int4pl, leftarg = integer, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, integer) is 'add';

create operator pg_catalog.+ (procedure = int42pl, leftarg = integer, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, smallint) is 'add';

create operator pg_catalog.+ (procedure = interval_pl_date, leftarg = interval, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, date) is 'add';

create operator pg_catalog.+ (procedure = interval_pl, leftarg = interval, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, interval) is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timetz, leftarg = interval, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time with time zone) is 'add';

create operator pg_catalog.+ (procedure = interval_pl_time, leftarg = interval, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time) is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp with time zone) is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timestamp, leftarg = interval, rightarg = timestamp, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp) is 'add';

create operator pg_catalog.+ (procedure = cash_pl, leftarg = money, rightarg = money, commutator = pg_catalog.+);

comment on operator pg_catalog.+(money, money) is 'add';

create operator pg_catalog.+ (procedure = numeric_add, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, numeric) is 'add';

create operator pg_catalog.+ (procedure = numeric_pl_pg_lsn, leftarg = numeric, rightarg = pg_lsn, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, pg_lsn) is 'add';

create operator pg_catalog.+ (procedure = path_add, leftarg = path, rightarg = path, commutator = pg_catalog.+);

comment on operator pg_catalog.+(path, path) is 'concatenate';

create operator pg_catalog.+ (procedure = path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point) is 'add (translate path)';

create operator pg_catalog.+ (procedure = pg_lsn_pli, leftarg = pg_lsn, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(pg_lsn, numeric) is 'add';

create operator pg_catalog.+ (procedure = point_add, leftarg = point, rightarg = point, commutator = pg_catalog.+);

comment on operator pg_catalog.+(point, point) is 'add points (translate)';

create operator pg_catalog.+ (procedure = float48pl, leftarg = real, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, double precision) is 'add';

create operator pg_catalog.+ (procedure = float4pl, leftarg = real, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, real) is 'add';

create operator pg_catalog.+ (procedure = int28pl, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, bigint) is 'add';

create operator pg_catalog.+ (procedure = int24pl, leftarg = smallint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, integer) is 'add';

create operator pg_catalog.+ (procedure = int2pl, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, smallint) is 'add';

create operator pg_catalog.+ (procedure = timetzdate_pl, leftarg = time with time zone, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, date) is 'convert time with time zone and date to timestamp with time zone';

create operator pg_catalog.+ (procedure = timetz_pl_interval, leftarg = time with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, interval) is 'add';

create operator pg_catalog.+ (procedure = timedate_pl, leftarg = time, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, date) is 'convert time and date to timestamp';

create operator pg_catalog.+ (procedure = time_pl_interval, leftarg = time, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, interval) is 'add';

create operator pg_catalog.+ (procedure = timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp with time zone, interval) is 'add';

create operator pg_catalog.+ (procedure = timestamp_pl_interval, leftarg = timestamp, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp, interval) is 'add';

create operator pg_catalog.+ (procedure = int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint) is 'unary plus';

create operator pg_catalog.+ (procedure = float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision) is 'unary plus';

create operator pg_catalog.+ (procedure = int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer) is 'unary plus';

create operator pg_catalog.+ (procedure = numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric) is 'unary plus';

create operator pg_catalog.+ (procedure = float4up, rightarg = real);

comment on operator pg_catalog.+(none, real) is 'unary plus';

create operator pg_catalog.+ (procedure = int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint) is 'unary plus';

create operator pg_catalog.- (procedure = aclremove, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem[], aclitem) is 'remove ACL item';

create operator pg_catalog.- (procedure = multirange_minus, leftarg = anymultirange, rightarg = anymultirange);

comment on operator pg_catalog.-(anymultirange, anymultirange) is 'multirange minus';

create operator pg_catalog.- (procedure = range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange) is 'range difference';

create operator pg_catalog.- (procedure = int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint) is 'subtract';

create operator pg_catalog.- (procedure = int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer) is 'subtract';

create operator pg_catalog.- (procedure = int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint) is 'subtract';

create operator pg_catalog.- (procedure = box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point) is 'subtract point from box (translate)';

create operator pg_catalog.- (procedure = circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point) is 'subtract';

create operator pg_catalog.- (procedure = date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date) is 'subtract';

create operator pg_catalog.- (procedure = date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer) is 'subtract';

create operator pg_catalog.- (procedure = date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval) is 'subtract';

create operator pg_catalog.- (procedure = float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision) is 'subtract';

create operator pg_catalog.- (procedure = float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real) is 'subtract';

create operator pg_catalog.- (procedure = inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint) is 'subtract';

create operator pg_catalog.- (procedure = inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet) is 'subtract';

create operator pg_catalog.- (procedure = int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint) is 'subtract';

create operator pg_catalog.- (procedure = int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer) is 'subtract';

create operator pg_catalog.- (procedure = int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint) is 'subtract';

create operator pg_catalog.- (procedure = interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval) is 'subtract';

create operator pg_catalog.- (procedure = jsonb_delete, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer) is 'delete array element';

create operator pg_catalog.- (procedure = jsonb_delete, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text) is 'delete object field';

create operator pg_catalog.- (procedure = jsonb_delete, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.-(jsonb, text[]) is 'delete object fields';

create operator pg_catalog.- (procedure = cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money) is 'subtract';

create operator pg_catalog.- (procedure = numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric) is 'subtract';

create operator pg_catalog.- (procedure = path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point) is 'subtract (translate path)';

create operator pg_catalog.- (procedure = pg_lsn_mii, leftarg = pg_lsn, rightarg = numeric);

comment on operator pg_catalog.-(pg_lsn, numeric) is 'subtract';

create operator pg_catalog.- (procedure = pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn) is 'minus';

create operator pg_catalog.- (procedure = point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point) is 'subtract points (translate)';

create operator pg_catalog.- (procedure = float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision) is 'subtract';

create operator pg_catalog.- (procedure = float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real) is 'subtract';

create operator pg_catalog.- (procedure = int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint) is 'subtract';

create operator pg_catalog.- (procedure = int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer) is 'subtract';

create operator pg_catalog.- (procedure = int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint) is 'subtract';

create operator pg_catalog.- (procedure = timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval) is 'subtract';

create operator pg_catalog.- (procedure = time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval) is 'subtract';

create operator pg_catalog.- (procedure = time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time) is 'subtract';

create operator pg_catalog.- (procedure = timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval) is 'subtract';

create operator pg_catalog.- (procedure = timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone) is 'subtract';

create operator pg_catalog.- (procedure = timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval) is 'subtract';

create operator pg_catalog.- (procedure = timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp) is 'subtract';

create operator pg_catalog.- (procedure = int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint) is 'negate';

create operator pg_catalog.- (procedure = float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision) is 'negate';

create operator pg_catalog.- (procedure = int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer) is 'negate';

create operator pg_catalog.- (procedure = interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval) is 'negate';

create operator pg_catalog.- (procedure = numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric) is 'negate';

create operator pg_catalog.- (procedure = float4um, rightarg = real);

comment on operator pg_catalog.-(none, real) is 'negate';

create operator pg_catalog.- (procedure = int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint) is 'negate';

create operator pg_catalog.-> (procedure = json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer) is 'get json array element';

create operator pg_catalog.-> (procedure = json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text) is 'get json object field';

create operator pg_catalog.-> (procedure = jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer) is 'get jsonb array element';

create operator pg_catalog.-> (procedure = jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text) is 'get jsonb object field';

create operator pg_catalog.->> (procedure = json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer) is 'get json array element as text';

create operator pg_catalog.->> (procedure = json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text) is 'get json object field as text';

create operator pg_catalog.->> (procedure = jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer) is 'get jsonb array element as text';

create operator pg_catalog.->> (procedure = jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text) is 'get jsonb object field as text';

create operator pg_catalog.-|- (procedure = multirange_adjacent_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.-|-, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.-|-(anymultirange, anymultirange) is 'is adjacent to';

create operator pg_catalog.-|- (procedure = multirange_adjacent_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.-|-, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.-|-(anymultirange, anyrange) is 'is adjacent to';

create operator pg_catalog.-|- (procedure = range_adjacent_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.-|-, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.-|-(anyrange, anymultirange) is 'is adjacent to';

create operator pg_catalog.-|- (procedure = range_adjacent, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.-|-, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.-|-(anyrange, anyrange) is 'is adjacent to';

create operator pg_catalog./ (procedure = int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint) is 'divide';

create operator pg_catalog./ (procedure = int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer) is 'divide';

create operator pg_catalog./ (procedure = int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint) is 'divide';

create operator pg_catalog./ (procedure = box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point) is 'divide box by point (scale)';

create operator pg_catalog./ (procedure = circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point) is 'divide';

create operator pg_catalog./ (procedure = float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision) is 'divide';

create operator pg_catalog./ (procedure = float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real) is 'divide';

create operator pg_catalog./ (procedure = int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint) is 'divide';

create operator pg_catalog./ (procedure = int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer) is 'divide';

create operator pg_catalog./ (procedure = int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint) is 'divide';

create operator pg_catalog./ (procedure = interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision) is 'divide';

create operator pg_catalog./ (procedure = cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint) is 'divide';

create operator pg_catalog./ (procedure = cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision) is 'divide';

create operator pg_catalog./ (procedure = cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer) is 'divide';

create operator pg_catalog./ (procedure = cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money) is 'divide';

create operator pg_catalog./ (procedure = cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real) is 'divide';

create operator pg_catalog./ (procedure = cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint) is 'divide';

create operator pg_catalog./ (procedure = numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric) is 'divide';

create operator pg_catalog./ (procedure = path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point) is 'divide (rotate/scale path)';

create operator pg_catalog./ (procedure = point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point) is 'divide points (scale/rotate)';

create operator pg_catalog./ (procedure = float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision) is 'divide';

create operator pg_catalog./ (procedure = float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real) is 'divide';

create operator pg_catalog./ (procedure = int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint) is 'divide';

create operator pg_catalog./ (procedure = int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer) is 'divide';

create operator pg_catalog./ (procedure = int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint) is 'divide';

create operator pg_catalog.<-> (procedure = box_distance, leftarg = box, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, box) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_bl, leftarg = box, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, line) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_bs, leftarg = box, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_bp, leftarg = box, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, point) is 'distance between';

create operator pg_catalog.<-> (procedure = circle_distance, leftarg = circle, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_cpoint, leftarg = circle, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, point) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_cpoly, leftarg = circle, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_lb, leftarg = line, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, box) is 'distance between';

create operator pg_catalog.<-> (procedure = line_distance, leftarg = line, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, line) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ls, leftarg = line, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_lp, leftarg = line, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, point) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_sb, leftarg = lseg, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, box) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_sl, leftarg = lseg, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, line) is 'distance between';

create operator pg_catalog.<-> (procedure = lseg_distance, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_sp, leftarg = lseg, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, point) is 'distance between';

create operator pg_catalog.<-> (procedure = path_distance, leftarg = path, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, path) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_pathp, leftarg = path, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, point) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_pb, leftarg = point, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, box) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_pc, leftarg = point, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_pl, leftarg = point, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, line) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ps, leftarg = point, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, path) is 'distance between';

create operator pg_catalog.<-> (procedure = point_distance, leftarg = point, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, point) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ppoly, leftarg = point, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_polyc, leftarg = polygon, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = dist_polyp, leftarg = polygon, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, point) is 'distance between';

create operator pg_catalog.<-> (procedure = poly_distance, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = tsquery_phrase, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery) is 'phrase-concatenate';

create operator pg_catalog.<< (procedure = int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = box_left, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<(box, box) is 'is left of';

create operator pg_catalog.<< (procedure = circle_left, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<(circle, circle) is 'is left of';

create operator pg_catalog.<< (procedure = int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = point_left, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<(point, point) is 'is left of';

create operator pg_catalog.<< (procedure = poly_left, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<(polygon, polygon) is 'is left of';

create operator pg_catalog.<< (procedure = int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer) is 'bitwise shift left';

create operator pg_catalog.<<| (procedure = box_below, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<|(box, box) is 'is below';

create operator pg_catalog.<<| (procedure = circle_below, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<|(circle, circle) is 'is below';

create operator pg_catalog.<<| (procedure = point_below, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<|(point, point) is 'is below';

create operator pg_catalog.<<| (procedure = poly_below, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<<|(polygon, polygon) is 'is below';

create operator pg_catalog.<@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box) is 'is contained by';

create operator pg_catalog.<@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line) is 'lseg on line';

create operator pg_catalog.<@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line) is 'point on line';

create operator pg_catalog.<@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg) is 'is contained by';

create operator pg_catalog.<^ (procedure = box_below_eq, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<^(box, box) is 'is below (allows touching)';

create operator pg_catalog.<^ (procedure = point_below, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.<^(point, point) is 'deprecated, use <<| instead';

create operator pg_catalog.>> (procedure = int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = box_right, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>>(box, box) is 'is right of';

create operator pg_catalog.>> (procedure = circle_right, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>>(circle, circle) is 'is right of';

create operator pg_catalog.>> (procedure = int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = point_right, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>>(point, point) is 'is right of';

create operator pg_catalog.>> (procedure = poly_right, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>>(polygon, polygon) is 'is right of';

create operator pg_catalog.>> (procedure = int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer) is 'bitwise shift right';

create operator pg_catalog.>^ (procedure = box_above_eq, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>^(box, box) is 'is above (allows touching)';

create operator pg_catalog.>^ (procedure = point_above, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.>^(point, point) is 'deprecated, use |>> instead';

create operator pg_catalog.?# (procedure = box_overlap, leftarg = box, rightarg = box, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.?#(box, box) is 'deprecated, use && instead';

create operator pg_catalog.?# (procedure = inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box) is 'intersect';

create operator pg_catalog.?# (procedure = line_intersect, leftarg = line, rightarg = line, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(line, line) is 'intersect';

create operator pg_catalog.?# (procedure = inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box) is 'intersect';

create operator pg_catalog.?# (procedure = inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line) is 'intersect';

create operator pg_catalog.?# (procedure = lseg_intersect, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(lseg, lseg) is 'intersect';

create operator pg_catalog.?# (procedure = path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path) is 'intersect';

create operator pg_catalog.?& (procedure = jsonb_exists_all, leftarg = jsonb, rightarg = text[], join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.?&(jsonb, text[]) is 'all keys exist';

create operator pg_catalog.? (procedure = jsonb_exists, leftarg = jsonb, rightarg = text, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.?(jsonb, text) is 'key exists';

create operator pg_catalog.?- (procedure = point_horiz, leftarg = point, rightarg = point, commutator = pg_catalog.?-);

comment on operator pg_catalog.?-(point, point) is 'horizontally aligned';

create operator pg_catalog.?- (procedure = line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line) is 'horizontal';

create operator pg_catalog.?- (procedure = lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg) is 'horizontal';

create operator pg_catalog.?-| (procedure = line_perp, leftarg = line, rightarg = line, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(line, line) is 'perpendicular';

create operator pg_catalog.?-| (procedure = lseg_perp, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(lseg, lseg) is 'perpendicular';

create operator pg_catalog.?| (procedure = jsonb_exists_any, leftarg = jsonb, rightarg = text[], join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.?|(jsonb, text[]) is 'any key exists';

create operator pg_catalog.?| (procedure = point_vert, leftarg = point, rightarg = point, commutator = pg_catalog.?|);

comment on operator pg_catalog.?|(point, point) is 'vertically aligned';

create operator pg_catalog.?| (procedure = line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line) is 'vertical';

create operator pg_catalog.?| (procedure = lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg) is 'vertical';

create operator pg_catalog.?|| (procedure = line_parallel, leftarg = line, rightarg = line, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(line, line) is 'parallel';

create operator pg_catalog.?|| (procedure = lseg_parallel, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(lseg, lseg) is 'parallel';

create operator pg_catalog.@ (procedure = int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint) is 'absolute value';

create operator pg_catalog.@ (procedure = float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision) is 'absolute value';

create operator pg_catalog.@ (procedure = int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer) is 'absolute value';

create operator pg_catalog.@ (procedure = numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric) is 'absolute value';

create operator pg_catalog.@ (procedure = float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real) is 'absolute value';

create operator pg_catalog.@ (procedure = int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint) is 'absolute value';

create operator pg_catalog.@-@ (procedure = lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg) is 'distance between endpoints';

create operator pg_catalog.@-@ (procedure = path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path) is 'sum of path segment lengths';

create operator pg_catalog.@> (procedure = aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem[], aclitem) is 'contains';

create operator pg_catalog.@? (procedure = jsonb_path_exists_opr, leftarg = jsonb, rightarg = jsonpath, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@?(jsonb, jsonpath) is 'jsonpath exists';

create operator pg_catalog.@@ (procedure = jsonb_path_match_opr, leftarg = jsonb, rightarg = jsonpath, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@@(jsonb, jsonpath) is 'jsonpath match';

create operator pg_catalog.@@ (procedure = ts_match_tt, leftarg = text, rightarg = text, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@@(text, text) is 'text search match';

create operator pg_catalog.@@ (procedure = ts_match_tq, leftarg = text, rightarg = tsquery, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@@(text, tsquery) is 'text search match';

create operator pg_catalog.@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@, join = tsmatchjoinsel, restrict = tsmatchsel);

comment on operator pg_catalog.@@(tsvector, tsquery) is 'text search match';

create operator pg_catalog.@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@, join = tsmatchjoinsel, restrict = tsmatchsel);

comment on operator pg_catalog.@@(tsquery, tsvector) is 'text search match';

create operator pg_catalog.@@ (procedure = box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box) is 'center of';

create operator pg_catalog.@@ (procedure = circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle) is 'center of';

create operator pg_catalog.@@ (procedure = lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg) is 'center of';

create operator pg_catalog.@@ (procedure = path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path) is 'center of';

create operator pg_catalog.@@ (procedure = poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon) is 'center of';

create operator pg_catalog.@@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@@, join = tsmatchjoinsel, restrict = tsmatchsel);

comment on operator pg_catalog.@@@(tsvector, tsquery) is 'deprecated, use @@ instead';

create operator pg_catalog.@@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@@, join = tsmatchjoinsel, restrict = tsmatchsel);

comment on operator pg_catalog.@@@(tsquery, tsvector) is 'deprecated, use @@ instead';

create operator pg_catalog.^ (procedure = dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision) is 'exponentiation';

create operator pg_catalog.^ (procedure = numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric) is 'exponentiation';

create operator pg_catalog.^@ (procedure = starts_with, leftarg = text, rightarg = text, join = prefixjoinsel, restrict = prefixsel);

comment on operator pg_catalog.^@(text, text) is 'starts with';

create operator pg_catalog.|&> (procedure = box_overabove, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|&>(box, box) is 'overlaps or is above';

create operator pg_catalog.|&> (procedure = circle_overabove, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|&>(circle, circle) is 'overlaps or is above';

create operator pg_catalog.|&> (procedure = poly_overabove, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|&>(polygon, polygon) is 'overlaps or is above';

create operator pg_catalog.| (procedure = int8or, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bigint, bigint) is 'bitwise or';

create operator pg_catalog.| (procedure = bitor, leftarg = bit, rightarg = bit, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bit, bit) is 'bitwise or';

create operator pg_catalog.| (procedure = inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet) is 'bitwise or';

create operator pg_catalog.| (procedure = int4or, leftarg = integer, rightarg = integer, commutator = pg_catalog.|);

comment on operator pg_catalog.|(integer, integer) is 'bitwise or';

create operator pg_catalog.| (procedure = macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr) is 'bitwise or';

create operator pg_catalog.| (procedure = macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8) is 'bitwise or';

create operator pg_catalog.| (procedure = int2or, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(smallint, smallint) is 'bitwise or';

create operator pg_catalog.|/ (procedure = dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision) is 'square root';

create operator pg_catalog.|>> (procedure = box_above, leftarg = box, rightarg = box, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|>>(box, box) is 'is above';

create operator pg_catalog.|>> (procedure = circle_above, leftarg = circle, rightarg = circle, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|>>(circle, circle) is 'is above';

create operator pg_catalog.|>> (procedure = point_above, leftarg = point, rightarg = point, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|>>(point, point) is 'is above';

create operator pg_catalog.|>> (procedure = poly_above, leftarg = polygon, rightarg = polygon, join = positionjoinsel, restrict = positionsel);

comment on operator pg_catalog.|>>(polygon, polygon) is 'is above';

create operator pg_catalog.|| (procedure = array_prepend, leftarg = anycompatible, rightarg = anycompatiblearray);

comment on operator pg_catalog.||(anycompatible, anycompatiblearray) is 'prepend element onto front of array';

create operator pg_catalog.|| (procedure = array_append, leftarg = anycompatiblearray, rightarg = anycompatible);

comment on operator pg_catalog.||(anycompatiblearray, anycompatible) is 'append element onto end of array';

create operator pg_catalog.|| (procedure = array_cat, leftarg = anycompatiblearray, rightarg = anycompatiblearray);

comment on operator pg_catalog.||(anycompatiblearray, anycompatiblearray) is 'concatenate';

create operator pg_catalog.|| (procedure = anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text) is 'concatenate';

create operator pg_catalog.|| (procedure = bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying) is 'concatenate';

create operator pg_catalog.|| (procedure = byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea) is 'concatenate';

create operator pg_catalog.|| (procedure = jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb) is 'concatenate';

create operator pg_catalog.|| (procedure = textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray) is 'concatenate';

create operator pg_catalog.|| (procedure = textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text) is 'concatenate';

create operator pg_catalog.|| (procedure = tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery) is 'OR-concatenate';

create operator pg_catalog.|| (procedure = tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector) is 'concatenate';

create operator pg_catalog.||/ (procedure = dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision) is 'cube root';

create operator pg_catalog.~ (procedure = int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint) is 'bitwise not';

create operator pg_catalog.~ (procedure = bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit) is 'bitwise not';

create operator pg_catalog.~ (procedure = inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet) is 'bitwise not';

create operator pg_catalog.~ (procedure = int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer) is 'bitwise not';

create operator pg_catalog.~ (procedure = macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr) is 'bitwise not';

create operator pg_catalog.~ (procedure = macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8) is 'bitwise not';

create operator pg_catalog.~ (procedure = int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint) is 'bitwise not';

create operator pg_catalog.~= (procedure = box_same, leftarg = box, rightarg = box, commutator = pg_catalog.~=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.~=(box, box) is 'same as';

create operator pg_catalog.~= (procedure = circle_same, leftarg = circle, rightarg = circle, commutator = pg_catalog.~=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.~=(circle, circle) is 'same as';

create operator pg_catalog.~= (procedure = poly_same, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.~=(polygon, polygon) is 'same as';

create aggregate pg_catalog.corr(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_corr,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.corr(unknown, unknown) is 'correlation coefficient';

create aggregate pg_catalog.count() (
    sfunc = int8inc,
    stype = ???,
combinefunc = int8pl,
msfunc = int8inc,
minvfunc = int8dec
);

comment on aggregate pg_catalog.count() is 'number of input rows';

create aggregate pg_catalog.count(unknown) (
    sfunc = int8inc_any,
    stype = ???,
combinefunc = int8pl,
msfunc = int8inc_any,
minvfunc = int8dec_any
);

comment on aggregate pg_catalog.count(unknown) is 'number of input rows for which the input expression is not null';

create aggregate pg_catalog.covar_pop(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_covar_pop,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.covar_pop(unknown, unknown) is 'population covariance';

create aggregate pg_catalog.covar_samp(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_covar_samp,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.covar_samp(unknown, unknown) is 'sample covariance';

create aggregate pg_catalog.cume_dist(unknown) (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = cume_dist_final
);

comment on aggregate pg_catalog.cume_dist(unknown) is 'cumulative distribution of hypothetical row';

create aggregate pg_catalog.dense_rank(unknown) (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = dense_rank_final
);

comment on aggregate pg_catalog.dense_rank(unknown) is 'rank of hypothetical row without gaps';

create aggregate pg_catalog.json_agg(unknown) (
    sfunc = json_agg_transfn,
    stype = ???,
finalfunc = json_agg_finalfn
);

comment on aggregate pg_catalog.json_agg(unknown) is 'aggregate input into json';

create aggregate pg_catalog.json_object_agg(unknown, unknown) (
    sfunc = json_object_agg_transfn,
    stype = ???,
finalfunc = json_object_agg_finalfn
);

comment on aggregate pg_catalog.json_object_agg(unknown, unknown) is 'aggregate input into a json object';

create aggregate pg_catalog.jsonb_agg(unknown) (
    sfunc = jsonb_agg_transfn,
    stype = ???,
finalfunc = jsonb_agg_finalfn
);

comment on aggregate pg_catalog.jsonb_agg(unknown) is 'aggregate input into jsonb';

create aggregate pg_catalog.jsonb_object_agg(unknown, unknown) (
    sfunc = jsonb_object_agg_transfn,
    stype = ???,
finalfunc = jsonb_object_agg_finalfn
);

comment on aggregate pg_catalog.jsonb_object_agg(unknown, unknown) is 'aggregate inputs into jsonb object';

create aggregate pg_catalog.mode(unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = mode_final
);

comment on aggregate pg_catalog.mode(unknown) is 'most common value';

create aggregate pg_catalog.percent_rank(unknown) (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = percent_rank_final
);

comment on aggregate pg_catalog.percent_rank(unknown) is 'fractional rank of hypothetical row';

create aggregate pg_catalog.range_agg(unknown) (
    sfunc = range_agg_transfn,
    stype = ???,
finalfunc = range_agg_finalfn
);

comment on aggregate pg_catalog.range_agg(unknown) is 'combine aggregate input into a multirange';

create aggregate pg_catalog.rank(unknown) (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = rank_final
);

comment on aggregate pg_catalog.rank(unknown) is 'rank of hypothetical row';

create aggregate pg_catalog.regr_avgx(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_avgx,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_avgx(unknown, unknown) is 'average of the independent variable (sum(X)/N)';

create aggregate pg_catalog.regr_avgy(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_avgy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_avgy(unknown, unknown) is 'average of the dependent variable (sum(Y)/N)';

create aggregate pg_catalog.regr_count(unknown, unknown) (
    sfunc = int8inc_float8_float8,
    stype = ???,
combinefunc = int8pl
);

comment on aggregate pg_catalog.regr_count(unknown, unknown) is 'number of input rows in which both expressions are not null';

create aggregate pg_catalog.regr_intercept(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_intercept,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_intercept(unknown, unknown) is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.regr_r2(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_r2,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_r2(unknown, unknown) is 'square of the correlation coefficient';

create aggregate pg_catalog.regr_slope(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_slope,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_slope(unknown, unknown) is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.regr_sxx(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_sxx,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_sxx(unknown, unknown) is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

create aggregate pg_catalog.regr_sxy(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_sxy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_sxy(unknown, unknown) is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

create aggregate pg_catalog.regr_syy(unknown, unknown) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_syy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_syy(unknown, unknown) is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

create aggregate pg_catalog.xmlagg(unknown) (
    sfunc = xmlconcat2,
    stype = ???
);

comment on aggregate pg_catalog.xmlagg(unknown) is 'concatenate XML values';

create operator family pg_catalog.aclitem_ops using hash;

alter operator family pg_catalog.aclitem_ops using hash add
    function 1(aclitem, aclitem) hash_aclitem(aclitem),
    function 2(aclitem, aclitem) hash_aclitem_extended(aclitem,bigint);

create operator class pg_catalog.aclitem_ops default for type aclitem using hash as
    operator 1 =(aclitem,aclitem);

create operator family pg_catalog.array_ops using btree;

alter operator family pg_catalog.array_ops using btree add
    function 1(anyarray, anyarray) btarraycmp(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using btree as
    operator 1 <(anyarray,anyarray),
    operator 2 <=(anyarray,anyarray),
    operator 3 =(anyarray,anyarray),
    operator 4 >=(anyarray,anyarray),
    operator 5 >(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using gin as storage anyelement operator 1 <(anyarray,anyarray),
	operator 2 <=(anyarray,anyarray),
	operator 3 =(anyarray,anyarray),
	operator 4 >=(anyarray,anyarray),
	operator 5 >(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using hash as
    operator 1 <(anyarray,anyarray),
    operator 2 <=(anyarray,anyarray),
    operator 3 =(anyarray,anyarray),
    operator 4 >=(anyarray,anyarray),
    operator 5 >(anyarray,anyarray);

create operator family pg_catalog.array_ops using gin;

alter operator family pg_catalog.array_ops using gin add
    operator 1 &&(anyarray,anyarray),
    operator 2 @>(anyarray,anyarray),
    operator 3 <@(anyarray,anyarray),
    operator 4 =(anyarray,anyarray),
    function 2(anyarray, anyarray) ginarrayextract(anyarray,internal,internal),
    function 3(anyarray, anyarray) ginqueryarrayextract(anyarray,internal,smallint,internal,internal,internal,internal),
    function 4(anyarray, anyarray) ginarrayconsistent(internal,smallint,anyarray,integer,internal,internal,internal,internal),
    function 6(anyarray, anyarray) ginarraytriconsistent(internal,smallint,anyarray,integer,internal,internal,internal);

create operator family pg_catalog.array_ops using hash;

alter operator family pg_catalog.array_ops using hash add
    operator 1 =(anyarray,anyarray),
    function 1(anyarray, anyarray) hash_array(anyarray),
    function 2(anyarray, anyarray) hash_array_extended(anyarray,bigint);

create operator family pg_catalog.bit_minmax_ops using brin;

alter operator family pg_catalog.bit_minmax_ops using brin add
    function 1(bit, bit) brin_minmax_opcinfo(internal),
    function 2(bit, bit) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bit, bit) brin_minmax_consistent(internal,internal,internal),
    function 4(bit, bit) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bit_minmax_ops default for type bit using brin as storage bit operator 1 <(bit,bit),
	operator 2 <=(bit,bit),
	operator 3 =(bit,bit),
	operator 4 >=(bit,bit),
	operator 5 >(bit,bit);

create operator family pg_catalog.bit_ops using btree;

alter operator family pg_catalog.bit_ops using btree add
    function 1(bit, bit) bitcmp(bit,bit),
    function 4(bit, bit) btequalimage(oid);

create operator class pg_catalog.bit_ops default for type bit using btree as
    operator 1 <(bit,bit),
    operator 2 <=(bit,bit),
    operator 3 =(bit,bit),
    operator 4 >=(bit,bit),
    operator 5 >(bit,bit);

create operator family pg_catalog.bool_ops using btree;

alter operator family pg_catalog.bool_ops using btree add
    function 1(boolean, boolean) btboolcmp(boolean,boolean),
    function 4(boolean, boolean) btequalimage(oid);

create operator class pg_catalog.bool_ops default for type boolean using btree as
    operator 1 <(boolean,boolean),
    operator 2 <=(boolean,boolean),
    operator 3 =(boolean,boolean),
    operator 4 >=(boolean,boolean),
    operator 5 >(boolean,boolean);

create operator class pg_catalog.bool_ops default for type boolean using hash as
    operator 1 <(boolean,boolean),
    operator 2 <=(boolean,boolean),
    operator 3 =(boolean,boolean),
    operator 4 >=(boolean,boolean),
    operator 5 >(boolean,boolean);

create operator family pg_catalog.bool_ops using hash;

alter operator family pg_catalog.bool_ops using hash add
    operator 1 =(boolean,boolean),
    function 1(boolean, boolean) hashchar("char"),
    function 2(boolean, boolean) hashcharextended("char",bigint);

create operator family pg_catalog.box_inclusion_ops using brin;

alter operator family pg_catalog.box_inclusion_ops using brin add
    function 11(box, box) bound_box(box,box),
    function 13(box, box) box_contain(box,box),
    function 1(box, box) brin_inclusion_opcinfo(internal),
    function 2(box, box) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(box, box) brin_inclusion_consistent(internal,internal,internal),
    function 4(box, box) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.box_inclusion_ops default for type box using brin as storage box operator 10 <<|(box,box),
	operator 11 |>>(box,box),
	operator 12 |&>(box,box),
	operator 1 <<(box,box),
	operator 2 &<(box,box),
	operator 3 &&(box,box),
	operator 4 &>(box,box),
	operator 5 >>(box,box),
	operator 6 ~=(box,box),
	operator 7 @>(box,box),
	operator 7 @>(box,point),
	operator 8 <@(box,box),
	operator 9 &<|(box,box);

create operator family pg_catalog.box_ops using gist;

alter operator family pg_catalog.box_ops using gist add
    function 1(box, box) gist_box_consistent(internal,box,smallint,oid,internal),
    function 2(box, box) gist_box_union(internal,internal),
    function 5(box, box) gist_box_penalty(internal,internal,internal),
    function 6(box, box) gist_box_picksplit(internal,internal),
    function 7(box, box) gist_box_same(box,box,internal),
    function 8(box, box) gist_box_distance(internal,box,smallint,oid,internal);

create operator class pg_catalog.box_ops default for type box using gist as
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box);

create operator class pg_catalog.box_ops default for type box using spgist as
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box);

create operator family pg_catalog.box_ops using spgist;

alter operator family pg_catalog.box_ops using spgist add
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box),
    function 1(box, box) spg_box_quad_config(internal,internal),
    function 2(box, box) spg_box_quad_choose(internal,internal),
    function 3(box, box) spg_box_quad_picksplit(internal,internal),
    function 4(box, box) spg_box_quad_inner_consistent(internal,internal),
    function 5(box, box) spg_box_quad_leaf_consistent(internal,internal);

create operator family pg_catalog.bpchar_bloom_ops using brin;

alter operator family pg_catalog.bpchar_bloom_ops using brin add
    function 11(character, character) hashbpchar(character),
    function 1(character, character) brin_bloom_opcinfo(internal),
    function 2(character, character) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(character, character) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(character, character) brin_bloom_union(internal,internal,internal),
    function 5(character, character) brin_bloom_options(internal);

create operator class pg_catalog.bpchar_bloom_ops for type character using brin as storage character operator 1 =(character,character);

create operator family pg_catalog.bpchar_minmax_ops using brin;

alter operator family pg_catalog.bpchar_minmax_ops using brin add
    function 1(character, character) brin_minmax_opcinfo(internal),
    function 2(character, character) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(character, character) brin_minmax_consistent(internal,internal,internal),
    function 4(character, character) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bpchar_minmax_ops default for type character using brin as storage character operator 1 <(character,character),
	operator 2 <=(character,character),
	operator 3 =(character,character),
	operator 4 >=(character,character),
	operator 5 >(character,character);

create operator family pg_catalog.bpchar_ops using btree;

alter operator family pg_catalog.bpchar_ops using btree add
    function 1(character, character) bpcharcmp(character,character),
    function 2(character, character) bpchar_sortsupport(internal),
    function 4(character, character) btvarstrequalimage(oid);

create operator class pg_catalog.bpchar_ops default for type character using btree as
    operator 1 <(character,character),
    operator 2 <=(character,character),
    operator 3 =(character,character),
    operator 4 >=(character,character),
    operator 5 >(character,character);

create operator class pg_catalog.bpchar_ops default for type character using hash as
    operator 1 <(character,character),
    operator 2 <=(character,character),
    operator 3 =(character,character),
    operator 4 >=(character,character),
    operator 5 >(character,character);

create operator family pg_catalog.bpchar_ops using hash;

alter operator family pg_catalog.bpchar_ops using hash add
    operator 1 =(character,character),
    function 1(character, character) hashbpchar(character),
    function 2(character, character) hashbpcharextended(character,bigint);

create operator family pg_catalog.bpchar_pattern_ops using btree;

alter operator family pg_catalog.bpchar_pattern_ops using btree add
    function 1(character, character) btbpchar_pattern_cmp(character,character),
    function 2(character, character) btbpchar_pattern_sortsupport(internal),
    function 4(character, character) btequalimage(oid);

create operator class pg_catalog.bpchar_pattern_ops for type character using btree as
    operator 1 ~<~(character,character),
    operator 2 ~<=~(character,character),
    operator 3 =(character,character),
    operator 4 ~>=~(character,character),
    operator 5 ~>~(character,character);

create operator class pg_catalog.bpchar_pattern_ops for type character using hash as
    operator 1 ~<~(character,character),
    operator 2 ~<=~(character,character),
    operator 3 =(character,character),
    operator 4 ~>=~(character,character),
    operator 5 ~>~(character,character);

create operator family pg_catalog.bpchar_pattern_ops using hash;

alter operator family pg_catalog.bpchar_pattern_ops using hash add
    operator 1 =(character,character),
    function 1(character, character) hashbpchar(character),
    function 2(character, character) hashbpcharextended(character,bigint);

create operator family pg_catalog.bytea_bloom_ops using brin;

alter operator family pg_catalog.bytea_bloom_ops using brin add
    function 11(bytea, bytea) hashvarlena(internal),
    function 1(bytea, bytea) brin_bloom_opcinfo(internal),
    function 2(bytea, bytea) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(bytea, bytea) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(bytea, bytea) brin_bloom_union(internal,internal,internal),
    function 5(bytea, bytea) brin_bloom_options(internal);

create operator class pg_catalog.bytea_bloom_ops for type bytea using brin as storage bytea operator 1 =(bytea,bytea);

create operator family pg_catalog.bytea_minmax_ops using brin;

alter operator family pg_catalog.bytea_minmax_ops using brin add
    function 1(bytea, bytea) brin_minmax_opcinfo(internal),
    function 2(bytea, bytea) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bytea, bytea) brin_minmax_consistent(internal,internal,internal),
    function 4(bytea, bytea) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bytea_minmax_ops default for type bytea using brin as storage bytea operator 1 <(bytea,bytea),
	operator 2 <=(bytea,bytea),
	operator 3 =(bytea,bytea),
	operator 4 >=(bytea,bytea),
	operator 5 >(bytea,bytea);

create operator family pg_catalog.bytea_ops using btree;

alter operator family pg_catalog.bytea_ops using btree add
    function 1(bytea, bytea) byteacmp(bytea,bytea),
    function 2(bytea, bytea) bytea_sortsupport(internal),
    function 4(bytea, bytea) btequalimage(oid);

create operator class pg_catalog.bytea_ops default for type bytea using btree as
    operator 1 <(bytea,bytea),
    operator 2 <=(bytea,bytea),
    operator 3 =(bytea,bytea),
    operator 4 >=(bytea,bytea),
    operator 5 >(bytea,bytea);

create operator class pg_catalog.bytea_ops default for type bytea using hash as
    operator 1 <(bytea,bytea),
    operator 2 <=(bytea,bytea),
    operator 3 =(bytea,bytea),
    operator 4 >=(bytea,bytea),
    operator 5 >(bytea,bytea);

create operator family pg_catalog.bytea_ops using hash;

alter operator family pg_catalog.bytea_ops using hash add
    operator 1 =(bytea,bytea),
    function 1(bytea, bytea) hashvarlena(internal),
    function 2(bytea, bytea) hashvarlenaextended(internal,bigint);

create operator family pg_catalog.char_bloom_ops using brin;

alter operator family pg_catalog.char_bloom_ops using brin add
    function 11("char", "char") hashchar("char"),
    function 1("char", "char") brin_bloom_opcinfo(internal),
    function 2("char", "char") brin_bloom_add_value(internal,internal,internal,internal),
    function 3("char", "char") brin_bloom_consistent(internal,internal,internal,integer),
    function 4("char", "char") brin_bloom_union(internal,internal,internal),
    function 5("char", "char") brin_bloom_options(internal);

create operator class pg_catalog.char_bloom_ops for type "char" using brin as storage "char" operator 1 =("char","char");

create operator family pg_catalog.char_minmax_ops using brin;

alter operator family pg_catalog.char_minmax_ops using brin add
    function 1("char", "char") brin_minmax_opcinfo(internal),
    function 2("char", "char") brin_minmax_add_value(internal,internal,internal,internal),
    function 3("char", "char") brin_minmax_consistent(internal,internal,internal),
    function 4("char", "char") brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.char_minmax_ops default for type "char" using brin as storage "char" operator 1 <("char","char"),
	operator 2 <=("char","char"),
	operator 3 =("char","char"),
	operator 4 >=("char","char"),
	operator 5 >("char","char");

create operator family pg_catalog.char_ops using btree;

alter operator family pg_catalog.char_ops using btree add
    function 1("char", "char") btcharcmp("char","char"),
    function 4("char", "char") btequalimage(oid);

create operator class pg_catalog.char_ops default for type "char" using btree as
    operator 1 <("char","char"),
    operator 2 <=("char","char"),
    operator 3 =("char","char"),
    operator 4 >=("char","char"),
    operator 5 >("char","char");

create operator class pg_catalog.char_ops default for type "char" using hash as
    operator 1 <("char","char"),
    operator 2 <=("char","char"),
    operator 3 =("char","char"),
    operator 4 >=("char","char"),
    operator 5 >("char","char");

create operator family pg_catalog.char_ops using hash;

alter operator family pg_catalog.char_ops using hash add
    operator 1 =("char","char"),
    function 1("char", "char") hashchar("char"),
    function 2("char", "char") hashcharextended("char",bigint);

create operator family pg_catalog.cid_ops using hash;

alter operator family pg_catalog.cid_ops using hash add
    function 1(cid, cid) hashint4(integer),
    function 2(cid, cid) hashint4extended(integer,bigint);

create operator class pg_catalog.cid_ops default for type cid using hash as
    operator 1 =(cid,cid);

create operator family pg_catalog.circle_ops using gist;

alter operator family pg_catalog.circle_ops using gist add
    function 1(circle, circle) gist_circle_consistent(internal,circle,smallint,oid,internal),
    function 2(circle, circle) gist_box_union(internal,internal),
    function 3(circle, circle) gist_circle_compress(internal),
    function 5(circle, circle) gist_box_penalty(internal,internal,internal),
    function 6(circle, circle) gist_box_picksplit(internal,internal),
    function 7(circle, circle) gist_box_same(box,box,internal),
    function 8(circle, circle) gist_circle_distance(internal,circle,smallint,oid,internal);

create operator class pg_catalog.circle_ops default for type circle using gist as storage box operator 10 <<|(circle,circle),
	operator 11 |>>(circle,circle),
	operator 12 |&>(circle,circle),
	operator 15 <->(circle,point),
	operator 1 <<(circle,circle),
	operator 2 &<(circle,circle),
	operator 3 &&(circle,circle),
	operator 4 &>(circle,circle),
	operator 5 >>(circle,circle),
	operator 6 ~=(circle,circle),
	operator 7 @>(circle,circle),
	operator 8 <@(circle,circle),
	operator 9 &<|(circle,circle);

create operator family pg_catalog.date_ops using hash;

alter operator family pg_catalog.date_ops using hash add
    function 1(date, date) hashint4(integer),
    function 2(date, date) hashint4extended(integer,bigint);

create operator class pg_catalog.date_ops default for type date using hash as
    operator 1 =(date,date);

create operator family pg_catalog.datetime_bloom_ops using brin;

alter operator family pg_catalog.datetime_bloom_ops using brin add
    function 11(date, date) hashint4(integer),
    function 11(timestamp with time zone, timestamp with time zone) timestamp_hash(timestamp without time zone),
    function 11(timestamp without time zone, timestamp without time zone) timestamp_hash(timestamp without time zone),
    function 1(date, date) brin_bloom_opcinfo(internal),
    function 1(timestamp with time zone, timestamp with time zone) brin_bloom_opcinfo(internal),
    function 1(timestamp without time zone, timestamp without time zone) brin_bloom_opcinfo(internal),
    function 2(date, date) brin_bloom_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, timestamp with time zone) brin_bloom_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, timestamp without time zone) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(date, date) brin_bloom_consistent(internal,internal,internal,integer),
    function 3(timestamp with time zone, timestamp with time zone) brin_bloom_consistent(internal,internal,internal,integer),
    function 3(timestamp without time zone, timestamp without time zone) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(date, date) brin_bloom_union(internal,internal,internal),
    function 4(timestamp with time zone, timestamp with time zone) brin_bloom_union(internal,internal,internal),
    function 4(timestamp without time zone, timestamp without time zone) brin_bloom_union(internal,internal,internal),
    function 5(date, date) brin_bloom_options(internal),
    function 5(timestamp with time zone, timestamp with time zone) brin_bloom_options(internal),
    function 5(timestamp without time zone, timestamp without time zone) brin_bloom_options(internal);

create operator class pg_catalog.date_bloom_ops for type date using brin family pg_catalog.datetime_bloom_ops as storage date operator 1 =(date,date),
	operator 1 =(timestamp with time zone,timestamp with time zone),
	operator 1 =(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_bloom_ops for type timestamp without time zone using brin family pg_catalog.datetime_bloom_ops as storage timestamp without time zone operator 1 =(date,date),
	operator 1 =(timestamp with time zone,timestamp with time zone),
	operator 1 =(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_bloom_ops for type timestamp with time zone using brin family pg_catalog.datetime_bloom_ops as storage timestamp with time zone operator 1 =(date,date),
	operator 1 =(timestamp with time zone,timestamp with time zone),
	operator 1 =(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.datetime_minmax_multi_ops using brin;

alter operator family pg_catalog.datetime_minmax_multi_ops using brin add
    function 11(date, date) brin_minmax_multi_distance_date(internal,internal),
    function 11(timestamp with time zone, timestamp with time zone) brin_minmax_multi_distance_timestamp(internal,internal),
    function 11(timestamp without time zone, timestamp without time zone) brin_minmax_multi_distance_timestamp(internal,internal),
    function 1(date, date) brin_minmax_multi_opcinfo(internal),
    function 1(timestamp with time zone, timestamp with time zone) brin_minmax_multi_opcinfo(internal),
    function 1(timestamp without time zone, timestamp without time zone) brin_minmax_multi_opcinfo(internal),
    function 2(date, date) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, timestamp with time zone) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, timestamp without time zone) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(date, date) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 3(timestamp with time zone, timestamp with time zone) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 3(timestamp without time zone, timestamp without time zone) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(date, date) brin_minmax_multi_union(internal,internal,internal),
    function 4(timestamp with time zone, timestamp with time zone) brin_minmax_multi_union(internal,internal,internal),
    function 4(timestamp without time zone, timestamp without time zone) brin_minmax_multi_union(internal,internal,internal),
    function 5(date, date) brin_minmax_multi_options(internal),
    function 5(timestamp with time zone, timestamp with time zone) brin_minmax_multi_options(internal),
    function 5(timestamp without time zone, timestamp without time zone) brin_minmax_multi_options(internal);

create operator class pg_catalog.date_minmax_multi_ops for type date using brin family pg_catalog.datetime_minmax_multi_ops as storage date operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_minmax_multi_ops for type timestamp without time zone using brin family pg_catalog.datetime_minmax_multi_ops as storage timestamp without time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_minmax_multi_ops for type timestamp with time zone using brin family pg_catalog.datetime_minmax_multi_ops as storage timestamp with time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.datetime_minmax_ops using brin;

alter operator family pg_catalog.datetime_minmax_ops using brin add
    function 1(date, date) brin_minmax_opcinfo(internal),
    function 1(timestamp with time zone, timestamp with time zone) brin_minmax_opcinfo(internal),
    function 1(timestamp without time zone, timestamp without time zone) brin_minmax_opcinfo(internal),
    function 2(date, date) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, timestamp with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, timestamp without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(date, date) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp with time zone, timestamp with time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp without time zone, timestamp without time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(date, date) brin_minmax_union(internal,internal,internal),
    function 4(timestamp with time zone, timestamp with time zone) brin_minmax_union(internal,internal,internal),
    function 4(timestamp without time zone, timestamp without time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.date_minmax_ops default for type date using brin family pg_catalog.datetime_minmax_ops as storage date operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_minmax_ops default for type timestamp without time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp without time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_minmax_ops default for type timestamp with time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp with time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.datetime_ops using btree;

alter operator family pg_catalog.datetime_ops using btree add
    function 1(date, date) date_cmp(date,date),
    function 1(date, timestamp with time zone) date_cmp_timestamptz(date,timestamp with time zone),
    function 1(date, timestamp without time zone) date_cmp_timestamp(date,timestamp without time zone),
    function 1(timestamp with time zone, date) timestamptz_cmp_date(timestamp with time zone,date),
    function 1(timestamp with time zone, timestamp with time zone) timestamptz_cmp(timestamp with time zone,timestamp with time zone),
    function 1(timestamp with time zone, timestamp without time zone) timestamptz_cmp_timestamp(timestamp with time zone,timestamp without time zone),
    function 1(timestamp without time zone, date) timestamp_cmp_date(timestamp without time zone,date),
    function 1(timestamp without time zone, timestamp with time zone) timestamp_cmp_timestamptz(timestamp without time zone,timestamp with time zone),
    function 1(timestamp without time zone, timestamp without time zone) timestamp_cmp(timestamp without time zone,timestamp without time zone),
    function 2(date, date) date_sortsupport(internal),
    function 2(timestamp with time zone, timestamp with time zone) timestamp_sortsupport(internal),
    function 2(timestamp without time zone, timestamp without time zone) timestamp_sortsupport(internal),
    function 3(date, interval) in_range(date,date,interval,boolean,boolean),
    function 3(timestamp with time zone, interval) in_range(timestamp with time zone,timestamp with time zone,interval,boolean,boolean),
    function 3(timestamp without time zone, interval) in_range(timestamp without time zone,timestamp without time zone,interval,boolean,boolean),
    function 4(date, date) btequalimage(oid),
    function 4(timestamp with time zone, timestamp with time zone) btequalimage(oid),
    function 4(timestamp without time zone, timestamp without time zone) btequalimage(oid);

create operator class pg_catalog.date_ops default for type date using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.enum_ops using btree;

alter operator family pg_catalog.enum_ops using btree add
    function 1(anyenum, anyenum) enum_cmp(anyenum,anyenum),
    function 4(anyenum, anyenum) btequalimage(oid);

create operator class pg_catalog.enum_ops default for type anyenum using btree as
    operator 1 <(anyenum,anyenum),
    operator 2 <=(anyenum,anyenum),
    operator 3 =(anyenum,anyenum),
    operator 4 >=(anyenum,anyenum),
    operator 5 >(anyenum,anyenum);

create operator class pg_catalog.enum_ops default for type anyenum using hash as
    operator 1 <(anyenum,anyenum),
    operator 2 <=(anyenum,anyenum),
    operator 3 =(anyenum,anyenum),
    operator 4 >=(anyenum,anyenum),
    operator 5 >(anyenum,anyenum);

create operator family pg_catalog.enum_ops using hash;

alter operator family pg_catalog.enum_ops using hash add
    operator 1 =(anyenum,anyenum),
    function 1(anyenum, anyenum) hashenum(anyenum),
    function 2(anyenum, anyenum) hashenumextended(anyenum,bigint);

create operator family pg_catalog.float_bloom_ops using brin;

alter operator family pg_catalog.float_bloom_ops using brin add
    function 11(double precision, double precision) hashfloat8(double precision),
    function 11(real, real) hashfloat4(real),
    function 1(double precision, double precision) brin_bloom_opcinfo(internal),
    function 1(real, real) brin_bloom_opcinfo(internal),
    function 2(double precision, double precision) brin_bloom_add_value(internal,internal,internal,internal),
    function 2(real, real) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(double precision, double precision) brin_bloom_consistent(internal,internal,internal,integer),
    function 3(real, real) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(double precision, double precision) brin_bloom_union(internal,internal,internal),
    function 4(real, real) brin_bloom_union(internal,internal,internal),
    function 5(double precision, double precision) brin_bloom_options(internal),
    function 5(real, real) brin_bloom_options(internal);

create operator class pg_catalog.float4_bloom_ops for type real using brin family pg_catalog.float_bloom_ops as storage real operator 1 =(double precision,double precision),
	operator 1 =(real,real);

create operator class pg_catalog.float8_bloom_ops for type double precision using brin family pg_catalog.float_bloom_ops as storage double precision operator 1 =(double precision,double precision),
	operator 1 =(real,real);

create operator family pg_catalog.float_minmax_multi_ops using brin;

alter operator family pg_catalog.float_minmax_multi_ops using brin add
    function 11(double precision, double precision) brin_minmax_multi_distance_float8(internal,internal),
    function 11(real, real) brin_minmax_multi_distance_float4(internal,internal),
    function 1(double precision, double precision) brin_minmax_multi_opcinfo(internal),
    function 1(real, real) brin_minmax_multi_opcinfo(internal),
    function 2(double precision, double precision) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 2(real, real) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(double precision, double precision) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 3(real, real) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(double precision, double precision) brin_minmax_multi_union(internal,internal,internal),
    function 4(real, real) brin_minmax_multi_union(internal,internal,internal),
    function 5(double precision, double precision) brin_minmax_multi_options(internal),
    function 5(real, real) brin_minmax_multi_options(internal);

create operator class pg_catalog.float4_minmax_multi_ops for type real using brin family pg_catalog.float_minmax_multi_ops as storage real operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator class pg_catalog.float8_minmax_multi_ops for type double precision using brin family pg_catalog.float_minmax_multi_ops as storage double precision operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator family pg_catalog.float_minmax_ops using brin;

alter operator family pg_catalog.float_minmax_ops using brin add
    function 1(double precision, double precision) brin_minmax_opcinfo(internal),
    function 1(real, real) brin_minmax_opcinfo(internal),
    function 2(double precision, double precision) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(real, real) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(double precision, double precision) brin_minmax_consistent(internal,internal,internal),
    function 3(real, real) brin_minmax_consistent(internal,internal,internal),
    function 4(double precision, double precision) brin_minmax_union(internal,internal,internal),
    function 4(real, real) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.float4_minmax_ops default for type real using brin family pg_catalog.float_minmax_ops as storage real operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator class pg_catalog.float8_minmax_ops default for type double precision using brin family pg_catalog.float_minmax_ops as storage double precision operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator family pg_catalog.float_ops using btree;

alter operator family pg_catalog.float_ops using btree add
    function 1(double precision, double precision) btfloat8cmp(double precision,double precision),
    function 1(double precision, real) btfloat84cmp(double precision,real),
    function 1(real, double precision) btfloat48cmp(real,double precision),
    function 1(real, real) btfloat4cmp(real,real),
    function 2(double precision, double precision) btfloat8sortsupport(internal),
    function 2(real, real) btfloat4sortsupport(internal),
    function 3(double precision, double precision) in_range(double precision,double precision,double precision,boolean,boolean),
    function 3(real, double precision) in_range(real,real,double precision,boolean,boolean);

create operator class pg_catalog.float4_ops default for type real using btree family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float4_ops default for type real using hash family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float8_ops default for type double precision using btree family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float8_ops default for type double precision using hash family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator family pg_catalog.float_ops using hash;

alter operator family pg_catalog.float_ops using hash add
    operator 1 =(double precision,double precision),
    operator 1 =(double precision,real),
    operator 1 =(real,double precision),
    operator 1 =(real,real),
    function 1(double precision, double precision) hashfloat8(double precision),
    function 1(real, real) hashfloat4(real),
    function 2(double precision, double precision) hashfloat8extended(double precision,bigint),
    function 2(real, real) hashfloat4extended(real,bigint);

create operator family pg_catalog.integer_bloom_ops using brin;

alter operator family pg_catalog.integer_bloom_ops using brin add
    function 11(bigint, bigint) hashint8(bigint),
    function 11(integer, integer) hashint4(integer),
    function 11(smallint, smallint) hashint2(smallint),
    function 1(bigint, bigint) brin_bloom_opcinfo(internal),
    function 1(integer, integer) brin_bloom_opcinfo(internal),
    function 1(smallint, smallint) brin_bloom_opcinfo(internal),
    function 2(bigint, bigint) brin_bloom_add_value(internal,internal,internal,internal),
    function 2(integer, integer) brin_bloom_add_value(internal,internal,internal,internal),
    function 2(smallint, smallint) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(bigint, bigint) brin_bloom_consistent(internal,internal,internal,integer),
    function 3(integer, integer) brin_bloom_consistent(internal,internal,internal,integer),
    function 3(smallint, smallint) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(bigint, bigint) brin_bloom_union(internal,internal,internal),
    function 4(integer, integer) brin_bloom_union(internal,internal,internal),
    function 4(smallint, smallint) brin_bloom_union(internal,internal,internal),
    function 5(bigint, bigint) brin_bloom_options(internal),
    function 5(integer, integer) brin_bloom_options(internal),
    function 5(smallint, smallint) brin_bloom_options(internal);

create operator class pg_catalog.int2_bloom_ops for type smallint using brin family pg_catalog.integer_bloom_ops as storage smallint operator 1 =(bigint,bigint),
	operator 1 =(integer,integer),
	operator 1 =(smallint,smallint);

create operator class pg_catalog.int4_bloom_ops for type integer using brin family pg_catalog.integer_bloom_ops as storage integer operator 1 =(bigint,bigint),
	operator 1 =(integer,integer),
	operator 1 =(smallint,smallint);

create operator class pg_catalog.int8_bloom_ops for type bigint using brin family pg_catalog.integer_bloom_ops as storage bigint operator 1 =(bigint,bigint),
	operator 1 =(integer,integer),
	operator 1 =(smallint,smallint);

create operator family pg_catalog.integer_minmax_multi_ops using brin;

alter operator family pg_catalog.integer_minmax_multi_ops using brin add
    function 11(bigint, bigint) brin_minmax_multi_distance_int8(internal,internal),
    function 11(integer, integer) brin_minmax_multi_distance_int4(internal,internal),
    function 11(smallint, smallint) brin_minmax_multi_distance_int2(internal,internal),
    function 1(bigint, bigint) brin_minmax_multi_opcinfo(internal),
    function 1(integer, integer) brin_minmax_multi_opcinfo(internal),
    function 1(smallint, smallint) brin_minmax_multi_opcinfo(internal),
    function 2(bigint, bigint) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 2(integer, integer) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 2(smallint, smallint) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(bigint, bigint) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 3(integer, integer) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 3(smallint, smallint) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(bigint, bigint) brin_minmax_multi_union(internal,internal,internal),
    function 4(integer, integer) brin_minmax_multi_union(internal,internal,internal),
    function 4(smallint, smallint) brin_minmax_multi_union(internal,internal,internal),
    function 5(bigint, bigint) brin_minmax_multi_options(internal),
    function 5(integer, integer) brin_minmax_multi_options(internal),
    function 5(smallint, smallint) brin_minmax_multi_options(internal);

create operator class pg_catalog.int2_minmax_multi_ops for type smallint using brin family pg_catalog.integer_minmax_multi_ops as storage smallint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_minmax_multi_ops for type integer using brin family pg_catalog.integer_minmax_multi_ops as storage integer operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_minmax_multi_ops for type bigint using brin family pg_catalog.integer_minmax_multi_ops as storage bigint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator family pg_catalog.integer_minmax_ops using brin;

alter operator family pg_catalog.integer_minmax_ops using brin add
    function 1(bigint, bigint) brin_minmax_opcinfo(internal),
    function 1(integer, integer) brin_minmax_opcinfo(internal),
    function 1(smallint, smallint) brin_minmax_opcinfo(internal),
    function 2(bigint, bigint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(integer, integer) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(smallint, smallint) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bigint, bigint) brin_minmax_consistent(internal,internal,internal),
    function 3(integer, integer) brin_minmax_consistent(internal,internal,internal),
    function 3(smallint, smallint) brin_minmax_consistent(internal,internal,internal),
    function 4(bigint, bigint) brin_minmax_union(internal,internal,internal),
    function 4(integer, integer) brin_minmax_union(internal,internal,internal),
    function 4(smallint, smallint) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.int2_minmax_ops default for type smallint using brin family pg_catalog.integer_minmax_ops as storage smallint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_minmax_ops default for type integer using brin family pg_catalog.integer_minmax_ops as storage integer operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_minmax_ops default for type bigint using brin family pg_catalog.integer_minmax_ops as storage bigint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator family pg_catalog.integer_ops using btree;

alter operator family pg_catalog.integer_ops using btree add
    function 1(bigint, bigint) btint8cmp(bigint,bigint),
    function 1(bigint, integer) btint84cmp(bigint,integer),
    function 1(bigint, smallint) btint82cmp(bigint,smallint),
    function 1(integer, bigint) btint48cmp(integer,bigint),
    function 1(integer, integer) btint4cmp(integer,integer),
    function 1(integer, smallint) btint42cmp(integer,smallint),
    function 1(smallint, bigint) btint28cmp(smallint,bigint),
    function 1(smallint, integer) btint24cmp(smallint,integer),
    function 1(smallint, smallint) btint2cmp(smallint,smallint),
    function 2(bigint, bigint) btint8sortsupport(internal),
    function 2(integer, integer) btint4sortsupport(internal),
    function 2(smallint, smallint) btint2sortsupport(internal),
    function 3(bigint, bigint) in_range(bigint,bigint,bigint,boolean,boolean),
    function 3(integer, bigint) in_range(integer,integer,bigint,boolean,boolean),
    function 3(integer, integer) in_range(integer,integer,integer,boolean,boolean),
    function 3(integer, smallint) in_range(integer,integer,smallint,boolean,boolean),
    function 3(smallint, bigint) in_range(smallint,smallint,bigint,boolean,boolean),
    function 3(smallint, integer) in_range(smallint,smallint,integer,boolean,boolean),
    function 3(smallint, smallint) in_range(smallint,smallint,smallint,boolean,boolean),
    function 4(bigint, bigint) btequalimage(oid),
    function 4(integer, integer) btequalimage(oid),
    function 4(smallint, smallint) btequalimage(oid);

create operator class pg_catalog.int2_ops default for type smallint using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int2_ops default for type smallint using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_ops default for type integer using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_ops default for type integer using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_ops default for type bigint using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_ops default for type bigint using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator family pg_catalog.integer_ops using hash;

alter operator family pg_catalog.integer_ops using hash add
    operator 1 =(bigint,bigint),
    operator 1 =(bigint,integer),
    operator 1 =(bigint,smallint),
    operator 1 =(integer,bigint),
    operator 1 =(integer,integer),
    operator 1 =(integer,smallint),
    operator 1 =(smallint,bigint),
    operator 1 =(smallint,integer),
    operator 1 =(smallint,smallint),
    function 1(bigint, bigint) hashint8(bigint),
    function 1(integer, integer) hashint4(integer),
    function 1(smallint, smallint) hashint2(smallint),
    function 2(bigint, bigint) hashint8extended(bigint,bigint),
    function 2(integer, integer) hashint4extended(integer,bigint),
    function 2(smallint, smallint) hashint2extended(smallint,bigint);

create operator family pg_catalog.interval_bloom_ops using brin;

alter operator family pg_catalog.interval_bloom_ops using brin add
    function 11(interval, interval) interval_hash(interval),
    function 1(interval, interval) brin_bloom_opcinfo(internal),
    function 2(interval, interval) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(interval, interval) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(interval, interval) brin_bloom_union(internal,internal,internal),
    function 5(interval, interval) brin_bloom_options(internal);

create operator class pg_catalog.interval_bloom_ops for type interval using brin as storage interval operator 1 =(interval,interval);

create operator family pg_catalog.interval_minmax_multi_ops using brin;

alter operator family pg_catalog.interval_minmax_multi_ops using brin add
    function 11(interval, interval) brin_minmax_multi_distance_interval(internal,internal),
    function 1(interval, interval) brin_minmax_multi_opcinfo(internal),
    function 2(interval, interval) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(interval, interval) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(interval, interval) brin_minmax_multi_union(internal,internal,internal),
    function 5(interval, interval) brin_minmax_multi_options(internal);

create operator class pg_catalog.interval_minmax_multi_ops for type interval using brin as storage interval operator 1 <(interval,interval),
	operator 2 <=(interval,interval),
	operator 3 =(interval,interval),
	operator 4 >=(interval,interval),
	operator 5 >(interval,interval);

create operator family pg_catalog.interval_minmax_ops using brin;

alter operator family pg_catalog.interval_minmax_ops using brin add
    function 1(interval, interval) brin_minmax_opcinfo(internal),
    function 2(interval, interval) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(interval, interval) brin_minmax_consistent(internal,internal,internal),
    function 4(interval, interval) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.interval_minmax_ops default for type interval using brin as storage interval operator 1 <(interval,interval),
	operator 2 <=(interval,interval),
	operator 3 =(interval,interval),
	operator 4 >=(interval,interval),
	operator 5 >(interval,interval);

create operator family pg_catalog.interval_ops using btree;

alter operator family pg_catalog.interval_ops using btree add
    function 1(interval, interval) interval_cmp(interval,interval),
    function 3(interval, interval) in_range(interval,interval,interval,boolean,boolean),
    function 4(interval, interval) btequalimage(oid);

create operator class pg_catalog.interval_ops default for type interval using btree as
    operator 1 <(interval,interval),
    operator 2 <=(interval,interval),
    operator 3 =(interval,interval),
    operator 4 >=(interval,interval),
    operator 5 >(interval,interval);

create operator class pg_catalog.interval_ops default for type interval using hash as
    operator 1 <(interval,interval),
    operator 2 <=(interval,interval),
    operator 3 =(interval,interval),
    operator 4 >=(interval,interval),
    operator 5 >(interval,interval);

create operator family pg_catalog.interval_ops using hash;

alter operator family pg_catalog.interval_ops using hash add
    operator 1 =(interval,interval),
    function 1(interval, interval) interval_hash(interval),
    function 2(interval, interval) interval_hash_extended(interval,bigint);

create operator family pg_catalog.jsonb_ops using btree;

alter operator family pg_catalog.jsonb_ops using btree add
    function 1(jsonb, jsonb) jsonb_cmp(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using btree as
    operator 1 <(jsonb,jsonb),
    operator 2 <=(jsonb,jsonb),
    operator 3 =(jsonb,jsonb),
    operator 4 >=(jsonb,jsonb),
    operator 5 >(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using gin as storage text operator 1 <(jsonb,jsonb),
	operator 2 <=(jsonb,jsonb),
	operator 3 =(jsonb,jsonb),
	operator 4 >=(jsonb,jsonb),
	operator 5 >(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using hash as
    operator 1 <(jsonb,jsonb),
    operator 2 <=(jsonb,jsonb),
    operator 3 =(jsonb,jsonb),
    operator 4 >=(jsonb,jsonb),
    operator 5 >(jsonb,jsonb);

create operator family pg_catalog.jsonb_ops using gin;

alter operator family pg_catalog.jsonb_ops using gin add
    operator 10 ?|(jsonb,text[]),
    operator 11 ?&(jsonb,text[]),
    operator 15 @?(jsonb,jsonpath),
    operator 16 @@(jsonb,jsonpath),
    operator 7 @>(jsonb,jsonb),
    operator 9 ?(jsonb,text),
    function 1(jsonb, jsonb) gin_compare_jsonb(text,text),
    function 2(jsonb, jsonb) gin_extract_jsonb(jsonb,internal,internal),
    function 3(jsonb, jsonb) gin_extract_jsonb_query(jsonb,internal,smallint,internal,internal,internal,internal),
    function 4(jsonb, jsonb) gin_consistent_jsonb(internal,smallint,jsonb,integer,internal,internal,internal,internal),
    function 6(jsonb, jsonb) gin_triconsistent_jsonb(internal,smallint,jsonb,integer,internal,internal,internal);

create operator family pg_catalog.jsonb_ops using hash;

alter operator family pg_catalog.jsonb_ops using hash add
    operator 1 =(jsonb,jsonb),
    function 1(jsonb, jsonb) jsonb_hash(jsonb),
    function 2(jsonb, jsonb) jsonb_hash_extended(jsonb,bigint);

create operator family pg_catalog.jsonb_path_ops using gin;

alter operator family pg_catalog.jsonb_path_ops using gin add
    function 1(jsonb, jsonb) btint4cmp(integer,integer),
    function 2(jsonb, jsonb) gin_extract_jsonb_path(jsonb,internal,internal),
    function 3(jsonb, jsonb) gin_extract_jsonb_query_path(jsonb,internal,smallint,internal,internal,internal,internal),
    function 4(jsonb, jsonb) gin_consistent_jsonb_path(internal,smallint,jsonb,integer,internal,internal,internal,internal),
    function 6(jsonb, jsonb) gin_triconsistent_jsonb_path(internal,smallint,jsonb,integer,internal,internal,internal);

create operator class pg_catalog.jsonb_path_ops for type jsonb using gin as storage integer operator 15 @?(jsonb,jsonpath),
	operator 16 @@(jsonb,jsonpath),
	operator 7 @>(jsonb,jsonb);

create operator family pg_catalog.kd_point_ops using spgist;

alter operator family pg_catalog.kd_point_ops using spgist add
    function 1(point, point) spg_kd_config(internal,internal),
    function 2(point, point) spg_kd_choose(internal,internal),
    function 3(point, point) spg_kd_picksplit(internal,internal),
    function 4(point, point) spg_kd_inner_consistent(internal,internal),
    function 5(point, point) spg_quad_leaf_consistent(internal,internal);

create operator class pg_catalog.kd_point_ops for type point using spgist as
    operator 10 <<|(point,point),
    operator 11 |>>(point,point),
    operator 15 <->(point,point),
    operator 1 <<(point,point),
    operator 29 <^(point,point),
    operator 30 >^(point,point),
    operator 5 >>(point,point),
    operator 6 ~=(point,point),
    operator 8 <@(point,box);

create operator family pg_catalog.macaddr8_bloom_ops using brin;

alter operator family pg_catalog.macaddr8_bloom_ops using brin add
    function 11(macaddr8, macaddr8) hashmacaddr8(macaddr8),
    function 1(macaddr8, macaddr8) brin_bloom_opcinfo(internal),
    function 2(macaddr8, macaddr8) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(macaddr8, macaddr8) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(macaddr8, macaddr8) brin_bloom_union(internal,internal,internal),
    function 5(macaddr8, macaddr8) brin_bloom_options(internal);

create operator class pg_catalog.macaddr8_bloom_ops for type macaddr8 using brin as storage macaddr8 operator 1 =(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_minmax_multi_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_multi_ops using brin add
    function 11(macaddr8, macaddr8) brin_minmax_multi_distance_macaddr8(internal,internal),
    function 1(macaddr8, macaddr8) brin_minmax_multi_opcinfo(internal),
    function 2(macaddr8, macaddr8) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(macaddr8, macaddr8) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(macaddr8, macaddr8) brin_minmax_multi_union(internal,internal,internal),
    function 5(macaddr8, macaddr8) brin_minmax_multi_options(internal);

create operator class pg_catalog.macaddr8_minmax_multi_ops for type macaddr8 using brin as storage macaddr8 operator 1 <(macaddr8,macaddr8),
	operator 2 <=(macaddr8,macaddr8),
	operator 3 =(macaddr8,macaddr8),
	operator 4 >=(macaddr8,macaddr8),
	operator 5 >(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_minmax_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_ops using brin add
    function 1(macaddr8, macaddr8) brin_minmax_opcinfo(internal),
    function 2(macaddr8, macaddr8) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(macaddr8, macaddr8) brin_minmax_consistent(internal,internal,internal),
    function 4(macaddr8, macaddr8) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.macaddr8_minmax_ops default for type macaddr8 using brin as storage macaddr8 operator 1 <(macaddr8,macaddr8),
	operator 2 <=(macaddr8,macaddr8),
	operator 3 =(macaddr8,macaddr8),
	operator 4 >=(macaddr8,macaddr8),
	operator 5 >(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_ops using btree;

alter operator family pg_catalog.macaddr8_ops using btree add
    function 1(macaddr8, macaddr8) macaddr8_cmp(macaddr8,macaddr8),
    function 4(macaddr8, macaddr8) btequalimage(oid);

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using btree as
    operator 1 <(macaddr8,macaddr8),
    operator 2 <=(macaddr8,macaddr8),
    operator 3 =(macaddr8,macaddr8),
    operator 4 >=(macaddr8,macaddr8),
    operator 5 >(macaddr8,macaddr8);

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using hash as
    operator 1 <(macaddr8,macaddr8),
    operator 2 <=(macaddr8,macaddr8),
    operator 3 =(macaddr8,macaddr8),
    operator 4 >=(macaddr8,macaddr8),
    operator 5 >(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_ops using hash;

alter operator family pg_catalog.macaddr8_ops using hash add
    operator 1 =(macaddr8,macaddr8),
    function 1(macaddr8, macaddr8) hashmacaddr8(macaddr8),
    function 2(macaddr8, macaddr8) hashmacaddr8extended(macaddr8,bigint);

create operator family pg_catalog.macaddr_bloom_ops using brin;

alter operator family pg_catalog.macaddr_bloom_ops using brin add
    function 11(macaddr, macaddr) hashmacaddr(macaddr),
    function 1(macaddr, macaddr) brin_bloom_opcinfo(internal),
    function 2(macaddr, macaddr) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(macaddr, macaddr) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(macaddr, macaddr) brin_bloom_union(internal,internal,internal),
    function 5(macaddr, macaddr) brin_bloom_options(internal);

create operator class pg_catalog.macaddr_bloom_ops for type macaddr using brin as storage macaddr operator 1 =(macaddr,macaddr);

create operator family pg_catalog.macaddr_minmax_multi_ops using brin;

alter operator family pg_catalog.macaddr_minmax_multi_ops using brin add
    function 11(macaddr, macaddr) brin_minmax_multi_distance_macaddr(internal,internal),
    function 1(macaddr, macaddr) brin_minmax_multi_opcinfo(internal),
    function 2(macaddr, macaddr) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(macaddr, macaddr) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(macaddr, macaddr) brin_minmax_multi_union(internal,internal,internal),
    function 5(macaddr, macaddr) brin_minmax_multi_options(internal);

create operator class pg_catalog.macaddr_minmax_multi_ops for type macaddr using brin as storage macaddr operator 1 <(macaddr,macaddr),
	operator 2 <=(macaddr,macaddr),
	operator 3 =(macaddr,macaddr),
	operator 4 >=(macaddr,macaddr),
	operator 5 >(macaddr,macaddr);

create operator family pg_catalog.macaddr_minmax_ops using brin;

alter operator family pg_catalog.macaddr_minmax_ops using brin add
    function 1(macaddr, macaddr) brin_minmax_opcinfo(internal),
    function 2(macaddr, macaddr) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(macaddr, macaddr) brin_minmax_consistent(internal,internal,internal),
    function 4(macaddr, macaddr) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.macaddr_minmax_ops default for type macaddr using brin as storage macaddr operator 1 <(macaddr,macaddr),
	operator 2 <=(macaddr,macaddr),
	operator 3 =(macaddr,macaddr),
	operator 4 >=(macaddr,macaddr),
	operator 5 >(macaddr,macaddr);

create operator family pg_catalog.macaddr_ops using btree;

alter operator family pg_catalog.macaddr_ops using btree add
    function 1(macaddr, macaddr) macaddr_cmp(macaddr,macaddr),
    function 2(macaddr, macaddr) macaddr_sortsupport(internal),
    function 4(macaddr, macaddr) btequalimage(oid);

create operator class pg_catalog.macaddr_ops default for type macaddr using btree as
    operator 1 <(macaddr,macaddr),
    operator 2 <=(macaddr,macaddr),
    operator 3 =(macaddr,macaddr),
    operator 4 >=(macaddr,macaddr),
    operator 5 >(macaddr,macaddr);

create operator class pg_catalog.macaddr_ops default for type macaddr using hash as
    operator 1 <(macaddr,macaddr),
    operator 2 <=(macaddr,macaddr),
    operator 3 =(macaddr,macaddr),
    operator 4 >=(macaddr,macaddr),
    operator 5 >(macaddr,macaddr);

create operator family pg_catalog.macaddr_ops using hash;

alter operator family pg_catalog.macaddr_ops using hash add
    operator 1 =(macaddr,macaddr),
    function 1(macaddr, macaddr) hashmacaddr(macaddr),
    function 2(macaddr, macaddr) hashmacaddrextended(macaddr,bigint);

create operator family pg_catalog.money_ops using btree;

alter operator family pg_catalog.money_ops using btree add
    function 1(money, money) cash_cmp(money,money),
    function 4(money, money) btequalimage(oid);

create operator class pg_catalog.money_ops default for type money using btree as
    operator 1 <(money,money),
    operator 2 <=(money,money),
    operator 3 =(money,money),
    operator 4 >=(money,money),
    operator 5 >(money,money);

create operator family pg_catalog.multirange_ops using btree;

alter operator family pg_catalog.multirange_ops using btree add
    function 1(anymultirange, anymultirange) multirange_cmp(anymultirange,anymultirange);

create operator class pg_catalog.multirange_ops default for type anymultirange using btree as
    operator 1 <(anymultirange,anymultirange),
    operator 2 <=(anymultirange,anymultirange),
    operator 3 =(anymultirange,anymultirange),
    operator 4 >=(anymultirange,anymultirange),
    operator 5 >(anymultirange,anymultirange);

create operator class pg_catalog.multirange_ops default for type anymultirange using gist as storage anyrange operator 1 <(anymultirange,anymultirange),
	operator 2 <=(anymultirange,anymultirange),
	operator 3 =(anymultirange,anymultirange),
	operator 4 >=(anymultirange,anymultirange),
	operator 5 >(anymultirange,anymultirange);

create operator class pg_catalog.multirange_ops default for type anymultirange using hash as
    operator 1 <(anymultirange,anymultirange),
    operator 2 <=(anymultirange,anymultirange),
    operator 3 =(anymultirange,anymultirange),
    operator 4 >=(anymultirange,anymultirange),
    operator 5 >(anymultirange,anymultirange);

create operator family pg_catalog.multirange_ops using gist;

alter operator family pg_catalog.multirange_ops using gist add
    operator 16 @>(anymultirange,anyelement),
    operator 18 =(anymultirange,anymultirange),
    operator 1 <<(anymultirange,anymultirange),
    operator 1 <<(anymultirange,anyrange),
    operator 2 &<(anymultirange,anymultirange),
    operator 2 &<(anymultirange,anyrange),
    operator 3 &&(anymultirange,anymultirange),
    operator 3 &&(anymultirange,anyrange),
    operator 4 &>(anymultirange,anymultirange),
    operator 4 &>(anymultirange,anyrange),
    operator 5 >>(anymultirange,anymultirange),
    operator 5 >>(anymultirange,anyrange),
    operator 6 -|-(anymultirange,anymultirange),
    operator 6 -|-(anymultirange,anyrange),
    operator 7 @>(anymultirange,anymultirange),
    operator 7 @>(anymultirange,anyrange),
    operator 8 <@(anymultirange,anymultirange),
    operator 8 <@(anymultirange,anyrange),
    function 1(anymultirange, anymultirange) multirange_gist_consistent(internal,anymultirange,smallint,oid,internal),
    function 2(anymultirange, anymultirange) range_gist_union(internal,internal),
    function 3(anymultirange, anymultirange) multirange_gist_compress(internal),
    function 5(anymultirange, anymultirange) range_gist_penalty(internal,internal,internal),
    function 6(anymultirange, anymultirange) range_gist_picksplit(internal,internal),
    function 7(anymultirange, anymultirange) range_gist_same(anyrange,anyrange,internal);

create operator family pg_catalog.multirange_ops using hash;

alter operator family pg_catalog.multirange_ops using hash add
    operator 1 =(anymultirange,anymultirange),
    function 1(anymultirange, anymultirange) hash_multirange(anymultirange),
    function 2(anymultirange, anymultirange) hash_multirange_extended(anymultirange,bigint);

create operator family pg_catalog.name_bloom_ops using brin;

alter operator family pg_catalog.name_bloom_ops using brin add
    function 11(name, name) hashname(name),
    function 1(name, name) brin_bloom_opcinfo(internal),
    function 2(name, name) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(name, name) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(name, name) brin_bloom_union(internal,internal,internal),
    function 5(name, name) brin_bloom_options(internal);

create operator class pg_catalog.name_bloom_ops for type name using brin as storage name operator 1 =(name,name);

create operator family pg_catalog.name_minmax_ops using brin;

alter operator family pg_catalog.name_minmax_ops using brin add
    function 1(name, name) brin_minmax_opcinfo(internal),
    function 2(name, name) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(name, name) brin_minmax_consistent(internal,internal,internal),
    function 4(name, name) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.name_minmax_ops default for type name using brin as storage name operator 1 <(name,name),
	operator 2 <=(name,name),
	operator 3 =(name,name),
	operator 4 >=(name,name),
	operator 5 >(name,name);

create operator family pg_catalog.network_bloom_ops using brin;

alter operator family pg_catalog.network_bloom_ops using brin add
    function 11(inet, inet) hashinet(inet),
    function 1(inet, inet) brin_bloom_opcinfo(internal),
    function 2(inet, inet) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(inet, inet) brin_bloom_union(internal,internal,internal),
    function 5(inet, inet) brin_bloom_options(internal);

create operator class pg_catalog.inet_bloom_ops for type inet using brin family pg_catalog.network_bloom_ops as storage inet operator 1 =(inet,inet);

create operator family pg_catalog.network_inclusion_ops using brin;

alter operator family pg_catalog.network_inclusion_ops using brin add
    function 11(inet, inet) inet_merge(inet,inet),
    function 12(inet, inet) inet_same_family(inet,inet),
    function 13(inet, inet) network_supeq(inet,inet),
    function 1(inet, inet) brin_inclusion_opcinfo(internal),
    function 2(inet, inet) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_inclusion_consistent(internal,internal,internal),
    function 4(inet, inet) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.inet_inclusion_ops default for type inet using brin family pg_catalog.network_inclusion_ops as storage inet operator 18 =(inet,inet),
	operator 24 >>(inet,inet),
	operator 26 <<(inet,inet),
	operator 3 &&(inet,inet),
	operator 7 >>=(inet,inet),
	operator 8 <<=(inet,inet);

create operator family pg_catalog.network_minmax_multi_ops using brin;

alter operator family pg_catalog.network_minmax_multi_ops using brin add
    function 11(inet, inet) brin_minmax_multi_distance_inet(internal,internal),
    function 1(inet, inet) brin_minmax_multi_opcinfo(internal),
    function 2(inet, inet) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(inet, inet) brin_minmax_multi_union(internal,internal,internal),
    function 5(inet, inet) brin_minmax_multi_options(internal);

create operator class pg_catalog.inet_minmax_multi_ops for type inet using brin family pg_catalog.network_minmax_multi_ops as storage inet operator 1 <(inet,inet),
	operator 2 <=(inet,inet),
	operator 3 =(inet,inet),
	operator 4 >=(inet,inet),
	operator 5 >(inet,inet);

create operator family pg_catalog.network_minmax_ops using brin;

alter operator family pg_catalog.network_minmax_ops using brin add
    function 1(inet, inet) brin_minmax_opcinfo(internal),
    function 2(inet, inet) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_minmax_consistent(internal,internal,internal),
    function 4(inet, inet) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.inet_minmax_ops for type inet using brin family pg_catalog.network_minmax_ops as storage inet operator 1 <(inet,inet),
	operator 2 <=(inet,inet),
	operator 3 =(inet,inet),
	operator 4 >=(inet,inet),
	operator 5 >(inet,inet);

create operator family pg_catalog.network_ops using btree;

alter operator family pg_catalog.network_ops using btree add
    function 1(inet, inet) network_cmp(inet,inet),
    function 2(inet, inet) network_sortsupport(internal),
    function 4(inet, inet) btequalimage(oid);

create operator class pg_catalog.cidr_ops for type inet using btree family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.cidr_ops for type inet using hash family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using btree family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops for type inet using gist family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using hash family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using spgist family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator family pg_catalog.network_ops using gist;

alter operator family pg_catalog.network_ops using gist add
    operator 18 =(inet,inet),
    operator 19 <>(inet,inet),
    operator 20 <(inet,inet),
    operator 21 <=(inet,inet),
    operator 22 >(inet,inet),
    operator 23 >=(inet,inet),
    operator 24 <<(inet,inet),
    operator 25 <<=(inet,inet),
    operator 26 >>(inet,inet),
    operator 27 >>=(inet,inet),
    operator 3 &&(inet,inet),
    function 1(inet, inet) inet_gist_consistent(internal,inet,smallint,oid,internal),
    function 2(inet, inet) inet_gist_union(internal,internal),
    function 3(inet, inet) inet_gist_compress(internal),
    function 5(inet, inet) inet_gist_penalty(internal,internal,internal),
    function 6(inet, inet) inet_gist_picksplit(internal,internal),
    function 7(inet, inet) inet_gist_same(inet,inet,internal),
    function 9(inet, inet) inet_gist_fetch(internal);

create operator family pg_catalog.network_ops using hash;

alter operator family pg_catalog.network_ops using hash add
    operator 1 =(inet,inet),
    function 1(inet, inet) hashinet(inet),
    function 2(inet, inet) hashinetextended(inet,bigint);

create operator family pg_catalog.network_ops using spgist;

alter operator family pg_catalog.network_ops using spgist add
    operator 18 =(inet,inet),
    operator 19 <>(inet,inet),
    operator 20 <(inet,inet),
    operator 21 <=(inet,inet),
    operator 22 >(inet,inet),
    operator 23 >=(inet,inet),
    operator 24 <<(inet,inet),
    operator 25 <<=(inet,inet),
    operator 26 >>(inet,inet),
    operator 27 >>=(inet,inet),
    operator 3 &&(inet,inet),
    function 1(inet, inet) inet_spg_config(internal,internal),
    function 2(inet, inet) inet_spg_choose(internal,internal),
    function 3(inet, inet) inet_spg_picksplit(internal,internal),
    function 4(inet, inet) inet_spg_inner_consistent(internal,internal),
    function 5(inet, inet) inet_spg_leaf_consistent(internal,internal);

create operator family pg_catalog.numeric_bloom_ops using brin;

alter operator family pg_catalog.numeric_bloom_ops using brin add
    function 11(numeric, numeric) hash_numeric(numeric),
    function 1(numeric, numeric) brin_bloom_opcinfo(internal),
    function 2(numeric, numeric) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(numeric, numeric) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(numeric, numeric) brin_bloom_union(internal,internal,internal),
    function 5(numeric, numeric) brin_bloom_options(internal);

create operator class pg_catalog.numeric_bloom_ops for type numeric using brin as storage numeric operator 1 =(numeric,numeric);

create operator family pg_catalog.numeric_minmax_multi_ops using brin;

alter operator family pg_catalog.numeric_minmax_multi_ops using brin add
    function 11(numeric, numeric) brin_minmax_multi_distance_numeric(internal,internal),
    function 1(numeric, numeric) brin_minmax_multi_opcinfo(internal),
    function 2(numeric, numeric) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(numeric, numeric) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(numeric, numeric) brin_minmax_multi_union(internal,internal,internal),
    function 5(numeric, numeric) brin_minmax_multi_options(internal);

create operator class pg_catalog.numeric_minmax_multi_ops for type numeric using brin as storage numeric operator 1 <(numeric,numeric),
	operator 2 <=(numeric,numeric),
	operator 3 =(numeric,numeric),
	operator 4 >=(numeric,numeric),
	operator 5 >(numeric,numeric);

create operator family pg_catalog.numeric_minmax_ops using brin;

alter operator family pg_catalog.numeric_minmax_ops using brin add
    function 1(numeric, numeric) brin_minmax_opcinfo(internal),
    function 2(numeric, numeric) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(numeric, numeric) brin_minmax_consistent(internal,internal,internal),
    function 4(numeric, numeric) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.numeric_minmax_ops default for type numeric using brin as storage numeric operator 1 <(numeric,numeric),
	operator 2 <=(numeric,numeric),
	operator 3 =(numeric,numeric),
	operator 4 >=(numeric,numeric),
	operator 5 >(numeric,numeric);

create operator family pg_catalog.numeric_ops using btree;

alter operator family pg_catalog.numeric_ops using btree add
    function 1(numeric, numeric) numeric_cmp(numeric,numeric),
    function 2(numeric, numeric) numeric_sortsupport(internal),
    function 3(numeric, numeric) in_range(numeric,numeric,numeric,boolean,boolean);

create operator class pg_catalog.numeric_ops default for type numeric using btree as
    operator 1 <(numeric,numeric),
    operator 2 <=(numeric,numeric),
    operator 3 =(numeric,numeric),
    operator 4 >=(numeric,numeric),
    operator 5 >(numeric,numeric);

create operator class pg_catalog.numeric_ops default for type numeric using hash as
    operator 1 <(numeric,numeric),
    operator 2 <=(numeric,numeric),
    operator 3 =(numeric,numeric),
    operator 4 >=(numeric,numeric),
    operator 5 >(numeric,numeric);

create operator family pg_catalog.numeric_ops using hash;

alter operator family pg_catalog.numeric_ops using hash add
    operator 1 =(numeric,numeric),
    function 1(numeric, numeric) hash_numeric(numeric),
    function 2(numeric, numeric) hash_numeric_extended(numeric,bigint);

create operator family pg_catalog.oid_bloom_ops using brin;

alter operator family pg_catalog.oid_bloom_ops using brin add
    function 11(oid, oid) hashoid(oid),
    function 1(oid, oid) brin_bloom_opcinfo(internal),
    function 2(oid, oid) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(oid, oid) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(oid, oid) brin_bloom_union(internal,internal,internal),
    function 5(oid, oid) brin_bloom_options(internal);

create operator class pg_catalog.oid_bloom_ops for type oid using brin as storage oid operator 1 =(oid,oid);

create operator family pg_catalog.oid_minmax_multi_ops using brin;

alter operator family pg_catalog.oid_minmax_multi_ops using brin add
    function 11(oid, oid) brin_minmax_multi_distance_int4(internal,internal),
    function 1(oid, oid) brin_minmax_multi_opcinfo(internal),
    function 2(oid, oid) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(oid, oid) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(oid, oid) brin_minmax_multi_union(internal,internal,internal),
    function 5(oid, oid) brin_minmax_multi_options(internal);

create operator class pg_catalog.oid_minmax_multi_ops for type oid using brin as storage oid operator 1 <(oid,oid),
	operator 2 <=(oid,oid),
	operator 3 =(oid,oid),
	operator 4 >=(oid,oid),
	operator 5 >(oid,oid);

create operator family pg_catalog.oid_minmax_ops using brin;

alter operator family pg_catalog.oid_minmax_ops using brin add
    function 1(oid, oid) brin_minmax_opcinfo(internal),
    function 2(oid, oid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(oid, oid) brin_minmax_consistent(internal,internal,internal),
    function 4(oid, oid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.oid_minmax_ops default for type oid using brin as storage oid operator 1 <(oid,oid),
	operator 2 <=(oid,oid),
	operator 3 =(oid,oid),
	operator 4 >=(oid,oid),
	operator 5 >(oid,oid);

create operator family pg_catalog.oid_ops using btree;

alter operator family pg_catalog.oid_ops using btree add
    function 1(oid, oid) btoidcmp(oid,oid),
    function 2(oid, oid) btoidsortsupport(internal),
    function 4(oid, oid) btequalimage(oid);

create operator class pg_catalog.oid_ops default for type oid using btree as
    operator 1 <(oid,oid),
    operator 2 <=(oid,oid),
    operator 3 =(oid,oid),
    operator 4 >=(oid,oid),
    operator 5 >(oid,oid);

create operator class pg_catalog.oid_ops default for type oid using hash as
    operator 1 <(oid,oid),
    operator 2 <=(oid,oid),
    operator 3 =(oid,oid),
    operator 4 >=(oid,oid),
    operator 5 >(oid,oid);

create operator family pg_catalog.oid_ops using hash;

alter operator family pg_catalog.oid_ops using hash add
    operator 1 =(oid,oid),
    function 1(oid, oid) hashoid(oid),
    function 2(oid, oid) hashoidextended(oid,bigint);

create operator family pg_catalog.oidvector_ops using btree;

alter operator family pg_catalog.oidvector_ops using btree add
    function 1(oidvector, oidvector) btoidvectorcmp(oidvector,oidvector),
    function 4(oidvector, oidvector) btequalimage(oid);

create operator class pg_catalog.oidvector_ops default for type oidvector using btree as
    operator 1 <(oidvector,oidvector),
    operator 2 <=(oidvector,oidvector),
    operator 3 =(oidvector,oidvector),
    operator 4 >=(oidvector,oidvector),
    operator 5 >(oidvector,oidvector);

create operator class pg_catalog.oidvector_ops default for type oidvector using hash as
    operator 1 <(oidvector,oidvector),
    operator 2 <=(oidvector,oidvector),
    operator 3 =(oidvector,oidvector),
    operator 4 >=(oidvector,oidvector),
    operator 5 >(oidvector,oidvector);

create operator family pg_catalog.oidvector_ops using hash;

alter operator family pg_catalog.oidvector_ops using hash add
    operator 1 =(oidvector,oidvector),
    function 1(oidvector, oidvector) hashoidvector(oidvector),
    function 2(oidvector, oidvector) hashoidvectorextended(oidvector,bigint);

create operator family pg_catalog.pg_lsn_bloom_ops using brin;

alter operator family pg_catalog.pg_lsn_bloom_ops using brin add
    function 11(pg_lsn, pg_lsn) pg_lsn_hash(pg_lsn),
    function 1(pg_lsn, pg_lsn) brin_bloom_opcinfo(internal),
    function 2(pg_lsn, pg_lsn) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(pg_lsn, pg_lsn) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(pg_lsn, pg_lsn) brin_bloom_union(internal,internal,internal),
    function 5(pg_lsn, pg_lsn) brin_bloom_options(internal);

create operator class pg_catalog.pg_lsn_bloom_ops for type pg_lsn using brin as storage pg_lsn operator 1 =(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_minmax_multi_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_multi_ops using brin add
    function 11(pg_lsn, pg_lsn) brin_minmax_multi_distance_pg_lsn(internal,internal),
    function 1(pg_lsn, pg_lsn) brin_minmax_multi_opcinfo(internal),
    function 2(pg_lsn, pg_lsn) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(pg_lsn, pg_lsn) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(pg_lsn, pg_lsn) brin_minmax_multi_union(internal,internal,internal),
    function 5(pg_lsn, pg_lsn) brin_minmax_multi_options(internal);

create operator class pg_catalog.pg_lsn_minmax_multi_ops for type pg_lsn using brin as storage pg_lsn operator 1 <(pg_lsn,pg_lsn),
	operator 2 <=(pg_lsn,pg_lsn),
	operator 3 =(pg_lsn,pg_lsn),
	operator 4 >=(pg_lsn,pg_lsn),
	operator 5 >(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_minmax_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_ops using brin add
    function 1(pg_lsn, pg_lsn) brin_minmax_opcinfo(internal),
    function 2(pg_lsn, pg_lsn) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(pg_lsn, pg_lsn) brin_minmax_consistent(internal,internal,internal),
    function 4(pg_lsn, pg_lsn) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.pg_lsn_minmax_ops default for type pg_lsn using brin as storage pg_lsn operator 1 <(pg_lsn,pg_lsn),
	operator 2 <=(pg_lsn,pg_lsn),
	operator 3 =(pg_lsn,pg_lsn),
	operator 4 >=(pg_lsn,pg_lsn),
	operator 5 >(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_ops using btree;

alter operator family pg_catalog.pg_lsn_ops using btree add
    function 1(pg_lsn, pg_lsn) pg_lsn_cmp(pg_lsn,pg_lsn),
    function 4(pg_lsn, pg_lsn) btequalimage(oid);

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using btree as
    operator 1 <(pg_lsn,pg_lsn),
    operator 2 <=(pg_lsn,pg_lsn),
    operator 3 =(pg_lsn,pg_lsn),
    operator 4 >=(pg_lsn,pg_lsn),
    operator 5 >(pg_lsn,pg_lsn);

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using hash as
    operator 1 <(pg_lsn,pg_lsn),
    operator 2 <=(pg_lsn,pg_lsn),
    operator 3 =(pg_lsn,pg_lsn),
    operator 4 >=(pg_lsn,pg_lsn),
    operator 5 >(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_ops using hash;

alter operator family pg_catalog.pg_lsn_ops using hash add
    operator 1 =(pg_lsn,pg_lsn),
    function 1(pg_lsn, pg_lsn) pg_lsn_hash(pg_lsn),
    function 2(pg_lsn, pg_lsn) pg_lsn_hash_extended(pg_lsn,bigint);

create operator family pg_catalog.point_ops using gist;

alter operator family pg_catalog.point_ops using gist add
    function 11(point, point) gist_point_sortsupport(internal),
    function 1(point, point) gist_point_consistent(internal,point,smallint,oid,internal),
    function 2(point, point) gist_box_union(internal,internal),
    function 3(point, point) gist_point_compress(internal),
    function 5(point, point) gist_box_penalty(internal,internal,internal),
    function 6(point, point) gist_box_picksplit(internal,internal),
    function 7(point, point) gist_box_same(box,box,internal),
    function 8(point, point) gist_point_distance(internal,point,smallint,oid,internal),
    function 9(point, point) gist_point_fetch(internal);

create operator class pg_catalog.point_ops default for type point using gist as storage box operator 10 <<|(point,point),
	operator 11 |>>(point,point),
	operator 15 <->(point,point),
	operator 1 <<(point,point),
	operator 28 <@(point,box),
	operator 29 <^(point,point),
	operator 30 >^(point,point),
	operator 48 <@(point,polygon),
	operator 5 >>(point,point),
	operator 68 <@(point,circle),
	operator 6 ~=(point,point);

create operator family pg_catalog.poly_ops using gist;

alter operator family pg_catalog.poly_ops using gist add
    function 1(polygon, polygon) gist_poly_consistent(internal,polygon,smallint,oid,internal),
    function 2(polygon, polygon) gist_box_union(internal,internal),
    function 3(polygon, polygon) gist_poly_compress(internal),
    function 5(polygon, polygon) gist_box_penalty(internal,internal,internal),
    function 6(polygon, polygon) gist_box_picksplit(internal,internal),
    function 7(polygon, polygon) gist_box_same(box,box,internal),
    function 8(polygon, polygon) gist_poly_distance(internal,polygon,smallint,oid,internal);

create operator class pg_catalog.poly_ops default for type polygon using gist as storage box operator 10 <<|(polygon,polygon),
	operator 11 |>>(polygon,polygon),
	operator 12 |&>(polygon,polygon),
	operator 15 <->(polygon,point),
	operator 1 <<(polygon,polygon),
	operator 2 &<(polygon,polygon),
	operator 3 &&(polygon,polygon),
	operator 4 &>(polygon,polygon),
	operator 5 >>(polygon,polygon),
	operator 6 ~=(polygon,polygon),
	operator 7 @>(polygon,polygon),
	operator 8 <@(polygon,polygon),
	operator 9 &<|(polygon,polygon);

create operator class pg_catalog.poly_ops default for type polygon using spgist as storage box operator 10 <<|(polygon,polygon),
	operator 11 |>>(polygon,polygon),
	operator 12 |&>(polygon,polygon),
	operator 15 <->(polygon,point),
	operator 1 <<(polygon,polygon),
	operator 2 &<(polygon,polygon),
	operator 3 &&(polygon,polygon),
	operator 4 &>(polygon,polygon),
	operator 5 >>(polygon,polygon),
	operator 6 ~=(polygon,polygon),
	operator 7 @>(polygon,polygon),
	operator 8 <@(polygon,polygon),
	operator 9 &<|(polygon,polygon);

create operator family pg_catalog.poly_ops using spgist;

alter operator family pg_catalog.poly_ops using spgist add
    operator 10 <<|(polygon,polygon),
    operator 11 |>>(polygon,polygon),
    operator 12 |&>(polygon,polygon),
    operator 15 <->(polygon,point),
    operator 1 <<(polygon,polygon),
    operator 2 &<(polygon,polygon),
    operator 3 &&(polygon,polygon),
    operator 4 &>(polygon,polygon),
    operator 5 >>(polygon,polygon),
    operator 6 ~=(polygon,polygon),
    operator 7 @>(polygon,polygon),
    operator 8 <@(polygon,polygon),
    operator 9 &<|(polygon,polygon),
    function 1(polygon, polygon) spg_bbox_quad_config(internal,internal),
    function 2(polygon, polygon) spg_box_quad_choose(internal,internal),
    function 3(polygon, polygon) spg_box_quad_picksplit(internal,internal),
    function 4(polygon, polygon) spg_box_quad_inner_consistent(internal,internal),
    function 5(polygon, polygon) spg_box_quad_leaf_consistent(internal,internal),
    function 6(polygon, polygon) spg_poly_quad_compress(polygon);

create operator family pg_catalog.quad_point_ops using spgist;

alter operator family pg_catalog.quad_point_ops using spgist add
    function 1(point, point) spg_quad_config(internal,internal),
    function 2(point, point) spg_quad_choose(internal,internal),
    function 3(point, point) spg_quad_picksplit(internal,internal),
    function 4(point, point) spg_quad_inner_consistent(internal,internal),
    function 5(point, point) spg_quad_leaf_consistent(internal,internal);

create operator class pg_catalog.quad_point_ops default for type point using spgist as
    operator 10 <<|(point,point),
    operator 11 |>>(point,point),
    operator 15 <->(point,point),
    operator 1 <<(point,point),
    operator 29 <^(point,point),
    operator 30 >^(point,point),
    operator 5 >>(point,point),
    operator 6 ~=(point,point),
    operator 8 <@(point,box);

create operator family pg_catalog.range_inclusion_ops using brin;

alter operator family pg_catalog.range_inclusion_ops using brin add
    function 11(anyrange, anyrange) range_merge(anyrange,anyrange),
    function 13(anyrange, anyrange) range_contains(anyrange,anyrange),
    function 14(anyrange, anyrange) isempty(anyrange),
    function 1(anyrange, anyrange) brin_inclusion_opcinfo(internal),
    function 2(anyrange, anyrange) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(anyrange, anyrange) brin_inclusion_consistent(internal,internal,internal),
    function 4(anyrange, anyrange) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.range_inclusion_ops default for type anyrange using brin as storage anyrange operator 16 @>(anyrange,anyelement),
	operator 17 -|-(anyrange,anyrange),
	operator 18 =(anyrange,anyrange),
	operator 1 <<(anyrange,anyrange),
	operator 20 <(anyrange,anyrange),
	operator 21 <=(anyrange,anyrange),
	operator 22 >(anyrange,anyrange),
	operator 23 >=(anyrange,anyrange),
	operator 2 &<(anyrange,anyrange),
	operator 3 &&(anyrange,anyrange),
	operator 4 &>(anyrange,anyrange),
	operator 5 >>(anyrange,anyrange),
	operator 7 @>(anyrange,anyrange),
	operator 8 <@(anyrange,anyrange);

create operator family pg_catalog.range_ops using btree;

alter operator family pg_catalog.range_ops using btree add
    function 1(anyrange, anyrange) range_cmp(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using btree as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using gist as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using hash as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using spgist as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator family pg_catalog.range_ops using gist;

alter operator family pg_catalog.range_ops using gist add
    operator 16 @>(anyrange,anyelement),
    operator 18 =(anyrange,anyrange),
    operator 1 <<(anyrange,anymultirange),
    operator 1 <<(anyrange,anyrange),
    operator 2 &<(anyrange,anymultirange),
    operator 2 &<(anyrange,anyrange),
    operator 3 &&(anyrange,anymultirange),
    operator 3 &&(anyrange,anyrange),
    operator 4 &>(anyrange,anymultirange),
    operator 4 &>(anyrange,anyrange),
    operator 5 >>(anyrange,anymultirange),
    operator 5 >>(anyrange,anyrange),
    operator 6 -|-(anyrange,anymultirange),
    operator 6 -|-(anyrange,anyrange),
    operator 7 @>(anyrange,anymultirange),
    operator 7 @>(anyrange,anyrange),
    operator 8 <@(anyrange,anymultirange),
    operator 8 <@(anyrange,anyrange),
    function 1(anyrange, anyrange) range_gist_consistent(internal,anyrange,smallint,oid,internal),
    function 2(anyrange, anyrange) range_gist_union(internal,internal),
    function 5(anyrange, anyrange) range_gist_penalty(internal,internal,internal),
    function 6(anyrange, anyrange) range_gist_picksplit(internal,internal),
    function 7(anyrange, anyrange) range_gist_same(anyrange,anyrange,internal);

create operator family pg_catalog.range_ops using hash;

alter operator family pg_catalog.range_ops using hash add
    operator 1 =(anyrange,anyrange),
    function 1(anyrange, anyrange) hash_range(anyrange),
    function 2(anyrange, anyrange) hash_range_extended(anyrange,bigint);

create operator family pg_catalog.range_ops using spgist;

alter operator family pg_catalog.range_ops using spgist add
    operator 16 @>(anyrange,anyelement),
    operator 18 =(anyrange,anyrange),
    operator 1 <<(anyrange,anyrange),
    operator 2 &<(anyrange,anyrange),
    operator 3 &&(anyrange,anyrange),
    operator 4 &>(anyrange,anyrange),
    operator 5 >>(anyrange,anyrange),
    operator 6 -|-(anyrange,anyrange),
    operator 7 @>(anyrange,anyrange),
    operator 8 <@(anyrange,anyrange),
    function 1(anyrange, anyrange) spg_range_quad_config(internal,internal),
    function 2(anyrange, anyrange) spg_range_quad_choose(internal,internal),
    function 3(anyrange, anyrange) spg_range_quad_picksplit(internal,internal),
    function 4(anyrange, anyrange) spg_range_quad_inner_consistent(internal,internal),
    function 5(anyrange, anyrange) spg_range_quad_leaf_consistent(internal,internal);

create operator family pg_catalog.record_image_ops using btree;

alter operator family pg_catalog.record_image_ops using btree add
    function 1(record, record) btrecordimagecmp(record,record);

create operator class pg_catalog.record_image_ops for type record using btree as
    operator 1 *<(record,record),
    operator 2 *<=(record,record),
    operator 3 *=(record,record),
    operator 4 *>=(record,record),
    operator 5 *>(record,record);

create operator family pg_catalog.record_ops using btree;

alter operator family pg_catalog.record_ops using btree add
    function 1(record, record) btrecordcmp(record,record);

create operator class pg_catalog.record_ops default for type record using btree as
    operator 1 <(record,record),
    operator 2 <=(record,record),
    operator 3 =(record,record),
    operator 4 >=(record,record),
    operator 5 >(record,record);

create operator class pg_catalog.record_ops default for type record using hash as
    operator 1 <(record,record),
    operator 2 <=(record,record),
    operator 3 =(record,record),
    operator 4 >=(record,record),
    operator 5 >(record,record);

create operator family pg_catalog.record_ops using hash;

alter operator family pg_catalog.record_ops using hash add
    operator 1 =(record,record),
    function 1(record, record) hash_record(record),
    function 2(record, record) hash_record_extended(record,bigint);

create operator family pg_catalog.text_bloom_ops using brin;

alter operator family pg_catalog.text_bloom_ops using brin add
    function 11(text, text) hashtext(text),
    function 1(text, text) brin_bloom_opcinfo(internal),
    function 2(text, text) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(text, text) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(text, text) brin_bloom_union(internal,internal,internal),
    function 5(text, text) brin_bloom_options(internal);

create operator class pg_catalog.text_bloom_ops for type text using brin as storage text operator 1 =(text,text);

create operator family pg_catalog.text_minmax_ops using brin;

alter operator family pg_catalog.text_minmax_ops using brin add
    function 1(text, text) brin_minmax_opcinfo(internal),
    function 2(text, text) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(text, text) brin_minmax_consistent(internal,internal,internal),
    function 4(text, text) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.text_minmax_ops default for type text using brin as storage text operator 1 <(text,text),
	operator 2 <=(text,text),
	operator 3 =(text,text),
	operator 4 >=(text,text),
	operator 5 >(text,text);

create operator family pg_catalog.text_ops using btree;

alter operator family pg_catalog.text_ops using btree add
    function 1(name, name) btnamecmp(name,name),
    function 1(name, text) btnametextcmp(name,text),
    function 1(text, name) bttextnamecmp(text,name),
    function 1(text, text) bttextcmp(text,text),
    function 2(name, name) btnamesortsupport(internal),
    function 2(text, text) bttextsortsupport(internal),
    function 4(name, name) btvarstrequalimage(oid),
    function 4(text, text) btvarstrequalimage(oid);

create operator class pg_catalog.name_ops default for type name using btree family pg_catalog.text_ops as storage cstring operator 1 <(name,name),
	operator 1 <(name,text),
	operator 1 <(text,name),
	operator 1 <(text,text),
	operator 2 <=(name,name),
	operator 2 <=(name,text),
	operator 2 <=(text,name),
	operator 2 <=(text,text),
	operator 3 =(name,name),
	operator 3 =(name,text),
	operator 3 =(text,name),
	operator 3 =(text,text),
	operator 4 >=(name,name),
	operator 4 >=(name,text),
	operator 4 >=(text,name),
	operator 4 >=(text,text),
	operator 5 >(name,name),
	operator 5 >(name,text),
	operator 5 >(text,name),
	operator 5 >(text,text);

create operator class pg_catalog.name_ops default for type name using hash family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using btree as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using hash as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using spgist as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.varchar_ops for type text using btree family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.varchar_ops for type text using hash family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator family pg_catalog.text_ops using hash;

alter operator family pg_catalog.text_ops using hash add
    operator 1 =(name,name),
    operator 1 =(name,text),
    operator 1 =(text,name),
    operator 1 =(text,text),
    function 1(name, name) hashname(name),
    function 1(text, text) hashtext(text),
    function 2(name, name) hashnameextended(name,bigint),
    function 2(text, text) hashtextextended(text,bigint);

create operator family pg_catalog.text_ops using spgist;

alter operator family pg_catalog.text_ops using spgist add
    operator 11 <(text,text),
    operator 12 <=(text,text),
    operator 14 >=(text,text),
    operator 15 >(text,text),
    operator 1 ~<~(text,text),
    operator 28 ^@(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text),
    function 1(text, text) spg_text_config(internal,internal),
    function 2(text, text) spg_text_choose(internal,internal),
    function 3(text, text) spg_text_picksplit(internal,internal),
    function 4(text, text) spg_text_inner_consistent(internal,internal),
    function 5(text, text) spg_text_leaf_consistent(internal,internal);

create operator family pg_catalog.text_pattern_ops using btree;

alter operator family pg_catalog.text_pattern_ops using btree add
    function 1(text, text) bttext_pattern_cmp(text,text),
    function 2(text, text) bttext_pattern_sortsupport(internal),
    function 4(text, text) btequalimage(oid);

create operator class pg_catalog.text_pattern_ops for type text using btree as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.text_pattern_ops for type text using hash as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.varchar_pattern_ops for type text using btree family pg_catalog.text_pattern_ops as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.varchar_pattern_ops for type text using hash family pg_catalog.text_pattern_ops as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator family pg_catalog.text_pattern_ops using hash;

alter operator family pg_catalog.text_pattern_ops using hash add
    operator 1 =(text,text),
    function 1(text, text) hashtext(text),
    function 2(text, text) hashtextextended(text,bigint);

create operator family pg_catalog.tid_bloom_ops using brin;

alter operator family pg_catalog.tid_bloom_ops using brin add
    function 11(tid, tid) hashtid(tid),
    function 1(tid, tid) brin_bloom_opcinfo(internal),
    function 2(tid, tid) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(tid, tid) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(tid, tid) brin_bloom_union(internal,internal,internal),
    function 5(tid, tid) brin_bloom_options(internal);

create operator class pg_catalog.tid_bloom_ops for type tid using brin as storage tid operator 1 =(tid,tid);

create operator family pg_catalog.tid_minmax_multi_ops using brin;

alter operator family pg_catalog.tid_minmax_multi_ops using brin add
    function 11(tid, tid) brin_minmax_multi_distance_tid(internal,internal),
    function 1(tid, tid) brin_minmax_multi_opcinfo(internal),
    function 2(tid, tid) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(tid, tid) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(tid, tid) brin_minmax_multi_union(internal,internal,internal),
    function 5(tid, tid) brin_minmax_multi_options(internal);

create operator class pg_catalog.tid_minmax_multi_ops for type tid using brin as storage tid operator 1 <(tid,tid),
	operator 2 <=(tid,tid),
	operator 3 =(tid,tid),
	operator 4 >=(tid,tid),
	operator 5 >(tid,tid);

create operator family pg_catalog.tid_minmax_ops using brin;

alter operator family pg_catalog.tid_minmax_ops using brin add
    function 1(tid, tid) brin_minmax_opcinfo(internal),
    function 2(tid, tid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(tid, tid) brin_minmax_consistent(internal,internal,internal),
    function 4(tid, tid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.tid_minmax_ops default for type tid using brin as storage tid operator 1 <(tid,tid),
	operator 2 <=(tid,tid),
	operator 3 =(tid,tid),
	operator 4 >=(tid,tid),
	operator 5 >(tid,tid);

create operator family pg_catalog.tid_ops using btree;

alter operator family pg_catalog.tid_ops using btree add
    function 1(tid, tid) bttidcmp(tid,tid),
    function 4(tid, tid) btequalimage(oid);

create operator class pg_catalog.tid_ops default for type tid using btree as
    operator 1 <(tid,tid),
    operator 2 <=(tid,tid),
    operator 3 =(tid,tid),
    operator 4 >=(tid,tid),
    operator 5 >(tid,tid);

create operator class pg_catalog.tid_ops default for type tid using hash as
    operator 1 <(tid,tid),
    operator 2 <=(tid,tid),
    operator 3 =(tid,tid),
    operator 4 >=(tid,tid),
    operator 5 >(tid,tid);

create operator family pg_catalog.tid_ops using hash;

alter operator family pg_catalog.tid_ops using hash add
    operator 1 =(tid,tid),
    function 1(tid, tid) hashtid(tid),
    function 2(tid, tid) hashtidextended(tid,bigint);

create operator family pg_catalog.time_bloom_ops using brin;

alter operator family pg_catalog.time_bloom_ops using brin add
    function 11(time without time zone, time without time zone) time_hash(time without time zone),
    function 1(time without time zone, time without time zone) brin_bloom_opcinfo(internal),
    function 2(time without time zone, time without time zone) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(time without time zone, time without time zone) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(time without time zone, time without time zone) brin_bloom_union(internal,internal,internal),
    function 5(time without time zone, time without time zone) brin_bloom_options(internal);

create operator class pg_catalog.time_bloom_ops for type time without time zone using brin as storage time without time zone operator 1 =(time without time zone,time without time zone);

create operator family pg_catalog.time_minmax_multi_ops using brin;

alter operator family pg_catalog.time_minmax_multi_ops using brin add
    function 11(time without time zone, time without time zone) brin_minmax_multi_distance_time(internal,internal),
    function 1(time without time zone, time without time zone) brin_minmax_multi_opcinfo(internal),
    function 2(time without time zone, time without time zone) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(time without time zone, time without time zone) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(time without time zone, time without time zone) brin_minmax_multi_union(internal,internal,internal),
    function 5(time without time zone, time without time zone) brin_minmax_multi_options(internal);

create operator class pg_catalog.time_minmax_multi_ops for type time without time zone using brin as storage time without time zone operator 1 <(time without time zone,time without time zone),
	operator 2 <=(time without time zone,time without time zone),
	operator 3 =(time without time zone,time without time zone),
	operator 4 >=(time without time zone,time without time zone),
	operator 5 >(time without time zone,time without time zone);

create operator family pg_catalog.time_minmax_ops using brin;

alter operator family pg_catalog.time_minmax_ops using brin add
    function 1(time without time zone, time without time zone) brin_minmax_opcinfo(internal),
    function 2(time without time zone, time without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(time without time zone, time without time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(time without time zone, time without time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.time_minmax_ops default for type time without time zone using brin as storage time without time zone operator 1 <(time without time zone,time without time zone),
	operator 2 <=(time without time zone,time without time zone),
	operator 3 =(time without time zone,time without time zone),
	operator 4 >=(time without time zone,time without time zone),
	operator 5 >(time without time zone,time without time zone);

create operator family pg_catalog.time_ops using btree;

alter operator family pg_catalog.time_ops using btree add
    function 1(time without time zone, time without time zone) time_cmp(time without time zone,time without time zone),
    function 3(time without time zone, interval) in_range(time without time zone,time without time zone,interval,boolean,boolean),
    function 4(time without time zone, time without time zone) btequalimage(oid);

create operator class pg_catalog.time_ops default for type time without time zone using btree as
    operator 1 <(time without time zone,time without time zone),
    operator 2 <=(time without time zone,time without time zone),
    operator 3 =(time without time zone,time without time zone),
    operator 4 >=(time without time zone,time without time zone),
    operator 5 >(time without time zone,time without time zone);

create operator class pg_catalog.time_ops default for type time without time zone using hash as
    operator 1 <(time without time zone,time without time zone),
    operator 2 <=(time without time zone,time without time zone),
    operator 3 =(time without time zone,time without time zone),
    operator 4 >=(time without time zone,time without time zone),
    operator 5 >(time without time zone,time without time zone);

create operator family pg_catalog.time_ops using hash;

alter operator family pg_catalog.time_ops using hash add
    operator 1 =(time without time zone,time without time zone),
    function 1(time without time zone, time without time zone) time_hash(time without time zone),
    function 2(time without time zone, time without time zone) time_hash_extended(time without time zone,bigint);

create operator family pg_catalog.timestamp_ops using hash;

alter operator family pg_catalog.timestamp_ops using hash add
    function 1(timestamp without time zone, timestamp without time zone) timestamp_hash(timestamp without time zone),
    function 2(timestamp without time zone, timestamp without time zone) timestamp_hash_extended(timestamp without time zone,bigint);

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using hash as
    operator 1 =(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.timestamptz_ops using hash;

alter operator family pg_catalog.timestamptz_ops using hash add
    function 1(timestamp with time zone, timestamp with time zone) timestamp_hash(timestamp without time zone),
    function 2(timestamp with time zone, timestamp with time zone) timestamp_hash_extended(timestamp without time zone,bigint);

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using hash as
    operator 1 =(timestamp with time zone,timestamp with time zone);

create operator family pg_catalog.timetz_bloom_ops using brin;

alter operator family pg_catalog.timetz_bloom_ops using brin add
    function 11(time with time zone, time with time zone) timetz_hash(time with time zone),
    function 1(time with time zone, time with time zone) brin_bloom_opcinfo(internal),
    function 2(time with time zone, time with time zone) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(time with time zone, time with time zone) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(time with time zone, time with time zone) brin_bloom_union(internal,internal,internal),
    function 5(time with time zone, time with time zone) brin_bloom_options(internal);

create operator class pg_catalog.timetz_bloom_ops for type time with time zone using brin as storage time with time zone operator 1 =(time with time zone,time with time zone);

create operator family pg_catalog.timetz_minmax_multi_ops using brin;

alter operator family pg_catalog.timetz_minmax_multi_ops using brin add
    function 11(time with time zone, time with time zone) brin_minmax_multi_distance_timetz(internal,internal),
    function 1(time with time zone, time with time zone) brin_minmax_multi_opcinfo(internal),
    function 2(time with time zone, time with time zone) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(time with time zone, time with time zone) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(time with time zone, time with time zone) brin_minmax_multi_union(internal,internal,internal),
    function 5(time with time zone, time with time zone) brin_minmax_multi_options(internal);

create operator class pg_catalog.timetz_minmax_multi_ops for type time with time zone using brin as storage time with time zone operator 1 <(time with time zone,time with time zone),
	operator 2 <=(time with time zone,time with time zone),
	operator 3 =(time with time zone,time with time zone),
	operator 4 >=(time with time zone,time with time zone),
	operator 5 >(time with time zone,time with time zone);

create operator family pg_catalog.timetz_minmax_ops using brin;

alter operator family pg_catalog.timetz_minmax_ops using brin add
    function 1(time with time zone, time with time zone) brin_minmax_opcinfo(internal),
    function 2(time with time zone, time with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(time with time zone, time with time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(time with time zone, time with time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.timetz_minmax_ops default for type time with time zone using brin as storage time with time zone operator 1 <(time with time zone,time with time zone),
	operator 2 <=(time with time zone,time with time zone),
	operator 3 =(time with time zone,time with time zone),
	operator 4 >=(time with time zone,time with time zone),
	operator 5 >(time with time zone,time with time zone);

create operator family pg_catalog.timetz_ops using btree;

alter operator family pg_catalog.timetz_ops using btree add
    function 1(time with time zone, time with time zone) timetz_cmp(time with time zone,time with time zone),
    function 3(time with time zone, interval) in_range(time with time zone,time with time zone,interval,boolean,boolean),
    function 4(time with time zone, time with time zone) btequalimage(oid);

create operator class pg_catalog.timetz_ops default for type time with time zone using btree as
    operator 1 <(time with time zone,time with time zone),
    operator 2 <=(time with time zone,time with time zone),
    operator 3 =(time with time zone,time with time zone),
    operator 4 >=(time with time zone,time with time zone),
    operator 5 >(time with time zone,time with time zone);

create operator class pg_catalog.timetz_ops default for type time with time zone using hash as
    operator 1 <(time with time zone,time with time zone),
    operator 2 <=(time with time zone,time with time zone),
    operator 3 =(time with time zone,time with time zone),
    operator 4 >=(time with time zone,time with time zone),
    operator 5 >(time with time zone,time with time zone);

create operator family pg_catalog.timetz_ops using hash;

alter operator family pg_catalog.timetz_ops using hash add
    operator 1 =(time with time zone,time with time zone),
    function 1(time with time zone, time with time zone) timetz_hash(time with time zone),
    function 2(time with time zone, time with time zone) timetz_hash_extended(time with time zone,bigint);

create operator family pg_catalog.tsquery_ops using btree;

alter operator family pg_catalog.tsquery_ops using btree add
    function 1(tsquery, tsquery) tsquery_cmp(tsquery,tsquery);

create operator class pg_catalog.tsquery_ops default for type tsquery using btree as
    operator 1 <(tsquery,tsquery),
    operator 2 <=(tsquery,tsquery),
    operator 3 =(tsquery,tsquery),
    operator 4 >=(tsquery,tsquery),
    operator 5 >(tsquery,tsquery);

create operator class pg_catalog.tsquery_ops default for type tsquery using gist as storage bigint operator 1 <(tsquery,tsquery),
	operator 2 <=(tsquery,tsquery),
	operator 3 =(tsquery,tsquery),
	operator 4 >=(tsquery,tsquery),
	operator 5 >(tsquery,tsquery);

create operator family pg_catalog.tsquery_ops using gist;

alter operator family pg_catalog.tsquery_ops using gist add
    operator 7 @>(tsquery,tsquery),
    operator 8 <@(tsquery,tsquery),
    function 1(tsquery, tsquery) gtsquery_consistent(internal,tsquery,smallint,oid,internal),
    function 2(tsquery, tsquery) gtsquery_union(internal,internal),
    function 3(tsquery, tsquery) gtsquery_compress(internal),
    function 5(tsquery, tsquery) gtsquery_penalty(internal,internal,internal),
    function 6(tsquery, tsquery) gtsquery_picksplit(internal,internal),
    function 7(tsquery, tsquery) gtsquery_same(bigint,bigint,internal);

create operator family pg_catalog.tsvector_ops using btree;

alter operator family pg_catalog.tsvector_ops using btree add
    function 1(tsvector, tsvector) tsvector_cmp(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using btree as
    operator 1 <(tsvector,tsvector),
    operator 2 <=(tsvector,tsvector),
    operator 3 =(tsvector,tsvector),
    operator 4 >=(tsvector,tsvector),
    operator 5 >(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using gin as storage text operator 1 <(tsvector,tsvector),
	operator 2 <=(tsvector,tsvector),
	operator 3 =(tsvector,tsvector),
	operator 4 >=(tsvector,tsvector),
	operator 5 >(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using gist as storage gtsvector operator 1 <(tsvector,tsvector),
	operator 2 <=(tsvector,tsvector),
	operator 3 =(tsvector,tsvector),
	operator 4 >=(tsvector,tsvector),
	operator 5 >(tsvector,tsvector);

create operator family pg_catalog.tsvector_ops using gin;

alter operator family pg_catalog.tsvector_ops using gin add
    operator 1 @@(tsvector,tsquery),
    operator 2 @@@(tsvector,tsquery),
    function 1(tsvector, tsvector) gin_cmp_tslexeme(text,text),
    function 2(tsvector, tsvector) gin_extract_tsvector(tsvector,internal,internal),
    function 3(tsvector, tsvector) gin_extract_tsquery(tsvector,internal,smallint,internal,internal,internal,internal),
    function 4(tsvector, tsvector) gin_tsquery_consistent(internal,smallint,tsvector,integer,internal,internal,internal,internal),
    function 5(tsvector, tsvector) gin_cmp_prefix(text,text,smallint,internal),
    function 6(tsvector, tsvector) gin_tsquery_triconsistent(internal,smallint,tsvector,integer,internal,internal,internal);

create operator family pg_catalog.tsvector_ops using gist;

alter operator family pg_catalog.tsvector_ops using gist add
    operator 1 @@(tsvector,tsquery),
    function 10(tsvector, tsvector) gtsvector_options(internal),
    function 1(tsvector, tsvector) gtsvector_consistent(internal,tsvector,smallint,oid,internal),
    function 2(tsvector, tsvector) gtsvector_union(internal,internal),
    function 3(tsvector, tsvector) gtsvector_compress(internal),
    function 4(tsvector, tsvector) gtsvector_decompress(internal),
    function 5(tsvector, tsvector) gtsvector_penalty(internal,internal,internal),
    function 6(tsvector, tsvector) gtsvector_picksplit(internal,internal),
    function 7(tsvector, tsvector) gtsvector_same(gtsvector,gtsvector,internal);

create operator family pg_catalog.uuid_bloom_ops using brin;

alter operator family pg_catalog.uuid_bloom_ops using brin add
    function 11(uuid, uuid) uuid_hash(uuid),
    function 1(uuid, uuid) brin_bloom_opcinfo(internal),
    function 2(uuid, uuid) brin_bloom_add_value(internal,internal,internal,internal),
    function 3(uuid, uuid) brin_bloom_consistent(internal,internal,internal,integer),
    function 4(uuid, uuid) brin_bloom_union(internal,internal,internal),
    function 5(uuid, uuid) brin_bloom_options(internal);

create operator class pg_catalog.uuid_bloom_ops for type uuid using brin as storage uuid operator 1 =(uuid,uuid);

create operator family pg_catalog.uuid_minmax_multi_ops using brin;

alter operator family pg_catalog.uuid_minmax_multi_ops using brin add
    function 11(uuid, uuid) brin_minmax_multi_distance_uuid(internal,internal),
    function 1(uuid, uuid) brin_minmax_multi_opcinfo(internal),
    function 2(uuid, uuid) brin_minmax_multi_add_value(internal,internal,internal,internal),
    function 3(uuid, uuid) brin_minmax_multi_consistent(internal,internal,internal,integer),
    function 4(uuid, uuid) brin_minmax_multi_union(internal,internal,internal),
    function 5(uuid, uuid) brin_minmax_multi_options(internal);

create operator class pg_catalog.uuid_minmax_multi_ops for type uuid using brin as storage uuid operator 1 <(uuid,uuid),
	operator 2 <=(uuid,uuid),
	operator 3 =(uuid,uuid),
	operator 4 >=(uuid,uuid),
	operator 5 >(uuid,uuid);

create operator family pg_catalog.uuid_minmax_ops using brin;

alter operator family pg_catalog.uuid_minmax_ops using brin add
    function 1(uuid, uuid) brin_minmax_opcinfo(internal),
    function 2(uuid, uuid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(uuid, uuid) brin_minmax_consistent(internal,internal,internal),
    function 4(uuid, uuid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.uuid_minmax_ops default for type uuid using brin as storage uuid operator 1 <(uuid,uuid),
	operator 2 <=(uuid,uuid),
	operator 3 =(uuid,uuid),
	operator 4 >=(uuid,uuid),
	operator 5 >(uuid,uuid);

create operator family pg_catalog.uuid_ops using btree;

alter operator family pg_catalog.uuid_ops using btree add
    function 1(uuid, uuid) uuid_cmp(uuid,uuid),
    function 2(uuid, uuid) uuid_sortsupport(internal),
    function 4(uuid, uuid) btequalimage(oid);

create operator class pg_catalog.uuid_ops default for type uuid using btree as
    operator 1 <(uuid,uuid),
    operator 2 <=(uuid,uuid),
    operator 3 =(uuid,uuid),
    operator 4 >=(uuid,uuid),
    operator 5 >(uuid,uuid);

create operator class pg_catalog.uuid_ops default for type uuid using hash as
    operator 1 <(uuid,uuid),
    operator 2 <=(uuid,uuid),
    operator 3 =(uuid,uuid),
    operator 4 >=(uuid,uuid),
    operator 5 >(uuid,uuid);

create operator family pg_catalog.uuid_ops using hash;

alter operator family pg_catalog.uuid_ops using hash add
    operator 1 =(uuid,uuid),
    function 1(uuid, uuid) uuid_hash(uuid),
    function 2(uuid, uuid) uuid_hash_extended(uuid,bigint);

create operator family pg_catalog.varbit_minmax_ops using brin;

alter operator family pg_catalog.varbit_minmax_ops using brin add
    function 1(bit varying, bit varying) brin_minmax_opcinfo(internal),
    function 2(bit varying, bit varying) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bit varying, bit varying) brin_minmax_consistent(internal,internal,internal),
    function 4(bit varying, bit varying) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.varbit_minmax_ops default for type bit varying using brin as storage bit varying operator 1 <(bit varying,bit varying),
	operator 2 <=(bit varying,bit varying),
	operator 3 =(bit varying,bit varying),
	operator 4 >=(bit varying,bit varying),
	operator 5 >(bit varying,bit varying);

create operator family pg_catalog.varbit_ops using btree;

alter operator family pg_catalog.varbit_ops using btree add
    function 1(bit varying, bit varying) varbitcmp(bit varying,bit varying),
    function 4(bit varying, bit varying) btequalimage(oid);

create operator class pg_catalog.varbit_ops default for type bit varying using btree as
    operator 1 <(bit varying,bit varying),
    operator 2 <=(bit varying,bit varying),
    operator 3 =(bit varying,bit varying),
    operator 4 >=(bit varying,bit varying),
    operator 5 >(bit varying,bit varying);

create operator family pg_catalog.xid8_ops using btree;

alter operator family pg_catalog.xid8_ops using btree add
    operator 1 <(xid8,xid8),
    operator 2 <=(xid8,xid8),
    operator 3 =(xid8,xid8),
    operator 4 >=(xid8,xid8),
    operator 5 >(xid8,xid8),
    function 1(xid8, xid8) xid8cmp(xid8,xid8),
    function 4(xid8, xid8) btequalimage(oid);

create operator family pg_catalog.xid8_ops using hash;

alter operator family pg_catalog.xid8_ops using hash add
    function 1(xid8, xid8) hashint8(bigint),
    function 2(xid8, xid8) hashint8extended(bigint,bigint);

create operator class pg_catalog.xid8_ops default for type xid8 using btree as
    operator 1 =(xid8,xid8);

create operator class pg_catalog.xid8_ops default for type xid8 using hash as
    operator 1 =(xid8,xid8);

create operator family pg_catalog.xid_ops using hash;

alter operator family pg_catalog.xid_ops using hash add
    function 1(xid, xid) hashint4(integer),
    function 2(xid, xid) hashint4extended(integer,bigint);

create operator class pg_catalog.xid_ops default for type xid using hash as
    operator 1 =(xid,xid);

-- Cyclic dependencies found

create aggregate pg_catalog.array_agg(unknown) (
    sfunc = array_agg_array_transfn,
    stype = ???,
finalfunc = array_agg_array_finalfn
);

comment on aggregate pg_catalog.array_agg(unknown) is 'concatenate aggregate input into an array';

create aggregate pg_catalog.array_agg(unknown) (
    sfunc = array_agg_transfn,
    stype = ???,
finalfunc = array_agg_finalfn
);

comment on aggregate pg_catalog.array_agg(unknown) is 'concatenate aggregate input into an array';

-- Cyclic dependencies found

create aggregate pg_catalog.bool_and(unknown) (
    sfunc = booland_statefunc,
    stype = ???,
combinefunc = booland_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_alltrue,
sortop = operator(<)
);

comment on aggregate pg_catalog.bool_and(unknown) is 'boolean-and aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bool_or(unknown) (
    sfunc = boolor_statefunc,
    stype = ???,
combinefunc = boolor_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_anytrue,
sortop = operator(>)
);

comment on aggregate pg_catalog.bool_or(unknown) is 'boolean-or aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.every(unknown) (
    sfunc = booland_statefunc,
    stype = ???,
combinefunc = booland_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_alltrue,
sortop = operator(<)
);

comment on aggregate pg_catalog.every(unknown) is 'boolean-and aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.percentile_disc(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_disc_final
);

comment on aggregate pg_catalog.percentile_disc(unknown, unknown) is 'discrete percentile';

create aggregate pg_catalog.percentile_disc(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_disc_multi_final
);

comment on aggregate pg_catalog.percentile_disc(unknown, unknown) is 'multiple discrete percentiles';

-- Cyclic dependencies found

create aggregate pg_catalog.range_intersect_agg(unknown) (
    sfunc = multirange_intersect_agg_transfn,
    stype = ???,
combinefunc = multirange_intersect_agg_transfn
);

comment on aggregate pg_catalog.range_intersect_agg(unknown) is 'range aggregate by intersecting';

create aggregate pg_catalog.range_intersect_agg(unknown) (
    sfunc = range_intersect_agg_transfn,
    stype = ???,
combinefunc = range_intersect_agg_transfn
);

comment on aggregate pg_catalog.range_intersect_agg(unknown) is 'range aggregate by intersecting';

-- Cyclic dependencies found

create aggregate pg_catalog.string_agg(unknown, unknown) (
    sfunc = string_agg_transfn,
    stype = ???,
finalfunc = string_agg_finalfn
);

comment on aggregate pg_catalog.string_agg(unknown, unknown) is 'concatenate aggregate input into a string';

create aggregate pg_catalog.string_agg(unknown, unknown) (
    sfunc = bytea_string_agg_transfn,
    stype = ???,
finalfunc = bytea_string_agg_finalfn
);

comment on aggregate pg_catalog.string_agg(unknown, unknown) is 'concatenate aggregate input into a bytea';

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = bpcharregexne, leftarg = char, rightarg = text, negator = pg_catalog.~, join = regexnejoinsel, restrict = regexnesel);

comment on operator pg_catalog.!~(char, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = bpcharregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~, join = regexeqjoinsel, restrict = regexeqsel);

comment on operator pg_catalog.~(char, text) is 'matches regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = nameregexne, leftarg = name, rightarg = text, negator = pg_catalog.~, join = regexnejoinsel, restrict = regexnesel);

comment on operator pg_catalog.!~(name, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = textregexne, leftarg = text, rightarg = text, negator = pg_catalog.~, join = regexnejoinsel, restrict = regexnesel);

comment on operator pg_catalog.!~(text, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = nameregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~, join = regexeqjoinsel, restrict = regexeqsel);

comment on operator pg_catalog.~(name, text) is 'matches regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = textregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~, join = regexeqjoinsel, restrict = regexeqsel);

comment on operator pg_catalog.~(text, text) is 'matches regular expression, case-sensitive';

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = bpcharicregexne, leftarg = char, rightarg = text, negator = pg_catalog.~*, join = icregexnejoinsel, restrict = icregexnesel);

comment on operator pg_catalog.!~*(char, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = bpcharicregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~*, join = icregexeqjoinsel, restrict = icregexeqsel);

comment on operator pg_catalog.~*(char, text) is 'matches regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = nameicregexne, leftarg = name, rightarg = text, negator = pg_catalog.~*, join = icregexnejoinsel, restrict = icregexnesel);

comment on operator pg_catalog.!~*(name, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = texticregexne, leftarg = text, rightarg = text, negator = pg_catalog.~*, join = icregexnejoinsel, restrict = icregexnesel);

comment on operator pg_catalog.!~*(text, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = nameicregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~*, join = icregexeqjoinsel, restrict = icregexeqsel);

comment on operator pg_catalog.~*(name, text) is 'matches regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = texticregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~*, join = icregexeqjoinsel, restrict = icregexeqsel);

comment on operator pg_catalog.~*(text, text) is 'matches regular expression, case-insensitive';

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = byteanlike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.~~, join = nlikejoinsel, restrict = nlikesel);

comment on operator pg_catalog.!~~(bytea, bytea) is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = bytealike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.!~~, join = likejoinsel, restrict = likesel);

comment on operator pg_catalog.~~(bytea, bytea) is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = bpcharnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~, join = nlikejoinsel, restrict = nlikesel);

comment on operator pg_catalog.!~~(char, text) is 'does not match LIKE expression';

create operator pg_catalog.!~~ (procedure = namenlike, leftarg = name, rightarg = text, negator = pg_catalog.~~, join = nlikejoinsel, restrict = nlikesel);

comment on operator pg_catalog.!~~(name, text) is 'does not match LIKE expression';

create operator pg_catalog.!~~ (procedure = textnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~, join = nlikejoinsel, restrict = nlikesel);

comment on operator pg_catalog.!~~(text, text) is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = bpcharlike, leftarg = char, rightarg = text, negator = pg_catalog.!~~, join = likejoinsel, restrict = likesel);

comment on operator pg_catalog.~~(char, text) is 'matches LIKE expression';

create operator pg_catalog.~~ (procedure = namelike, leftarg = name, rightarg = text, negator = pg_catalog.!~~, join = likejoinsel, restrict = likesel);

comment on operator pg_catalog.~~(name, text) is 'matches LIKE expression';

create operator pg_catalog.~~ (procedure = textlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~, join = likejoinsel, restrict = likesel);

comment on operator pg_catalog.~~(text, text) is 'matches LIKE expression';

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = bpcharicnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~*, join = icnlikejoinsel, restrict = icnlikesel);

comment on operator pg_catalog.!~~*(char, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = bpchariclike, leftarg = char, rightarg = text, negator = pg_catalog.!~~*, join = iclikejoinsel, restrict = iclikesel);

comment on operator pg_catalog.~~*(char, text) is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = nameicnlike, leftarg = name, rightarg = text, negator = pg_catalog.~~*, join = icnlikejoinsel, restrict = icnlikesel);

comment on operator pg_catalog.!~~*(name, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = texticnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~*, join = icnlikejoinsel, restrict = icnlikesel);

comment on operator pg_catalog.!~~*(text, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = nameiclike, leftarg = name, rightarg = text, negator = pg_catalog.!~~*, join = iclikejoinsel, restrict = iclikesel);

comment on operator pg_catalog.~~*(name, text) is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = texticlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~*, join = iclikejoinsel, restrict = iclikesel);

comment on operator pg_catalog.~~*(text, text) is 'matches LIKE expression, case-insensitive';

-- Cyclic dependencies found

create operator pg_catalog.*<> (procedure = record_image_ne, leftarg = record, rightarg = record, commutator = pg_catalog.*<>, negator = pg_catalog.*=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.*<>(record, record) is 'not identical';

create operator pg_catalog.*= (procedure = record_image_eq, leftarg = record, rightarg = record, commutator = pg_catalog.*=, negator = pg_catalog.*<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.*=(record, record) is 'identical';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = path_n_lt, leftarg = path, rightarg = path, commutator = pg_catalog.>);

comment on operator pg_catalog.<(path, path) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = multirange_before_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>>, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<<(anymultirange, anymultirange) is 'is left of';

create operator pg_catalog.>> (procedure = multirange_after_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<<, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.>>(anymultirange, anymultirange) is 'is right of';

create operator pg_catalog.<< (procedure = multirange_before_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.>>, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<<(anymultirange, anyrange) is 'is left of';

create operator pg_catalog.<< (procedure = range_before_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.>>, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<<(anyrange, anymultirange) is 'is left of';

create operator pg_catalog.<< (procedure = range_before, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>>, join = scalarltjoinsel, restrict = rangesel);

comment on operator pg_catalog.<<(anyrange, anyrange) is 'is left of';

create operator pg_catalog.>> (procedure = multirange_after_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.<<, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.>>(anymultirange, anyrange) is 'is right of';

create operator pg_catalog.>> (procedure = range_after_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.<<, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.>>(anyrange, anymultirange) is 'is right of';

create operator pg_catalog.>> (procedure = range_after, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<<, join = scalargtjoinsel, restrict = rangesel);

comment on operator pg_catalog.>>(anyrange, anyrange) is 'is right of';

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = network_sub, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>, join = networkjoinsel, restrict = networksel);

comment on operator pg_catalog.<<(inet, inet) is 'is subnet';

create operator pg_catalog.>> (procedure = network_sup, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<, join = networkjoinsel, restrict = networksel);

comment on operator pg_catalog.>>(inet, inet) is 'is supernet';

-- Cyclic dependencies found

create operator pg_catalog.<<= (procedure = network_subeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>=, join = networkjoinsel, restrict = networksel);

comment on operator pg_catalog.<<=(inet, inet) is 'is subnet or equal';

create operator pg_catalog.>>= (procedure = network_supeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<=, join = networkjoinsel, restrict = networksel);

comment on operator pg_catalog.>>=(inet, inet) is 'is supernet or equal';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = path_n_le, leftarg = path, rightarg = path, commutator = pg_catalog.>=);

comment on operator pg_catalog.<=(path, path) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = charne, leftarg = "char", rightarg = "char", commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>("char", "char") is 'not equal';

create operator pg_catalog.= (procedure = chareq, leftarg = "char", rightarg = "char", commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=("char", "char") is 'equal';

create operator pg_catalog.<> (procedure = array_ne, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(anyarray, anyarray) is 'not equal';

create operator pg_catalog.<> (procedure = enum_ne, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(anyenum, anyenum) is 'not equal';

create operator pg_catalog.<> (procedure = multirange_ne, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(anymultirange, anymultirange) is 'not equal';

create operator pg_catalog.<> (procedure = range_ne, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(anyrange, anyrange) is 'not equal';

create operator pg_catalog.<> (procedure = int8ne, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bigint, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = int84ne, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bigint, integer) is 'not equal';

create operator pg_catalog.<> (procedure = int82ne, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bigint, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = varbitne, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bit varying, bit varying) is 'not equal';

create operator pg_catalog.<> (procedure = bitne, leftarg = bit, rightarg = bit, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bit, bit) is 'not equal';

create operator pg_catalog.<> (procedure = boolne, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(boolean, boolean) is 'not equal';

create operator pg_catalog.<> (procedure = byteane, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(bytea, bytea) is 'not equal';

create operator pg_catalog.<> (procedure = bpcharne, leftarg = char, rightarg = char, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(char, char) is 'not equal';

create operator pg_catalog.<> (procedure = circle_ne, leftarg = circle, rightarg = circle, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(circle, circle) is 'not equal by area';

create operator pg_catalog.<> (procedure = date_ne, leftarg = date, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(date, date) is 'not equal';

create operator pg_catalog.<> (procedure = date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(date, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = date_ne_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(date, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = float8ne, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(double precision, double precision) is 'not equal';

create operator pg_catalog.<> (procedure = float84ne, leftarg = double precision, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(double precision, real) is 'not equal';

create operator pg_catalog.<> (procedure = network_ne, leftarg = inet, rightarg = inet, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(inet, inet) is 'not equal';

create operator pg_catalog.<> (procedure = int48ne, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(integer, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = int4ne, leftarg = integer, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(integer, integer) is 'not equal';

create operator pg_catalog.<> (procedure = int42ne, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(integer, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = interval_ne, leftarg = interval, rightarg = interval, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(interval, interval) is 'not equal';

create operator pg_catalog.<> (procedure = jsonb_ne, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(jsonb, jsonb) is 'not equal';

create operator pg_catalog.<> (procedure = lseg_ne, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(lseg, lseg) is 'not equal';

create operator pg_catalog.<> (procedure = macaddr_ne, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(macaddr, macaddr) is 'not equal';

create operator pg_catalog.<> (procedure = macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(macaddr8, macaddr8) is 'not equal';

create operator pg_catalog.<> (procedure = cash_ne, leftarg = money, rightarg = money, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(money, money) is 'not equal';

create operator pg_catalog.<> (procedure = namene, leftarg = name, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(name, name) is 'not equal';

create operator pg_catalog.<> (procedure = namenetext, leftarg = name, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(name, text) is 'not equal';

create operator pg_catalog.<> (procedure = numeric_ne, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(numeric, numeric) is 'not equal';

create operator pg_catalog.<> (procedure = oidne, leftarg = oid, rightarg = oid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(oid, oid) is 'not equal';

create operator pg_catalog.<> (procedure = oidvectorne, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(oidvector, oidvector) is 'not equal';

create operator pg_catalog.<> (procedure = pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn) is 'not equal';

create operator pg_catalog.= (procedure = aclitemeq, leftarg = aclitem, rightarg = aclitem, commutator = pg_catalog.=, join = eqjoinsel, restrict = eqsel, hashes);

comment on operator pg_catalog.=(aclitem, aclitem) is 'equal';

create operator pg_catalog.= (procedure = array_eq, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(anyarray, anyarray) is 'equal';

create operator pg_catalog.= (procedure = enum_eq, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(anyenum, anyenum) is 'equal';

create operator pg_catalog.= (procedure = multirange_eq, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(anymultirange, anymultirange) is 'equal';

create operator pg_catalog.= (procedure = range_eq, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(anyrange, anyrange) is 'equal';

create operator pg_catalog.= (procedure = int8eq, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, bigint) is 'equal';

create operator pg_catalog.= (procedure = int84eq, leftarg = bigint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, integer) is 'equal';

create operator pg_catalog.= (procedure = int82eq, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, smallint) is 'equal';

create operator pg_catalog.= (procedure = varbiteq, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(bit varying, bit varying) is 'equal';

create operator pg_catalog.= (procedure = biteq, leftarg = bit, rightarg = bit, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(bit, bit) is 'equal';

create operator pg_catalog.= (procedure = booleq, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(boolean, boolean) is 'equal';

create operator pg_catalog.= (procedure = box_eq, leftarg = box, rightarg = box, commutator = pg_catalog.=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(box, box) is 'equal by area';

create operator pg_catalog.= (procedure = byteaeq, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(bytea, bytea) is 'equal';

create operator pg_catalog.= (procedure = bpchareq, leftarg = char, rightarg = char, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(char, char) is 'equal';

create operator pg_catalog.= (procedure = cideq, leftarg = cid, rightarg = cid, commutator = pg_catalog.=, join = eqjoinsel, restrict = eqsel, hashes);

comment on operator pg_catalog.=(cid, cid) is 'equal';

create operator pg_catalog.= (procedure = circle_eq, leftarg = circle, rightarg = circle, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(circle, circle) is 'equal by area';

create operator pg_catalog.= (procedure = date_eq, leftarg = date, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(date, date) is 'equal';

create operator pg_catalog.= (procedure = date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(date, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = date_eq_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(date, timestamp) is 'equal';

create operator pg_catalog.= (procedure = float8eq, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, double precision) is 'equal';

create operator pg_catalog.= (procedure = float84eq, leftarg = double precision, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, real) is 'equal';

create operator pg_catalog.= (procedure = network_eq, leftarg = inet, rightarg = inet, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(inet, inet) is 'equal';

create operator pg_catalog.= (procedure = int48eq, leftarg = integer, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, bigint) is 'equal';

create operator pg_catalog.= (procedure = int4eq, leftarg = integer, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, integer) is 'equal';

create operator pg_catalog.= (procedure = int42eq, leftarg = integer, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, smallint) is 'equal';

create operator pg_catalog.= (procedure = interval_eq, leftarg = interval, rightarg = interval, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(interval, interval) is 'equal';

create operator pg_catalog.= (procedure = jsonb_eq, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(jsonb, jsonb) is 'equal';

create operator pg_catalog.= (procedure = line_eq, leftarg = line, rightarg = line, commutator = pg_catalog.=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(line, line) is 'equal';

create operator pg_catalog.= (procedure = lseg_eq, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(lseg, lseg) is 'equal';

create operator pg_catalog.= (procedure = macaddr_eq, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr, macaddr) is 'equal';

create operator pg_catalog.= (procedure = macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr8, macaddr8) is 'equal';

create operator pg_catalog.= (procedure = cash_eq, leftarg = money, rightarg = money, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(money, money) is 'equal';

create operator pg_catalog.= (procedure = nameeq, leftarg = name, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(name, name) is 'equal';

create operator pg_catalog.= (procedure = nameeqtext, leftarg = name, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(name, text) is 'equal';

create operator pg_catalog.= (procedure = numeric_eq, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(numeric, numeric) is 'equal';

create operator pg_catalog.= (procedure = oideq, leftarg = oid, rightarg = oid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(oid, oid) is 'equal';

create operator pg_catalog.= (procedure = oidvectoreq, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(oidvector, oidvector) is 'equal';

create operator pg_catalog.= (procedure = path_n_eq, leftarg = path, rightarg = path, commutator = pg_catalog.=, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(path, path) is 'equal';

create operator pg_catalog.= (procedure = pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(pg_lsn, pg_lsn) is 'equal';

create operator pg_catalog.= (procedure = float48eq, leftarg = real, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(real, double precision) is 'equal';

create operator pg_catalog.<> (procedure = float48ne, leftarg = real, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(real, double precision) is 'not equal';

create operator pg_catalog.<> (procedure = float4ne, leftarg = real, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(real, real) is 'not equal';

create operator pg_catalog.<> (procedure = record_ne, leftarg = record, rightarg = record, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(record, record) is 'not equal';

create operator pg_catalog.<> (procedure = int28ne, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(smallint, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = int24ne, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(smallint, integer) is 'not equal';

create operator pg_catalog.<> (procedure = int2ne, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(smallint, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = textnename, leftarg = text, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(text, name) is 'not equal';

create operator pg_catalog.<> (procedure = textne, leftarg = text, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(text, text) is 'not equal';

create operator pg_catalog.<> (procedure = tidne, leftarg = tid, rightarg = tid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(tid, tid) is 'not equal';

create operator pg_catalog.<> (procedure = timetz_ne, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(time with time zone, time with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = time_ne, leftarg = time, rightarg = time, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(time, time) is 'not equal';

create operator pg_catalog.<> (procedure = timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, date) is 'not equal';

create operator pg_catalog.<> (procedure = timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = timestamp_ne_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp, date) is 'not equal';

create operator pg_catalog.<> (procedure = timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = timestamp_ne, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = tsquery_ne, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(tsquery, tsquery) is 'not equal';

create operator pg_catalog.<> (procedure = tsvector_ne, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(tsvector, tsvector) is 'not equal';

create operator pg_catalog.<> (procedure = uuid_ne, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(uuid, uuid) is 'not equal';

create operator pg_catalog.<> (procedure = xidneqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(xid, integer) is 'not equal';

create operator pg_catalog.<> (procedure = xidneq, leftarg = xid, rightarg = xid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(xid, xid) is 'not equal';

create operator pg_catalog.<> (procedure = xid8ne, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(xid8, xid8) is 'not equal';

create operator pg_catalog.= (procedure = float4eq, leftarg = real, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(real, real) is 'equal';

create operator pg_catalog.= (procedure = record_eq, leftarg = record, rightarg = record, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(record, record) is 'equal';

create operator pg_catalog.= (procedure = int28eq, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, bigint) is 'equal';

create operator pg_catalog.= (procedure = int24eq, leftarg = smallint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, integer) is 'equal';

create operator pg_catalog.= (procedure = int2eq, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, smallint) is 'equal';

create operator pg_catalog.= (procedure = texteqname, leftarg = text, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(text, name) is 'equal';

create operator pg_catalog.= (procedure = texteq, leftarg = text, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(text, text) is 'equal';

create operator pg_catalog.= (procedure = tideq, leftarg = tid, rightarg = tid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(tid, tid) is 'equal';

create operator pg_catalog.= (procedure = timetz_eq, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(time with time zone, time with time zone) is 'equal';

create operator pg_catalog.= (procedure = time_eq, leftarg = time, rightarg = time, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(time, time) is 'equal';

create operator pg_catalog.= (procedure = timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, date) is 'equal';

create operator pg_catalog.= (procedure = timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp) is 'equal';

create operator pg_catalog.= (procedure = timestamp_eq_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(timestamp, date) is 'equal';

create operator pg_catalog.= (procedure = timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(timestamp, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = timestamp_eq, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp, timestamp) is 'equal';

create operator pg_catalog.= (procedure = tsquery_eq, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(tsquery, tsquery) is 'equal';

create operator pg_catalog.= (procedure = tsvector_eq, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, merges);

comment on operator pg_catalog.=(tsvector, tsvector) is 'equal';

create operator pg_catalog.= (procedure = uuid_eq, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(uuid, uuid) is 'equal';

create operator pg_catalog.= (procedure = xideqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.=(xid, integer) is 'equal';

create operator pg_catalog.= (procedure = xideq, leftarg = xid, rightarg = xid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes);

comment on operator pg_catalog.=(xid, xid) is 'equal';

create operator pg_catalog.= (procedure = xid8eq, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel, hashes, merges);

comment on operator pg_catalog.=(xid8, xid8) is 'equal';

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = point_ne, leftarg = point, rightarg = point, commutator = pg_catalog.<>, negator = pg_catalog.~=, join = neqjoinsel, restrict = neqsel);

comment on operator pg_catalog.<>(point, point) is 'not equal';

create operator pg_catalog.~= (procedure = point_eq, leftarg = point, rightarg = point, commutator = pg_catalog.~=, negator = pg_catalog.<>, join = eqjoinsel, restrict = eqsel);

comment on operator pg_catalog.~=(point, point) is 'same as';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(box, box) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(circle, circle) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(point, circle) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(point, polygon) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(polygon, polygon) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = on_pb, leftarg = point, rightarg = box, commutator = pg_catalog.@>, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.<@(point, box) is 'point inside box';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.@>);

comment on operator pg_catalog.<@(point, path) is 'point within closed path, or point on open path';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = tsq_mcontained, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.@>, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.<@(tsquery, tsquery) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = arraycontained, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.@>, join = arraycontjoinsel, restrict = arraycontsel);

comment on operator pg_catalog.<@(anyarray, anyarray) is 'is contained by';

create operator pg_catalog.@> (procedure = arraycontains, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<@, join = arraycontjoinsel, restrict = arraycontsel);

comment on operator pg_catalog.@>(anyarray, anyarray) is 'contains';

create operator pg_catalog.<@ (procedure = elem_contained_by_multirange, leftarg = anyelement, rightarg = anymultirange, commutator = pg_catalog.@>, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<@(anyelement, anymultirange) is 'is contained by';

create operator pg_catalog.<@ (procedure = elem_contained_by_range, leftarg = anyelement, rightarg = anyrange, commutator = pg_catalog.@>, join = contjoinsel, restrict = rangesel);

comment on operator pg_catalog.<@(anyelement, anyrange) is 'is contained by';

create operator pg_catalog.<@ (procedure = multirange_contained_by_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.@>, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<@(anymultirange, anymultirange) is 'is contained by';

create operator pg_catalog.<@ (procedure = multirange_contained_by_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.@>, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<@(anymultirange, anyrange) is 'is contained by';

create operator pg_catalog.<@ (procedure = range_contained_by_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.@>, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<@(anyrange, anymultirange) is 'is contained by';

create operator pg_catalog.<@ (procedure = range_contained_by, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.@>, join = contjoinsel, restrict = rangesel);

comment on operator pg_catalog.<@(anyrange, anyrange) is 'is contained by';

create operator pg_catalog.<@ (procedure = jsonb_contained, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.@>, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.<@(jsonb, jsonb) is 'is contained by';

create operator pg_catalog.@> (procedure = multirange_contains_elem, leftarg = anymultirange, rightarg = anyelement, commutator = pg_catalog.<@, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.@>(anymultirange, anyelement) is 'contains';

create operator pg_catalog.@> (procedure = multirange_contains_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<@, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.@>(anymultirange, anymultirange) is 'contains';

create operator pg_catalog.@> (procedure = multirange_contains_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.<@, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.@>(anymultirange, anyrange) is 'contains';

create operator pg_catalog.@> (procedure = range_contains_elem, leftarg = anyrange, rightarg = anyelement, commutator = pg_catalog.<@, join = contjoinsel, restrict = rangesel);

comment on operator pg_catalog.@>(anyrange, anyelement) is 'contains';

create operator pg_catalog.@> (procedure = range_contains_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.<@, join = contjoinsel, restrict = multirangesel);

comment on operator pg_catalog.@>(anyrange, anymultirange) is 'contains';

create operator pg_catalog.@> (procedure = range_contains, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<@, join = contjoinsel, restrict = rangesel);

comment on operator pg_catalog.@>(anyrange, anyrange) is 'contains';

create operator pg_catalog.@> (procedure = box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(box, box) is 'contains';

create operator pg_catalog.@> (procedure = box_contain_pt, leftarg = box, rightarg = point, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(box, point) is 'contains';

create operator pg_catalog.@> (procedure = circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(circle, circle) is 'contains';

create operator pg_catalog.@> (procedure = circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(circle, point) is 'contains';

create operator pg_catalog.@> (procedure = jsonb_contains, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<@, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@>(jsonb, jsonb) is 'contains';

create operator pg_catalog.@> (procedure = path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.<@);

comment on operator pg_catalog.@>(path, point) is 'contains';

create operator pg_catalog.@> (procedure = poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(polygon, point) is 'contains';

create operator pg_catalog.@> (procedure = poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<@, join = contjoinsel, restrict = contsel);

comment on operator pg_catalog.@>(polygon, polygon) is 'contains';

create operator pg_catalog.@> (procedure = tsq_mcontains, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<@, join = matchingjoinsel, restrict = matchingsel);

comment on operator pg_catalog.@>(tsquery, tsquery) is 'contains';

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = path_n_gt, leftarg = path, rightarg = path, commutator = pg_catalog.<);

comment on operator pg_catalog.>(path, path) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.>= (procedure = path_n_ge, leftarg = path, rightarg = path, commutator = pg_catalog.<=);

comment on operator pg_catalog.>=(path, path) is 'greater than or equal';

-- Cyclic dependencies found

create function pg_catalog.abbrev(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(unknown) is 'abbreviated display of cidr value';

create function pg_catalog.abbrev(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(unknown) is 'abbreviated display of inet value';

-- Cyclic dependencies found

create function pg_catalog.age(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(unknown, unknown) is 'date difference preserving months and years';

create function pg_catalog.age(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(unknown, unknown) is 'date difference preserving months and years';

-- Cyclic dependencies found

create function pg_catalog.bit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(unknown, unknown) is 'convert int4 to bitstring';

create function pg_catalog.bit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(unknown, unknown) is 'convert int8 to bitstring';

-- Cyclic dependencies found

create function pg_catalog.bit_count(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_count(unknown) is 'number of set bits';

create function pg_catalog.bit_count(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_count(unknown) is 'number of set bits';

-- Cyclic dependencies found

create function pg_catalog.bool(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(unknown) is 'convert int4 to boolean';

create function pg_catalog.bool(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(unknown) is 'convert jsonb to boolean';

-- Cyclic dependencies found

create function pg_catalog.bpchar(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(unknown) is 'convert name to char(n)';

create function pg_catalog.bpchar(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(unknown) is 'convert char to char(n)';

-- Cyclic dependencies found

create function pg_catalog.btrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(unknown, unknown) is 'trim selected characters from both ends of string';

create function pg_catalog.btrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(unknown, unknown) is 'trim selected bytes from both ends of string';

-- Cyclic dependencies found

create function pg_catalog.ceil(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(unknown) is 'nearest integer >= value';

create function pg_catalog.ceil(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(unknown) is 'nearest integer >= value';

-- Cyclic dependencies found

create function pg_catalog.ceiling(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(unknown) is 'nearest integer >= value';

create function pg_catalog.ceiling(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(unknown) is 'nearest integer >= value';

-- Cyclic dependencies found

create function pg_catalog.center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(unknown) is 'center of';

create function pg_catalog.center(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(unknown) is 'center of';

-- Cyclic dependencies found

create function pg_catalog.char(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(unknown) is 'convert int4 to char';

create function pg_catalog.char(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(unknown) is 'convert text to char';

-- Cyclic dependencies found

create function pg_catalog.char_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(unknown) is 'character length';

create function pg_catalog.char_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(unknown) is 'character length';

-- Cyclic dependencies found

create function pg_catalog.character_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(unknown) is 'character length';

create function pg_catalog.character_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(unknown) is 'character length';

-- Cyclic dependencies found

create function pg_catalog.circle(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(unknown) is 'convert box to circle';

create function pg_catalog.circle(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(unknown) is 'convert polygon to circle';

-- Cyclic dependencies found

create function pg_catalog.date(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(unknown) is 'convert timestamp to date';

create function pg_catalog.date(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(unknown) is 'convert timestamp with time zone to date';

-- Cyclic dependencies found

create function pg_catalog.date_bin(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_bin(unknown, unknown, unknown) is 'bin timestamp into specified interval';

create function pg_catalog.date_bin(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_bin(unknown, unknown, unknown) is 'bin timestamp with time zone into specified interval';

-- Cyclic dependencies found

create function pg_catalog.datemultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange(unknown) is 'datemultirange constructor';

create function pg_catalog.datemultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange(unknown) is 'datemultirange constructor';

-- Cyclic dependencies found

create function pg_catalog.exp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(unknown) is 'natural exponential (e^x)';

create function pg_catalog.exp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(unknown) is 'natural exponential (e^x)';

-- Cyclic dependencies found

create function pg_catalog.floor(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(unknown) is 'nearest integer <= value';

create function pg_catalog.floor(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(unknown) is 'nearest integer <= value';

-- Cyclic dependencies found

create function pg_catalog.get_bit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(unknown, unknown) is 'get bit';

create function pg_catalog.get_bit(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(unknown, unknown) is 'get bit';

-- Cyclic dependencies found

create function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support (obsolete)';

-- Cyclic dependencies found

create function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support';

create function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) is 'GIN tsvector support (obsolete)';

-- Cyclic dependencies found

create function pg_catalog.gtsquery_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST tsquery support';

create function pg_catalog.gtsquery_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST tsquery support (obsolete)';

-- Cyclic dependencies found

create function pg_catalog.gtsvector_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST tsvector support';

create function pg_catalog.gtsvector_consistent(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(unknown, unknown, unknown, unknown, unknown) is 'GiST tsvector support (obsolete)';

-- Cyclic dependencies found

create function pg_catalog.has_any_column_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown) is 'current user privilege on any column by rel name';

create function pg_catalog.has_any_column_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown) is 'current user privilege on any column by rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_database_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown) is 'current user privilege on database by database name';

create function pg_catalog.has_database_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown) is 'current user privilege on database by database oid';

-- Cyclic dependencies found

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown) is 'current user privilege on foreign data wrapper by foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown) is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

-- Cyclic dependencies found

create function pg_catalog.has_function_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown) is 'current user privilege on function by function name';

create function pg_catalog.has_function_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown) is 'current user privilege on function by function oid';

-- Cyclic dependencies found

create function pg_catalog.has_language_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown) is 'current user privilege on language by language name';

create function pg_catalog.has_language_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown) is 'current user privilege on language by language oid';

-- Cyclic dependencies found

create function pg_catalog.has_schema_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown) is 'current user privilege on schema by schema name';

create function pg_catalog.has_schema_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown) is 'current user privilege on schema by schema oid';

-- Cyclic dependencies found

create function pg_catalog.has_sequence_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown) is 'current user privilege on sequence by seq name';

create function pg_catalog.has_sequence_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown) is 'current user privilege on sequence by seq oid';

-- Cyclic dependencies found

create function pg_catalog.has_server_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown) is 'current user privilege on server by server name';

create function pg_catalog.has_server_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown) is 'current user privilege on server by server oid';

-- Cyclic dependencies found

create function pg_catalog.has_table_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown) is 'current user privilege on relation by rel name';

create function pg_catalog.has_table_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown) is 'current user privilege on relation by rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_tablespace_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown) is 'current user privilege on tablespace by tablespace name';

create function pg_catalog.has_tablespace_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown) is 'current user privilege on tablespace by tablespace oid';

-- Cyclic dependencies found

create function pg_catalog.has_type_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown) is 'current user privilege on type by type name';

create function pg_catalog.has_type_privilege(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown) is 'current user privilege on type by type oid';

-- Cyclic dependencies found

create function pg_catalog.int4multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange(unknown) is 'int4multirange constructor';

create function pg_catalog.int4multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange(unknown) is 'int4multirange constructor';

-- Cyclic dependencies found

create function pg_catalog.int8multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange(unknown) is 'int8multirange constructor';

create function pg_catalog.int8multirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange(unknown) is 'int8multirange constructor';

-- Cyclic dependencies found

create function pg_catalog.isempty(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty(unknown) is 'is the range empty?';

create function pg_catalog.isempty(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty(unknown) is 'is the multirange empty?';

-- Cyclic dependencies found

create function pg_catalog.ishorizontal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(unknown) is 'horizontal';

create function pg_catalog.ishorizontal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(unknown) is 'horizontal';

-- Cyclic dependencies found

create function pg_catalog.isparallel(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(unknown, unknown) is 'parallel';

create function pg_catalog.isparallel(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(unknown, unknown) is 'parallel';

-- Cyclic dependencies found

create function pg_catalog.isperp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(unknown, unknown) is 'perpendicular';

create function pg_catalog.isperp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(unknown, unknown) is 'perpendicular';

-- Cyclic dependencies found

create function pg_catalog.isvertical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(unknown) is 'vertical';

create function pg_catalog.isvertical(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(unknown) is 'vertical';

-- Cyclic dependencies found

create function pg_catalog.like_escape(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(unknown, unknown) is 'convert LIKE pattern to use backslash escapes';

create function pg_catalog.like_escape(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(unknown, unknown) is 'convert LIKE pattern to use backslash escapes';

-- Cyclic dependencies found

create function pg_catalog.ln(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(unknown) is 'natural logarithm';

create function pg_catalog.ln(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(unknown) is 'natural logarithm';

-- Cyclic dependencies found

create function pg_catalog.log(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(unknown) is 'base 10 logarithm';

create function pg_catalog.log(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(unknown) is 'base 10 logarithm';

-- Cyclic dependencies found

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(unknown) is 'base 10 logarithm';

create function pg_catalog.log10(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(unknown) is 'base 10 logarithm';

-- Cyclic dependencies found

create function pg_catalog.lower_inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc(unknown) is 'is the range''s lower bound inclusive?';

create function pg_catalog.lower_inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc(unknown) is 'is the multirange''s lower bound inclusive?';

-- Cyclic dependencies found

create function pg_catalog.lower_inf(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf(unknown) is 'is the range''s lower bound infinite?';

create function pg_catalog.lower_inf(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf(unknown) is 'is the multirange''s lower bound infinite?';

-- Cyclic dependencies found

create function pg_catalog.ltrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(unknown, unknown) is 'trim selected characters from left end of string';

create function pg_catalog.ltrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(unknown, unknown) is 'trim selected bytes from left end of string';

-- Cyclic dependencies found

create function pg_catalog.md5(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(unknown) is 'MD5 hash';

create function pg_catalog.md5(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(unknown) is 'MD5 hash';

-- Cyclic dependencies found

create function pg_catalog.npoints(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(unknown) is 'number of points';

create function pg_catalog.npoints(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(unknown) is 'number of points';

-- Cyclic dependencies found

create function pg_catalog.nummultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange(unknown) is 'nummultirange constructor';

create function pg_catalog.nummultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange(unknown) is 'nummultirange constructor';

-- Cyclic dependencies found

create function pg_catalog.pg_database_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(unknown) is 'total disk space usage for the specified database';

create function pg_catalog.pg_database_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(unknown) is 'total disk space usage for the specified database';

-- Cyclic dependencies found

create function pg_catalog.pg_get_viewdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(unknown) is 'select statement of a view';

create function pg_catalog.pg_get_viewdef(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(unknown) is 'select statement of a view';

-- Cyclic dependencies found

create function pg_catalog.pg_has_role(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown) is 'current user privilege on role by role name';

create function pg_catalog.pg_has_role(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown) is 'current user privilege on role by role oid';

-- Cyclic dependencies found

create function pg_catalog.pg_logical_emit_message(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(unknown, unknown, unknown) is 'emit a binary logical decoding message';

create function pg_catalog.pg_logical_emit_message(unknown, unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(unknown, unknown, unknown) is 'emit a textual logical decoding message';

-- Cyclic dependencies found

create function pg_catalog.pg_size_pretty(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(unknown) is 'convert a long int to a human readable text using size units';

create function pg_catalog.pg_size_pretty(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(unknown) is 'convert a numeric to a human readable text using size units';

-- Cyclic dependencies found

create function pg_catalog.pg_tablespace_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(unknown) is 'total disk space usage for the specified tablespace';

create function pg_catalog.pg_tablespace_size(unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(unknown) is 'total disk space usage for the specified tablespace';

-- Cyclic dependencies found

create function pg_catalog.pow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(unknown, unknown) is 'exponentiation';

create function pg_catalog.pow(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(unknown, unknown) is 'exponentiation';

-- Cyclic dependencies found

create function pg_catalog.power(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(unknown, unknown) is 'exponentiation';

create function pg_catalog.power(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(unknown, unknown) is 'exponentiation';

-- Cyclic dependencies found

create function pg_catalog.quote_literal(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal(unknown) is 'quote a literal for usage in a querystring';

create function pg_catalog.quote_literal(anyelement) returns text
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal(unknown) is 'quote a data value for usage in a querystring';

-- Cyclic dependencies found

create function pg_catalog.quote_nullable(unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable(unknown) is 'quote a possibly-null literal for usage in a querystring';

create function pg_catalog.quote_nullable(anyelement) returns text
    stable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable(unknown) is 'quote a possibly-null data value for usage in a querystring';

-- Cyclic dependencies found

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(unknown) is 'value rounded to ''scale'' of zero';

create function pg_catalog.round(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(unknown) is 'round to nearest integer';

-- Cyclic dependencies found

create function pg_catalog.row_security_active(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(unknown) is 'row security for current context active on table by table name';

create function pg_catalog.row_security_active(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(unknown) is 'row security for current context active on table by table oid';

-- Cyclic dependencies found

create function pg_catalog.rtrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(unknown, unknown) is 'trim selected characters from right end of string';

create function pg_catalog.rtrim(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(unknown, unknown) is 'trim selected bytes from right end of string';

-- Cyclic dependencies found

create function pg_catalog.set_bit(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(unknown, unknown, unknown) is 'set bit';

create function pg_catalog.set_bit(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(unknown, unknown, unknown) is 'set bit';

-- Cyclic dependencies found

create function pg_catalog.set_masklen(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(unknown, unknown) is 'change netmask of cidr';

create function pg_catalog.set_masklen(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(unknown, unknown) is 'change netmask of inet';

-- Cyclic dependencies found

create function pg_catalog.sign(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(unknown) is 'sign of value';

create function pg_catalog.sign(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(unknown) is 'sign of value';

-- Cyclic dependencies found

create function pg_catalog.sqrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(unknown) is 'square root';

create function pg_catalog.sqrt(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(unknown) is 'square root';

-- Cyclic dependencies found

create function pg_catalog.substr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(unknown, unknown) is 'extract portion of string';

create function pg_catalog.substr(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(unknown, unknown) is 'extract portion of string';

-- Cyclic dependencies found

create function pg_catalog.substr(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(unknown, unknown, unknown) is 'extract portion of string';

create function pg_catalog.substr(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(unknown, unknown, unknown) is 'extract portion of string';

-- Cyclic dependencies found

create function pg_catalog.timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(unknown, unknown) is 'adjust timestamp precision';

create function pg_catalog.timestamp(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(unknown, unknown) is 'convert date and time to timestamp';

-- Cyclic dependencies found

create function pg_catalog.timestamp(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(unknown) is 'convert date to timestamp';

create function pg_catalog.timestamp(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(unknown) is 'convert timestamp with time zone to timestamp';

-- Cyclic dependencies found

create function pg_catalog.timestamptz(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(unknown) is 'convert date to timestamp with time zone';

create function pg_catalog.timestamptz(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(unknown) is 'convert timestamp to timestamp with time zone';

-- Cyclic dependencies found

create function pg_catalog.timetz(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(unknown) is 'convert time to time with time zone';

create function pg_catalog.timetz(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(unknown) is 'convert timestamp with time zone to time with time zone';

-- Cyclic dependencies found

create function pg_catalog.to_ascii(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(unknown, unknown) is 'encode text from encoding to ASCII text';

create function pg_catalog.to_ascii(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(unknown, unknown) is 'encode text from encoding to ASCII text';

-- Cyclic dependencies found

create function pg_catalog.to_hex(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(unknown) is 'convert int4 number to hex';

create function pg_catalog.to_hex(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(unknown) is 'convert int8 number to hex';

-- Cyclic dependencies found

create function pg_catalog.ts_delete(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(unknown, unknown) is 'delete given lexemes';

create function pg_catalog.ts_delete(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(unknown, unknown) is 'delete lexeme';

-- Cyclic dependencies found

create function pg_catalog.ts_parse(parser_oid unknown, txt unknown, out tokid unknown, out token unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_parse(unknown, unknown, out unknown, out unknown) is 'parse text to tokens';

create function pg_catalog.ts_parse(parser_name unknown, txt unknown, out tokid unknown, out token unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_parse(unknown, unknown, out unknown, out unknown) is 'parse text to tokens';

-- Cyclic dependencies found

create function pg_catalog.ts_rank(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(unknown, unknown, unknown) is 'relevance';

create function pg_catalog.ts_rank(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(unknown, unknown, unknown) is 'relevance';

-- Cyclic dependencies found

create function pg_catalog.ts_rank_cd(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(unknown, unknown, unknown) is 'relevance';

create function pg_catalog.ts_rank_cd(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(unknown, unknown, unknown) is 'relevance';

-- Cyclic dependencies found

create function pg_catalog.ts_token_type(parser_oid unknown, out tokid unknown, out alias unknown, out description unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_token_type(unknown, out unknown, out unknown, out unknown) is 'get parser''s token types';

create function pg_catalog.ts_token_type(parser_name unknown, out tokid unknown, out alias unknown, out description unknown) returns setof unknown
    stable
    strict
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_token_type(unknown, out unknown, out unknown, out unknown) is 'get parser''s token types';

-- Cyclic dependencies found

create function pg_catalog.tsmultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange(unknown) is 'tsmultirange constructor';

create function pg_catalog.tsmultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange(unknown) is 'tsmultirange constructor';

-- Cyclic dependencies found

create function pg_catalog.tstzmultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange(unknown) is 'tstzmultirange constructor';

create function pg_catalog.tstzmultirange(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange(unknown) is 'tstzmultirange constructor';

-- Cyclic dependencies found

create function pg_catalog.upper_inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc(unknown) is 'is the range''s upper bound inclusive?';

create function pg_catalog.upper_inc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc(unknown) is 'is the multirange''s upper bound inclusive?';

-- Cyclic dependencies found

create function pg_catalog.upper_inf(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf(unknown) is 'is the range''s upper bound infinite?';

create function pg_catalog.upper_inf(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf(unknown) is 'is the multirange''s upper bound infinite?';

-- Cyclic dependencies found

create function pg_catalog.width_bucket(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(unknown, unknown, unknown, unknown) is 'bucket number of operand in equal-width histogram';

create function pg_catalog.width_bucket(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(unknown, unknown, unknown, unknown) is 'bucket number of operand in equal-width histogram';

-- Cyclic dependencies found

create operator pg_catalog.*< (procedure = record_image_lt, leftarg = record, rightarg = record, commutator = pg_catalog.*>, negator = pg_catalog.*>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.*<(record, record) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.*> (procedure = record_image_gt, leftarg = record, rightarg = record, commutator = pg_catalog.*<, negator = pg_catalog.*<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.*>(record, record) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.*<= (procedure = record_image_le, leftarg = record, rightarg = record, commutator = pg_catalog.*>=, negator = pg_catalog.*>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.*<=(record, record) is 'less than or equal';

create operator pg_catalog.*>= (procedure = record_image_ge, leftarg = record, rightarg = record, commutator = pg_catalog.*<=, negator = pg_catalog.*<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.*>=(record, record) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = charlt, leftarg = "char", rightarg = "char", commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<("char", "char") is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = chargt, leftarg = "char", rightarg = "char", commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>("char", "char") is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = array_lt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(anyarray, anyarray) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = enum_lt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(anyenum, anyenum) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int8lt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bigint, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int84lt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bigint, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int82lt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bigint, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = varbitlt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bit varying, bit varying) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = bitlt, leftarg = bit, rightarg = bit, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bit, bit) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = boollt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(boolean, boolean) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = bytealt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(bytea, bytea) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = bpcharlt, leftarg = char, rightarg = char, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(char, char) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = date_lt, leftarg = date, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(date, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(date, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = date_lt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(date, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = float8lt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(double precision, double precision) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = float84lt, leftarg = double precision, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(double precision, real) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = network_lt, leftarg = inet, rightarg = inet, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(inet, inet) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int48lt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(integer, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int4lt, leftarg = integer, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(integer, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int42lt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(integer, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = interval_lt, leftarg = interval, rightarg = interval, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(interval, interval) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = macaddr_lt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(macaddr, macaddr) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = cash_lt, leftarg = money, rightarg = money, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(money, money) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = namelt, leftarg = name, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(name, name) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = numeric_lt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(numeric, numeric) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = oidvectorlt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(oidvector, oidvector) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = oidlt, leftarg = oid, rightarg = oid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(oid, oid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = range_lt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = rangesel);

comment on operator pg_catalog.<(anyrange, anyrange) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = jsonb_lt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(jsonb, jsonb) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = box_lt, leftarg = box, rightarg = box, commutator = pg_catalog.>, negator = pg_catalog.>=, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.<(box, box) is 'less than by area';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = circle_lt, leftarg = circle, rightarg = circle, commutator = pg_catalog.>, negator = pg_catalog.>=, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.<(circle, circle) is 'less than by area';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = lseg_lt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>, negator = pg_catalog.>=);

comment on operator pg_catalog.<(lseg, lseg) is 'less than by length';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(macaddr8, macaddr8) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = namelttext, leftarg = name, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(name, text) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = multirange_lt, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = multirangesel);

comment on operator pg_catalog.<(anymultirange, anymultirange) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(pg_lsn, pg_lsn) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = float48lt, leftarg = real, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(real, double precision) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = float4lt, leftarg = real, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(real, real) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = record_lt, leftarg = record, rightarg = record, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(record, record) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int28lt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(smallint, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int24lt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(smallint, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = int2lt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(smallint, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = textltname, leftarg = text, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(text, name) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = text_lt, leftarg = text, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(text, text) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = tidlt, leftarg = tid, rightarg = tid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(tid, tid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timetz_lt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(time with time zone, time with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamp_lt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = timestamp_lt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = time_lt, leftarg = time, rightarg = time, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(time, time) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = tsquery_lt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(tsquery, tsquery) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = tsvector_lt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(tsvector, tsvector) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = uuid_lt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(uuid, uuid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = xid8lt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.<(xid8, xid8) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = box_le, leftarg = box, rightarg = box, commutator = pg_catalog.>=, negator = pg_catalog.>, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.<=(box, box) is 'less than or equal by area';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = circle_le, leftarg = circle, rightarg = circle, commutator = pg_catalog.>=, negator = pg_catalog.>, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.<=(circle, circle) is 'less than or equal by area';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = lseg_le, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>=, negator = pg_catalog.>);

comment on operator pg_catalog.<=(lseg, lseg) is 'less than or equal by length';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = charle, leftarg = "char", rightarg = "char", commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=("char", "char") is 'less than or equal';

create operator pg_catalog.> (procedure = array_gt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(anyarray, anyarray) is 'greater than';

create operator pg_catalog.> (procedure = enum_gt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(anyenum, anyenum) is 'greater than';

create operator pg_catalog.> (procedure = multirange_gt, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = multirangesel);

comment on operator pg_catalog.>(anymultirange, anymultirange) is 'greater than';

create operator pg_catalog.> (procedure = range_gt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = rangesel);

comment on operator pg_catalog.>(anyrange, anyrange) is 'greater than';

create operator pg_catalog.> (procedure = int8gt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bigint, bigint) is 'greater than';

create operator pg_catalog.> (procedure = int84gt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bigint, integer) is 'greater than';

create operator pg_catalog.> (procedure = int82gt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bigint, smallint) is 'greater than';

create operator pg_catalog.> (procedure = varbitgt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bit varying, bit varying) is 'greater than';

create operator pg_catalog.> (procedure = bitgt, leftarg = bit, rightarg = bit, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bit, bit) is 'greater than';

create operator pg_catalog.> (procedure = boolgt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(boolean, boolean) is 'greater than';

create operator pg_catalog.> (procedure = box_gt, leftarg = box, rightarg = box, commutator = pg_catalog.<, negator = pg_catalog.<=, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.>(box, box) is 'greater than by area';

create operator pg_catalog.> (procedure = byteagt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(bytea, bytea) is 'greater than';

create operator pg_catalog.> (procedure = bpchargt, leftarg = char, rightarg = char, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(char, char) is 'greater than';

create operator pg_catalog.> (procedure = circle_gt, leftarg = circle, rightarg = circle, commutator = pg_catalog.<, negator = pg_catalog.<=, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.>(circle, circle) is 'greater than by area';

create operator pg_catalog.> (procedure = date_gt, leftarg = date, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(date, date) is 'greater than';

create operator pg_catalog.> (procedure = date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(date, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = date_gt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(date, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = float8gt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(double precision, double precision) is 'greater than';

create operator pg_catalog.> (procedure = float84gt, leftarg = double precision, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(double precision, real) is 'greater than';

create operator pg_catalog.> (procedure = network_gt, leftarg = inet, rightarg = inet, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(inet, inet) is 'greater than';

create operator pg_catalog.> (procedure = int48gt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(integer, bigint) is 'greater than';

create operator pg_catalog.> (procedure = int4gt, leftarg = integer, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(integer, integer) is 'greater than';

create operator pg_catalog.> (procedure = int42gt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(integer, smallint) is 'greater than';

create operator pg_catalog.> (procedure = interval_gt, leftarg = interval, rightarg = interval, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(interval, interval) is 'greater than';

create operator pg_catalog.> (procedure = jsonb_gt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(jsonb, jsonb) is 'greater than';

create operator pg_catalog.> (procedure = lseg_gt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<, negator = pg_catalog.<=);

comment on operator pg_catalog.>(lseg, lseg) is 'greater than by length';

create operator pg_catalog.> (procedure = macaddr_gt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(macaddr, macaddr) is 'greater than';

create operator pg_catalog.> (procedure = macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(macaddr8, macaddr8) is 'greater than';

create operator pg_catalog.> (procedure = cash_gt, leftarg = money, rightarg = money, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(money, money) is 'greater than';

create operator pg_catalog.> (procedure = namegt, leftarg = name, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(name, name) is 'greater than';

create operator pg_catalog.> (procedure = namegttext, leftarg = name, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(name, text) is 'greater than';

create operator pg_catalog.> (procedure = numeric_gt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(numeric, numeric) is 'greater than';

create operator pg_catalog.> (procedure = oidgt, leftarg = oid, rightarg = oid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(oid, oid) is 'greater than';

create operator pg_catalog.> (procedure = oidvectorgt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(oidvector, oidvector) is 'greater than';

create operator pg_catalog.>= (procedure = charge, leftarg = "char", rightarg = "char", commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=("char", "char") is 'greater than or equal';

create operator pg_catalog.<= (procedure = array_le, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(anyarray, anyarray) is 'less than or equal';

create operator pg_catalog.<= (procedure = enum_le, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(anyenum, anyenum) is 'less than or equal';

create operator pg_catalog.<= (procedure = multirange_le, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = multirangesel);

comment on operator pg_catalog.<=(anymultirange, anymultirange) is 'less than or equal';

create operator pg_catalog.<= (procedure = range_le, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = rangesel);

comment on operator pg_catalog.<=(anyrange, anyrange) is 'less than or equal';

create operator pg_catalog.<= (procedure = int8le, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bigint, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = int84le, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bigint, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = int82le, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bigint, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = varbitle, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bit varying, bit varying) is 'less than or equal';

create operator pg_catalog.<= (procedure = bitle, leftarg = bit, rightarg = bit, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bit, bit) is 'less than or equal';

create operator pg_catalog.<= (procedure = boolle, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(boolean, boolean) is 'less than or equal';

create operator pg_catalog.<= (procedure = byteale, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(bytea, bytea) is 'less than or equal';

create operator pg_catalog.<= (procedure = bpcharle, leftarg = char, rightarg = char, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(char, char) is 'less than or equal';

create operator pg_catalog.<= (procedure = date_le, leftarg = date, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(date, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(date, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = date_le_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(date, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = float8le, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(double precision, double precision) is 'less than or equal';

create operator pg_catalog.<= (procedure = float84le, leftarg = double precision, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(double precision, real) is 'less than or equal';

create operator pg_catalog.<= (procedure = network_le, leftarg = inet, rightarg = inet, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(inet, inet) is 'less than or equal';

create operator pg_catalog.<= (procedure = int48le, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(integer, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = int4le, leftarg = integer, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(integer, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = int42le, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(integer, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = interval_le, leftarg = interval, rightarg = interval, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(interval, interval) is 'less than or equal';

create operator pg_catalog.<= (procedure = jsonb_le, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(jsonb, jsonb) is 'less than or equal';

create operator pg_catalog.<= (procedure = macaddr_le, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(macaddr, macaddr) is 'less than or equal';

create operator pg_catalog.<= (procedure = macaddr8_le, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(macaddr8, macaddr8) is 'less than or equal';

create operator pg_catalog.<= (procedure = cash_le, leftarg = money, rightarg = money, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(money, money) is 'less than or equal';

create operator pg_catalog.<= (procedure = namele, leftarg = name, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(name, name) is 'less than or equal';

create operator pg_catalog.<= (procedure = nameletext, leftarg = name, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(name, text) is 'less than or equal';

create operator pg_catalog.<= (procedure = numeric_le, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(numeric, numeric) is 'less than or equal';

create operator pg_catalog.<= (procedure = oidle, leftarg = oid, rightarg = oid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(oid, oid) is 'less than or equal';

create operator pg_catalog.<= (procedure = oidvectorle, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(oidvector, oidvector) is 'less than or equal';

create operator pg_catalog.>= (procedure = array_ge, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(anyarray, anyarray) is 'greater than or equal';

create operator pg_catalog.>= (procedure = enum_ge, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(anyenum, anyenum) is 'greater than or equal';

create operator pg_catalog.>= (procedure = multirange_ge, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = multirangesel);

comment on operator pg_catalog.>=(anymultirange, anymultirange) is 'greater than or equal';

create operator pg_catalog.>= (procedure = range_ge, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = rangesel);

comment on operator pg_catalog.>=(anyrange, anyrange) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int8ge, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bigint, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int84ge, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bigint, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int82ge, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bigint, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = varbitge, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bit varying, bit varying) is 'greater than or equal';

create operator pg_catalog.>= (procedure = bitge, leftarg = bit, rightarg = bit, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bit, bit) is 'greater than or equal';

create operator pg_catalog.>= (procedure = boolge, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(boolean, boolean) is 'greater than or equal';

create operator pg_catalog.>= (procedure = box_ge, leftarg = box, rightarg = box, commutator = pg_catalog.<=, negator = pg_catalog.<, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.>=(box, box) is 'greater than or equal by area';

create operator pg_catalog.>= (procedure = byteage, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(bytea, bytea) is 'greater than or equal';

create operator pg_catalog.>= (procedure = bpcharge, leftarg = char, rightarg = char, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(char, char) is 'greater than or equal';

create operator pg_catalog.>= (procedure = circle_ge, leftarg = circle, rightarg = circle, commutator = pg_catalog.<=, negator = pg_catalog.<, join = areajoinsel, restrict = areasel);

comment on operator pg_catalog.>=(circle, circle) is 'greater than or equal by area';

create operator pg_catalog.>= (procedure = date_ge, leftarg = date, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(date, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(date, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = date_ge_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(date, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = float8ge, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(double precision, double precision) is 'greater than or equal';

create operator pg_catalog.>= (procedure = float84ge, leftarg = double precision, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(double precision, real) is 'greater than or equal';

create operator pg_catalog.>= (procedure = network_ge, leftarg = inet, rightarg = inet, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(inet, inet) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int48ge, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(integer, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int4ge, leftarg = integer, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(integer, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int42ge, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(integer, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = interval_ge, leftarg = interval, rightarg = interval, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(interval, interval) is 'greater than or equal';

create operator pg_catalog.>= (procedure = jsonb_ge, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(jsonb, jsonb) is 'greater than or equal';

create operator pg_catalog.>= (procedure = lseg_ge, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<=, negator = pg_catalog.<);

comment on operator pg_catalog.>=(lseg, lseg) is 'greater than or equal by length';

create operator pg_catalog.>= (procedure = macaddr_ge, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(macaddr, macaddr) is 'greater than or equal';

create operator pg_catalog.>= (procedure = macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(macaddr8, macaddr8) is 'greater than or equal';

create operator pg_catalog.>= (procedure = cash_ge, leftarg = money, rightarg = money, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(money, money) is 'greater than or equal';

create operator pg_catalog.>= (procedure = namege, leftarg = name, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(name, name) is 'greater than or equal';

create operator pg_catalog.>= (procedure = namegetext, leftarg = name, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(name, text) is 'greater than or equal';

create operator pg_catalog.>= (procedure = numeric_ge, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(numeric, numeric) is 'greater than or equal';

create operator pg_catalog.>= (procedure = oidge, leftarg = oid, rightarg = oid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(oid, oid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = oidvectorge, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(oidvector, oidvector) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn) is 'greater than or equal';

create operator pg_catalog.>= (procedure = float48ge, leftarg = real, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(real, double precision) is 'greater than or equal';

create operator pg_catalog.>= (procedure = float4ge, leftarg = real, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(real, real) is 'greater than or equal';

create operator pg_catalog.>= (procedure = record_ge, leftarg = record, rightarg = record, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(record, record) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int28ge, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(smallint, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int24ge, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(smallint, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = int2ge, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(smallint, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = textgename, leftarg = text, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(text, name) is 'greater than or equal';

create operator pg_catalog.>= (procedure = text_ge, leftarg = text, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(text, text) is 'greater than or equal';

create operator pg_catalog.>= (procedure = tidge, leftarg = tid, rightarg = tid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(tid, tid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timetz_ge, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(time with time zone, time with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = time_ge, leftarg = time, rightarg = time, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(time, time) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamp_ge_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = timestamp_ge, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = tsquery_ge, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(tsquery, tsquery) is 'greater than or equal';

create operator pg_catalog.>= (procedure = tsvector_ge, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(tsvector, tsvector) is 'greater than or equal';

create operator pg_catalog.>= (procedure = uuid_ge, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(uuid, uuid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = xid8ge, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.>=(xid8, xid8) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn) is 'less than or equal';

create operator pg_catalog.> (procedure = pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(pg_lsn, pg_lsn) is 'greater than';

create operator pg_catalog.<= (procedure = float48le, leftarg = real, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(real, double precision) is 'less than or equal';

create operator pg_catalog.<= (procedure = float4le, leftarg = real, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(real, real) is 'less than or equal';

create operator pg_catalog.<= (procedure = record_le, leftarg = record, rightarg = record, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(record, record) is 'less than or equal';

create operator pg_catalog.<= (procedure = int28le, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(smallint, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = int24le, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(smallint, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = int2le, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(smallint, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = textlename, leftarg = text, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(text, name) is 'less than or equal';

create operator pg_catalog.<= (procedure = text_le, leftarg = text, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(text, text) is 'less than or equal';

create operator pg_catalog.<= (procedure = tidle, leftarg = tid, rightarg = tid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(tid, tid) is 'less than or equal';

create operator pg_catalog.<= (procedure = timetz_le, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(time with time zone, time with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = time_le, leftarg = time, rightarg = time, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(time, time) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamp_le_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = timestamp_le, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = tsquery_le, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(tsquery, tsquery) is 'less than or equal';

create operator pg_catalog.<= (procedure = tsvector_le, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(tsvector, tsvector) is 'less than or equal';

create operator pg_catalog.<= (procedure = uuid_le, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(uuid, uuid) is 'less than or equal';

create operator pg_catalog.<= (procedure = xid8le, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.<=(xid8, xid8) is 'less than or equal';

create operator pg_catalog.> (procedure = float48gt, leftarg = real, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(real, double precision) is 'greater than';

create operator pg_catalog.> (procedure = float4gt, leftarg = real, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(real, real) is 'greater than';

create operator pg_catalog.> (procedure = record_gt, leftarg = record, rightarg = record, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(record, record) is 'greater than';

create operator pg_catalog.> (procedure = int28gt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(smallint, bigint) is 'greater than';

create operator pg_catalog.> (procedure = int24gt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(smallint, integer) is 'greater than';

create operator pg_catalog.> (procedure = int2gt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(smallint, smallint) is 'greater than';

create operator pg_catalog.> (procedure = textgtname, leftarg = text, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(text, name) is 'greater than';

create operator pg_catalog.> (procedure = text_gt, leftarg = text, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(text, text) is 'greater than';

create operator pg_catalog.> (procedure = tidgt, leftarg = tid, rightarg = tid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(tid, tid) is 'greater than';

create operator pg_catalog.> (procedure = timetz_gt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(time with time zone, time with time zone) is 'greater than';

create operator pg_catalog.> (procedure = time_gt, leftarg = time, rightarg = time, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(time, time) is 'greater than';

create operator pg_catalog.> (procedure = timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, date) is 'greater than';

create operator pg_catalog.> (procedure = timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = timestamp_gt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp, date) is 'greater than';

create operator pg_catalog.> (procedure = timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = timestamp_gt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = tsquery_gt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(tsquery, tsquery) is 'greater than';

create operator pg_catalog.> (procedure = tsvector_gt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(tsvector, tsvector) is 'greater than';

create operator pg_catalog.> (procedure = uuid_gt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(uuid, uuid) is 'greater than';

create operator pg_catalog.> (procedure = xid8gt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.>(xid8, xid8) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = bpchar_pattern_le, leftarg = char, rightarg = char, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.~<=~(char, char) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = bpchar_pattern_ge, leftarg = char, rightarg = char, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.~>=~(char, char) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = text_pattern_le, leftarg = text, rightarg = text, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = scalarlejoinsel, restrict = scalarlesel);

comment on operator pg_catalog.~<=~(text, text) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = bpchar_pattern_lt, leftarg = char, rightarg = char, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.~<~(char, char) is 'less than';

create operator pg_catalog.~>=~ (procedure = text_pattern_ge, leftarg = text, rightarg = text, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = scalargejoinsel, restrict = scalargesel);

comment on operator pg_catalog.~>=~(text, text) is 'greater than or equal';

create operator pg_catalog.~>~ (procedure = bpchar_pattern_gt, leftarg = char, rightarg = char, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.~>~(char, char) is 'greater than';

create operator pg_catalog.~<~ (procedure = text_pattern_lt, leftarg = text, rightarg = text, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = scalarltjoinsel, restrict = scalarltsel);

comment on operator pg_catalog.~<~(text, text) is 'less than';

create operator pg_catalog.~>~ (procedure = text_pattern_gt, leftarg = text, rightarg = text, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = scalargtjoinsel, restrict = scalargtsel);

comment on operator pg_catalog.~>~(text, text) is 'greater than';

-- Cyclic dependencies found

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(unknown) is 'date difference from today preserving months and years';

-- Cyclic dependencies found

create function pg_catalog.age(timestamp without time zone) returns interval
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(unknown) is 'date difference from today preserving months and years';

create function pg_catalog.age(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(unknown) is 'age of a transaction ID, in transactions before current transaction';

-- Cyclic dependencies found

create function pg_catalog.area(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(unknown) is 'area of a closed path';

-- Cyclic dependencies found

create function pg_catalog.area(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(unknown) is 'area of circle';

create function pg_catalog.area(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(unknown) is 'box area';

-- Cyclic dependencies found

create function pg_catalog.bit_length(bit) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(unknown) is 'length in bits';

-- Cyclic dependencies found

create function pg_catalog.bit_length(bytea) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(unknown) is 'length in bits';

create function pg_catalog.bit_length(text) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(unknown) is 'length in bits';

-- Cyclic dependencies found

create function pg_catalog.box(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(unknown) is 'convert circle to box';

-- Cyclic dependencies found

create function pg_catalog.box(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(unknown) is 'convert polygon to bounding box';

create function pg_catalog.box(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(unknown) is 'convert point to empty box';

-- Cyclic dependencies found

create function pg_catalog.date_trunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(unknown, unknown) is 'truncate interval to specified units';

-- Cyclic dependencies found

create function pg_catalog.date_trunc(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(unknown, unknown) is 'truncate timestamp to specified units';

create function pg_catalog.date_trunc(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(unknown, unknown) is 'truncate timestamp with time zone to specified units';

-- Cyclic dependencies found

create function pg_catalog.gcd(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(unknown, unknown) is 'greatest common divisor';

-- Cyclic dependencies found

create function pg_catalog.gcd(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(unknown, unknown) is 'greatest common divisor';

create function pg_catalog.gcd(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(unknown, unknown) is 'greatest common divisor';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown) is 'non-persistent series generator';

create function pg_catalog.generate_series(unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.jsonb_delete(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(unknown, unknown) is 'implementation of - operator';

-- Cyclic dependencies found

create function pg_catalog.jsonb_delete(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(unknown, unknown) is 'implementation of - operator';

create function pg_catalog.jsonb_delete(from_json unknown, path_elems unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(unknown, unknown) is 'implementation of - operator';

-- Cyclic dependencies found

create function pg_catalog.lcm(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(unknown, unknown) is 'least common multiple';

-- Cyclic dependencies found

create function pg_catalog.lcm(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(unknown, unknown) is 'least common multiple';

create function pg_catalog.lcm(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(unknown, unknown) is 'least common multiple';

-- Cyclic dependencies found

create function pg_catalog."like"(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(unknown, unknown) is 'matches LIKE expression';

-- Cyclic dependencies found

create function pg_catalog."like"(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(unknown, unknown) is 'matches LIKE expression';

create function pg_catalog."like"(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(unknown, unknown) is 'matches LIKE expression';

-- Cyclic dependencies found

create function pg_catalog.lower(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(unknown) is 'lowercase';

-- Cyclic dependencies found

create function pg_catalog.lower(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(unknown) is 'lower bound of range';

create function pg_catalog.lower(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(unknown) is 'lower bound of multirange';

-- Cyclic dependencies found

create function pg_catalog.money(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(unknown) is 'convert int4 to money';

-- Cyclic dependencies found

create function pg_catalog.money(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(unknown) is 'convert int8 to money';

create function pg_catalog.money(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(unknown) is 'convert numeric to money';

-- Cyclic dependencies found

create function pg_catalog.name(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(unknown) is 'convert char(n) to name';

-- Cyclic dependencies found

create function pg_catalog.name(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(unknown) is 'convert text to name';

create function pg_catalog.name(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(unknown) is 'convert varchar to name';

-- Cyclic dependencies found

create function pg_catalog.notlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(unknown, unknown) is 'does not match LIKE expression';

-- Cyclic dependencies found

create function pg_catalog.notlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(unknown, unknown) is 'does not match LIKE expression';

create function pg_catalog.notlike(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(unknown, unknown) is 'does not match LIKE expression';

-- Cyclic dependencies found

create function pg_catalog.overlay(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown) is 'substitute portion of bitstring';

-- Cyclic dependencies found

create function pg_catalog.overlay(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown) is 'substitute portion of string';

create function pg_catalog.overlay(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown) is 'substitute portion of string';

-- Cyclic dependencies found

create function pg_catalog.overlay(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown, unknown) is 'substitute portion of bitstring';

-- Cyclic dependencies found

create function pg_catalog.overlay(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown, unknown) is 'substitute portion of string';

create function pg_catalog.overlay(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(unknown, unknown, unknown, unknown) is 'substitute portion of string';

-- Cyclic dependencies found

create function pg_catalog.pg_get_viewdef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(unknown, unknown) is 'select statement of a view with pretty-print option';

-- Cyclic dependencies found

create function pg_catalog.pg_get_viewdef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(unknown, unknown) is 'select statement of a view with pretty-print option';

create function pg_catalog.pg_get_viewdef(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(unknown, unknown) is 'select statement of a view with pretty-printing and specified line wrapping';

-- Cyclic dependencies found

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(unknown) is 'convert circle to 12-vertex polygon';

-- Cyclic dependencies found

create function pg_catalog.polygon(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(unknown) is 'convert box to polygon';

create function pg_catalog.polygon(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(unknown) is 'convert path to polygon';

-- Cyclic dependencies found

create function pg_catalog.position(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(unknown, unknown) is 'position of sub-bitstring';

-- Cyclic dependencies found

create function pg_catalog.position(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(unknown, unknown) is 'position of substring';

create function pg_catalog.position(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(unknown, unknown) is 'position of substring';

-- Cyclic dependencies found

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(unknown, unknown) is 'convert date and time to timestamp with time zone';

-- Cyclic dependencies found

create function pg_catalog.timestamptz(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(unknown, unknown) is 'adjust timestamptz precision';

create function pg_catalog.timestamptz(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(unknown, unknown) is 'convert date and time with time zone to timestamp with time zone';

-- Cyclic dependencies found

create function pg_catalog.to_tsvector(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown, unknown) is 'transform to tsvector';

-- Cyclic dependencies found

create function pg_catalog.to_tsvector(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown, unknown) is 'transform string values from json to tsvector';

create function pg_catalog.to_tsvector(unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown, unknown) is 'transform string values from jsonb to tsvector';

-- Cyclic dependencies found

create function pg_catalog.to_tsvector(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown) is 'transform to tsvector';

-- Cyclic dependencies found

create function pg_catalog.to_tsvector(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown) is 'transform string values from json to tsvector';

create function pg_catalog.to_tsvector(unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(unknown) is 'transform string values from jsonb to tsvector';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) is 'generate headline';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) is 'generate headline from json';

create function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown, unknown) is 'generate headline from jsonb';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown) is 'generate headline';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown) is 'generate headline from json';

create function pg_catalog.ts_headline(unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown) is 'generate headline from jsonb';

-- Cyclic dependencies found

create function pg_catalog.unnest(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unnest(unknown) is 'expand array to set of rows';

-- Cyclic dependencies found

create function pg_catalog.unnest(tsvector unknown, out lexeme unknown, out positions unknown, out weights unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unnest(unknown, out unknown, out unknown, out unknown) is 'expand tsvector to set of rows';

create function pg_catalog.unnest(unknown) returns setof unknown
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unnest(unknown) is 'expand multirange to set of ranges';

-- Cyclic dependencies found

create function pg_catalog.upper(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(unknown) is 'uppercase';

-- Cyclic dependencies found

create function pg_catalog.upper(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(unknown) is 'upper bound of range';

create function pg_catalog.upper(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(unknown) is 'upper bound of multirange';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_and(unknown) (
    sfunc = int8and,
    stype = ???,
combinefunc = int8and
);

comment on aggregate pg_catalog.bit_and(unknown) is 'bitwise-and bigint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_and(unknown) (
    sfunc = bitand,
    stype = ???,
combinefunc = bitand
);

comment on aggregate pg_catalog.bit_and(unknown) is 'bitwise-and bit aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_and(unknown) (
    sfunc = int4and,
    stype = ???,
combinefunc = int4and
);

comment on aggregate pg_catalog.bit_and(unknown) is 'bitwise-and integer aggregate';

create aggregate pg_catalog.bit_and(unknown) (
    sfunc = int2and,
    stype = ???,
combinefunc = int2and
);

comment on aggregate pg_catalog.bit_and(unknown) is 'bitwise-and smallint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_or(unknown) (
    sfunc = int8or,
    stype = ???,
combinefunc = int8or
);

comment on aggregate pg_catalog.bit_or(unknown) is 'bitwise-or bigint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_or(unknown) (
    sfunc = bitor,
    stype = ???,
combinefunc = bitor
);

comment on aggregate pg_catalog.bit_or(unknown) is 'bitwise-or bit aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_or(unknown) (
    sfunc = int4or,
    stype = ???,
combinefunc = int4or
);

comment on aggregate pg_catalog.bit_or(unknown) is 'bitwise-or integer aggregate';

create aggregate pg_catalog.bit_or(unknown) (
    sfunc = int2or,
    stype = ???,
combinefunc = int2or
);

comment on aggregate pg_catalog.bit_or(unknown) is 'bitwise-or smallint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_xor(unknown) (
    sfunc = int8xor,
    stype = ???,
combinefunc = int8xor
);

comment on aggregate pg_catalog.bit_xor(unknown) is 'bitwise-xor bigint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_xor(unknown) (
    sfunc = bitxor,
    stype = ???,
combinefunc = bitxor
);

comment on aggregate pg_catalog.bit_xor(unknown) is 'bitwise-xor bit aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bit_xor(unknown) (
    sfunc = int4xor,
    stype = ???,
combinefunc = int4xor
);

comment on aggregate pg_catalog.bit_xor(unknown) is 'bitwise-xor integer aggregate';

create aggregate pg_catalog.bit_xor(unknown) (
    sfunc = int2xor,
    stype = ???,
combinefunc = int2xor
);

comment on aggregate pg_catalog.bit_xor(unknown) is 'bitwise-xor smallint aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.percentile_cont(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_float8_final
);

comment on aggregate pg_catalog.percentile_cont(unknown, unknown) is 'continuous distribution percentile';

-- Cyclic dependencies found

create aggregate pg_catalog.percentile_cont(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_interval_final
);

comment on aggregate pg_catalog.percentile_cont(unknown, unknown) is 'continuous distribution percentile';

-- Cyclic dependencies found

create aggregate pg_catalog.percentile_cont(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_float8_multi_final
);

comment on aggregate pg_catalog.percentile_cont(unknown, unknown) is 'multiple continuous percentiles';

create aggregate pg_catalog.percentile_cont(unknown, unknown) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_interval_multi_final
);

comment on aggregate pg_catalog.percentile_cont(unknown, unknown) is 'multiple continuous percentiles';

-- Cyclic dependencies found

create function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) is 'user privilege on any column by user oid, rel name';

-- Cyclic dependencies found

create function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) is 'user privilege on any column by user oid, rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) is 'user privilege on any column by username, rel name';

create function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(unknown, unknown, unknown) is 'user privilege on any column by username, rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown) is 'current user privilege on column by rel name, col attnum';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown) is 'current user privilege on column by rel name, col name';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown) is 'current user privilege on column by rel oid, col attnum';

create function pg_catalog.has_column_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown) is 'current user privilege on column by rel oid, col name';

-- Cyclic dependencies found

create function pg_catalog.has_database_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown, unknown) is 'user privilege on database by user oid, database name';

-- Cyclic dependencies found

create function pg_catalog.has_database_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown, unknown) is 'user privilege on database by user oid, database oid';

-- Cyclic dependencies found

create function pg_catalog.has_database_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown, unknown) is 'user privilege on database by username, database name';

create function pg_catalog.has_database_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(unknown, unknown, unknown) is 'user privilege on database by username, database oid';

-- Cyclic dependencies found

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

-- Cyclic dependencies found

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

-- Cyclic dependencies found

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(unknown, unknown, unknown) is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

-- Cyclic dependencies found

create function pg_catalog.has_function_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown, unknown) is 'user privilege on function by user oid, function name';

-- Cyclic dependencies found

create function pg_catalog.has_function_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown, unknown) is 'user privilege on function by user oid, function oid';

-- Cyclic dependencies found

create function pg_catalog.has_function_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown, unknown) is 'user privilege on function by username, function name';

create function pg_catalog.has_function_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(unknown, unknown, unknown) is 'user privilege on function by username, function oid';

-- Cyclic dependencies found

create function pg_catalog.has_language_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown, unknown) is 'user privilege on language by user oid, language name';

-- Cyclic dependencies found

create function pg_catalog.has_language_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown, unknown) is 'user privilege on language by user oid, language oid';

-- Cyclic dependencies found

create function pg_catalog.has_language_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown, unknown) is 'user privilege on language by username, language name';

create function pg_catalog.has_language_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(unknown, unknown, unknown) is 'user privilege on language by username, language oid';

-- Cyclic dependencies found

create function pg_catalog.has_schema_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown, unknown) is 'user privilege on schema by user oid, schema name';

-- Cyclic dependencies found

create function pg_catalog.has_schema_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown, unknown) is 'user privilege on schema by user oid, schema oid';

-- Cyclic dependencies found

create function pg_catalog.has_schema_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown, unknown) is 'user privilege on schema by username, schema name';

create function pg_catalog.has_schema_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(unknown, unknown, unknown) is 'user privilege on schema by username, schema oid';

-- Cyclic dependencies found

create function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) is 'user privilege on sequence by user oid, seq name';

-- Cyclic dependencies found

create function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) is 'user privilege on sequence by user oid, seq oid';

-- Cyclic dependencies found

create function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) is 'user privilege on sequence by username, seq name';

create function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(unknown, unknown, unknown) is 'user privilege on sequence by username, seq oid';

-- Cyclic dependencies found

create function pg_catalog.has_server_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown, unknown) is 'user privilege on server by user oid, server name';

-- Cyclic dependencies found

create function pg_catalog.has_server_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown, unknown) is 'user privilege on server by user oid, server oid';

-- Cyclic dependencies found

create function pg_catalog.has_server_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown, unknown) is 'user privilege on server by username, server name';

create function pg_catalog.has_server_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(unknown, unknown, unknown) is 'user privilege on server by username, server oid';

-- Cyclic dependencies found

create function pg_catalog.has_table_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown, unknown) is 'user privilege on relation by user oid, rel name';

-- Cyclic dependencies found

create function pg_catalog.has_table_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown, unknown) is 'user privilege on relation by user oid, rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_table_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown, unknown) is 'user privilege on relation by username, rel name';

create function pg_catalog.has_table_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(unknown, unknown, unknown) is 'user privilege on relation by username, rel oid';

-- Cyclic dependencies found

create function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) is 'user privilege on tablespace by user oid, tablespace name';

-- Cyclic dependencies found

create function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) is 'user privilege on tablespace by user oid, tablespace oid';

-- Cyclic dependencies found

create function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) is 'user privilege on tablespace by username, tablespace name';

create function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(unknown, unknown, unknown) is 'user privilege on tablespace by username, tablespace oid';

-- Cyclic dependencies found

create function pg_catalog.has_type_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown, unknown) is 'user privilege on type by user oid, type name';

-- Cyclic dependencies found

create function pg_catalog.has_type_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown, unknown) is 'user privilege on type by user oid, type oid';

-- Cyclic dependencies found

create function pg_catalog.has_type_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown, unknown) is 'user privilege on type by username, type name';

create function pg_catalog.has_type_privilege(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(unknown, unknown, unknown) is 'user privilege on type by username, type oid';

-- Cyclic dependencies found

create function pg_catalog.isfinite(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(unknown) is 'finite date?';

-- Cyclic dependencies found

create function pg_catalog.isfinite(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(unknown) is 'finite interval?';

-- Cyclic dependencies found

create function pg_catalog.isfinite(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(unknown) is 'finite timestamp?';

create function pg_catalog.isfinite(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(unknown) is 'finite timestamp?';

-- Cyclic dependencies found

create function pg_catalog.mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(unknown, unknown) is 'modulus';

-- Cyclic dependencies found

create function pg_catalog.mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(unknown, unknown) is 'modulus';

-- Cyclic dependencies found

create function pg_catalog.mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(unknown, unknown) is 'modulus';

create function pg_catalog.mod(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(unknown, unknown) is 'modulus';

-- Cyclic dependencies found

create function pg_catalog.octet_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(unknown) is 'octet length';

-- Cyclic dependencies found

create function pg_catalog.octet_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(unknown) is 'octet length';

-- Cyclic dependencies found

create function pg_catalog.octet_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(unknown) is 'octet length';

create function pg_catalog.octet_length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(unknown) is 'octet length';

-- Cyclic dependencies found

create function pg_catalog.pg_has_role(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown, unknown) is 'user privilege on role by user oid, role name';

-- Cyclic dependencies found

create function pg_catalog.pg_has_role(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown, unknown) is 'user privilege on role by user oid, role oid';

-- Cyclic dependencies found

create function pg_catalog.pg_has_role(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown, unknown) is 'user privilege on role by username, role name';

create function pg_catalog.pg_has_role(unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(unknown, unknown, unknown) is 'user privilege on role by username, role oid';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown) is 'extract portion of bitstring';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown) is 'extract portion of string';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown) is 'extract portion of string';

create function pg_catalog.substring(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown) is 'extract text matching regular expression';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown, unknown) is 'extract portion of bitstring';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown, unknown) is 'extract portion of string';

-- Cyclic dependencies found

create function pg_catalog.substring(unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown, unknown) is 'extract portion of string';

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(unknown, unknown, unknown) is 'extract text matching SQL regular expression';

-- Cyclic dependencies found

create function pg_catalog.time(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(unknown) is 'convert interval to time';

-- Cyclic dependencies found

create function pg_catalog.time(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(unknown) is 'convert time with time zone to time';

-- Cyclic dependencies found

create function pg_catalog.time(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(unknown) is 'convert timestamp to time';

create function pg_catalog.time(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(unknown) is 'convert timestamp with time zone to time';

-- Cyclic dependencies found

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(unknown) is 'value truncated to ''scale'' of zero';

-- Cyclic dependencies found

create function pg_catalog.trunc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(unknown) is 'truncate to integer';

-- Cyclic dependencies found

create function pg_catalog.trunc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(unknown) is 'MACADDR manufacturer fields';

create function pg_catalog.trunc(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(unknown) is 'MACADDR8 manufacturer fields';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.generate_series(unknown, unknown, unknown) returns setof unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown, unknown) is 'non-persistent series generator';

create function pg_catalog.generate_series(unknown, unknown, unknown) returns setof unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series(unknown, unknown, unknown) is 'non-persistent series generator';

-- Cyclic dependencies found

create function pg_catalog.point(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown) is 'center of';

-- Cyclic dependencies found

create function pg_catalog.point(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown) is 'center of';

-- Cyclic dependencies found

create function pg_catalog.point(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown) is 'center of';

-- Cyclic dependencies found

create function pg_catalog.point(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown) is 'center of';

create function pg_catalog.point(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(unknown) is 'center of';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(unknown) is 'historical alias for stddev_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of numeric input values';

create aggregate pg_catalog.stddev_pop(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(unknown) is 'population standard deviation of smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of numeric input values';

create aggregate pg_catalog.stddev_samp(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(unknown) is 'sample standard deviation of smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of bigint input values (square of the population standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of float4 input values (square of the population standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of float8 input values (square of the population standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of integer input values (square of the population standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of numeric input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(unknown) is 'population variance of smallint input values (square of the population standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of bigint input values (square of the sample standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of float4 input values (square of the sample standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of float8 input values (square of the sample standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of integer input values (square of the sample standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of numeric input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(unknown) is 'sample variance of smallint input values (square of the sample standard deviation)';

-- Cyclic dependencies found

create aggregate pg_catalog.variance(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.variance(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.variance(unknown) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.variance(unknown) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

-- Cyclic dependencies found

create aggregate pg_catalog.variance(unknown) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(unknown) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(unknown) is 'historical alias for var_samp';

-- Cyclic dependencies found

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

-- Cyclic dependencies found

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

-- Cyclic dependencies found

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

-- Cyclic dependencies found

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

-- Cyclic dependencies found

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

create function pg_catalog.abs(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(unknown) is 'absolute value';

-- Cyclic dependencies found

create function pg_catalog.date_part(text, date) returns double precision
    immutable
    strict
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from date';

-- Cyclic dependencies found

create function pg_catalog.date_part(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from interval';

-- Cyclic dependencies found

create function pg_catalog.date_part(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from time';

-- Cyclic dependencies found

create function pg_catalog.date_part(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from time with time zone';

-- Cyclic dependencies found

create function pg_catalog.date_part(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from timestamp';

create function pg_catalog.date_part(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(unknown, unknown) is 'extract field from timestamp with time zone';

-- Cyclic dependencies found

create function pg_catalog.extract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from date';

-- Cyclic dependencies found

create function pg_catalog.extract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from interval';

-- Cyclic dependencies found

create function pg_catalog.extract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from time';

-- Cyclic dependencies found

create function pg_catalog.extract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from time with time zone';

-- Cyclic dependencies found

create function pg_catalog.extract(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from timestamp';

create function pg_catalog.extract(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(unknown, unknown) is 'extract field from timestamp with time zone';

-- Cyclic dependencies found

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert float8 to float4';

-- Cyclic dependencies found

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert int2 to float4';

-- Cyclic dependencies found

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert int4 to float4';

-- Cyclic dependencies found

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert int8 to float4';

-- Cyclic dependencies found

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert numeric to float4';

create function pg_catalog.float4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(unknown) is 'convert jsonb to float4';

-- Cyclic dependencies found

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert float4 to float8';

-- Cyclic dependencies found

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert int2 to float8';

-- Cyclic dependencies found

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert int4 to float8';

-- Cyclic dependencies found

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert int8 to float8';

-- Cyclic dependencies found

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert numeric to float8';

create function pg_catalog.float8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(unknown) is 'convert jsonb to float8';

-- Cyclic dependencies found

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert float4 to int2';

-- Cyclic dependencies found

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert float8 to int2';

-- Cyclic dependencies found

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert int4 to int2';

-- Cyclic dependencies found

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert int8 to int2';

-- Cyclic dependencies found

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert numeric to int2';

create function pg_catalog.int2(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(unknown) is 'convert jsonb to int2';

-- Cyclic dependencies found

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'convert boolean to text';

-- Cyclic dependencies found

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'convert char to text';

-- Cyclic dependencies found

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'convert char(n) to text';

-- Cyclic dependencies found

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'convert name to text';

-- Cyclic dependencies found

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'serialize an XML value to a character string';

create function pg_catalog.text(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(unknown) is 'show all parts of inet/cidr value';

-- Cyclic dependencies found

create function pg_catalog.timezone(unknown, unknown) returns unknown
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust time with time zone to new zone';

-- Cyclic dependencies found

create function pg_catalog.timezone(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust time with time zone to new zone';

-- Cyclic dependencies found

create function pg_catalog.timezone(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust timestamp to new time zone';

-- Cyclic dependencies found

create function pg_catalog.timezone(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust timestamp to new time zone';

-- Cyclic dependencies found

create function pg_catalog.timezone(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust timestamp to new time zone';

create function pg_catalog.timezone(unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(unknown, unknown) is 'adjust timestamp to new time zone';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline from json';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline from json';

-- Cyclic dependencies found

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline from jsonb';

create function pg_catalog.ts_headline(unknown, unknown, unknown) returns unknown
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(unknown, unknown, unknown) is 'generate headline from jsonb';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_avg,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as float8 of all float4 values';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_avg,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as float8 of all float8 values';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = interval_accum,
    stype = ???,
finalfunc = interval_avg,
combinefunc = interval_combine,
msfunc = interval_accum,
minvfunc = interval_accum_inv,
mfinalfunc = interval_avg
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as interval of all interval values';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = int8_avg_accum,
    stype = ???,
finalfunc = numeric_poly_avg,
combinefunc = int8_avg_combine,
serialfunc = int8_avg_serialize,
deserialfunc = int8_avg_deserialize,
msfunc = int8_avg_accum,
minvfunc = int8_avg_accum_inv,
mfinalfunc = numeric_poly_avg
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as numeric of all bigint values';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = int4_avg_accum,
    stype = ???,
finalfunc = int8_avg,
combinefunc = int4_avg_combine,
msfunc = int4_avg_accum,
minvfunc = int4_avg_accum_inv,
mfinalfunc = int8_avg
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as numeric of all integer values';

-- Cyclic dependencies found

create aggregate pg_catalog.avg(unknown) (
    sfunc = numeric_avg_accum,
    stype = ???,
finalfunc = numeric_avg,
combinefunc = numeric_avg_combine,
serialfunc = numeric_avg_serialize,
deserialfunc = numeric_avg_deserialize,
msfunc = numeric_avg_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_avg
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as numeric of all numeric values';

create aggregate pg_catalog.avg(unknown) (
    sfunc = int2_avg_accum,
    stype = ???,
finalfunc = int8_avg,
combinefunc = int4_avg_combine,
msfunc = int2_avg_accum,
minvfunc = int2_avg_accum_inv,
mfinalfunc = int8_avg
);

comment on aggregate pg_catalog.avg(unknown) is 'the average (arithmetic mean) as numeric of all smallint values';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'bitstring length';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'character length';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'distance between endpoints';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'length';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'number of lexemes';

-- Cyclic dependencies found

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'octet length';

create function pg_catalog.length(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(unknown) is 'sum of path segments';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert float4 to numeric';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert float8 to numeric';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert int2 to numeric';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert int4 to numeric';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert int8 to numeric';

-- Cyclic dependencies found

create function pg_catalog.numeric(unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert money to numeric';

create function pg_catalog.numeric(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(unknown) is 'convert jsonb to numeric';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = int4_sum,
    stype = ???,
combinefunc = int8pl,
msfunc = int4_avg_accum,
minvfunc = int4_avg_accum_inv,
mfinalfunc = int2int4_sum
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as bigint across all integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = int2_sum,
    stype = ???,
combinefunc = int8pl,
msfunc = int2_avg_accum,
minvfunc = int2_avg_accum_inv,
mfinalfunc = int2int4_sum
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as bigint across all smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = float4pl,
    stype = ???,
combinefunc = float4pl
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as float4 across all float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = float8pl,
    stype = ???,
combinefunc = float8pl
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as float8 across all float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = interval_pl,
    stype = ???,
combinefunc = interval_pl,
msfunc = interval_pl,
minvfunc = interval_mi
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as interval across all interval input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = cash_pl,
    stype = ???,
combinefunc = cash_pl,
msfunc = cash_pl,
minvfunc = cash_mi
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as money across all money input values';

-- Cyclic dependencies found

create aggregate pg_catalog.sum(unknown) (
    sfunc = int8_avg_accum,
    stype = ???,
finalfunc = numeric_poly_sum,
combinefunc = int8_avg_combine,
serialfunc = int8_avg_serialize,
deserialfunc = int8_avg_deserialize,
msfunc = int8_avg_accum,
minvfunc = int8_avg_accum_inv,
mfinalfunc = numeric_poly_sum
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as numeric across all bigint input values';

create aggregate pg_catalog.sum(unknown) (
    sfunc = numeric_avg_accum,
    stype = ???,
finalfunc = numeric_sum,
combinefunc = numeric_avg_combine,
serialfunc = numeric_avg_serialize,
deserialfunc = numeric_avg_deserialize,
msfunc = numeric_avg_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_sum
);

comment on aggregate pg_catalog.sum(unknown) is 'sum as numeric across all numeric input values';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by user oid, rel name, col attnum';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by user oid, rel name, col name';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by user oid, rel oid, col attnum';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by user oid, rel oid, col name';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by username, rel name, col attnum';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by username, rel name, col name';

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by username, rel oid, col attnum';

create function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(unknown, unknown, unknown, unknown) is 'user privilege on column by username, rel oid, col name';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert float4 to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert float8 to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert int2 to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert int4 to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert oid to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert bitstring to int8';

-- Cyclic dependencies found

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert numeric to int8';

create function pg_catalog.int8(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(unknown) is 'convert jsonb to int8';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format float4 to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format float8 to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format int4 to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format int8 to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format interval to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format numeric to text';

-- Cyclic dependencies found

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format timestamp to text';

create function pg_catalog.to_char(unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(unknown, unknown) is 'format timestamp with time zone to text';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert boolean to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert char to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert float4 to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert float8 to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert int2 to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert int8 to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert bitstring to int4';

-- Cyclic dependencies found

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert numeric to int4';

create function pg_catalog.int4(unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(unknown) is 'convert jsonb to int4';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    stable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) returns boolean
    stable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) returns boolean
    stable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, timestamp without time zone) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

create function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) returns unknown
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(unknown, unknown, unknown, unknown) is 'intervals overlap?';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

create function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) returns unknown
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(unknown, unknown, unknown, unknown, unknown) is 'window RANGE support';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = array_larger,
    stype = ???,
combinefunc = array_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all anyarray input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = int8larger,
    stype = ???,
combinefunc = int8larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = bpchar_larger,
    stype = ???,
combinefunc = bpchar_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all bpchar input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = date_larger,
    stype = ???,
combinefunc = date_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all date input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = enum_larger,
    stype = ???,
combinefunc = enum_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all enum input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = float4larger,
    stype = ???,
combinefunc = float4larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = float8larger,
    stype = ???,
combinefunc = float8larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = network_larger,
    stype = ???,
combinefunc = network_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all inet input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = int4larger,
    stype = ???,
combinefunc = int4larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = interval_larger,
    stype = ???,
combinefunc = interval_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all interval input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = cashlarger,
    stype = ???,
combinefunc = cashlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all money input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = numeric_larger,
    stype = ???,
combinefunc = numeric_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all numeric input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = oidlarger,
    stype = ???,
combinefunc = oidlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all oid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = int2larger,
    stype = ???,
combinefunc = int2larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = text_larger,
    stype = ???,
combinefunc = text_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all text input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = tidlarger,
    stype = ???,
combinefunc = tidlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all tid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = time_larger,
    stype = ???,
combinefunc = time_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all time input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = timetz_larger,
    stype = ???,
combinefunc = timetz_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all time with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = timestamp_larger,
    stype = ???,
combinefunc = timestamp_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all timestamp input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(unknown) (
    sfunc = timestamptz_larger,
    stype = ???,
combinefunc = timestamptz_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all timestamp with time zone input values';

create aggregate pg_catalog.max(unknown) (
    sfunc = pg_lsn_larger,
    stype = ???,
combinefunc = pg_lsn_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(unknown) is 'maximum value of all pg_lsn input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = array_smaller,
    stype = ???,
combinefunc = array_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all anyarray input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = int8smaller,
    stype = ???,
combinefunc = int8smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = bpchar_smaller,
    stype = ???,
combinefunc = bpchar_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all bpchar input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = date_smaller,
    stype = ???,
combinefunc = date_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all date input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = enum_smaller,
    stype = ???,
combinefunc = enum_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all enum input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = float4smaller,
    stype = ???,
combinefunc = float4smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = float8smaller,
    stype = ???,
combinefunc = float8smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = network_smaller,
    stype = ???,
combinefunc = network_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all inet input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = int4smaller,
    stype = ???,
combinefunc = int4smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = interval_smaller,
    stype = ???,
combinefunc = interval_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all interval input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = cashsmaller,
    stype = ???,
combinefunc = cashsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all money input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = numeric_smaller,
    stype = ???,
combinefunc = numeric_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all numeric input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = oidsmaller,
    stype = ???,
combinefunc = oidsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all oid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = int2smaller,
    stype = ???,
combinefunc = int2smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = text_smaller,
    stype = ???,
combinefunc = text_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all text values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = tidsmaller,
    stype = ???,
combinefunc = tidsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all tid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = time_smaller,
    stype = ???,
combinefunc = time_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all time input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = timetz_smaller,
    stype = ???,
combinefunc = timetz_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all time with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = timestamp_smaller,
    stype = ???,
combinefunc = timestamp_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all timestamp input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(unknown) (
    sfunc = timestamptz_smaller,
    stype = ???,
combinefunc = timestamptz_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all timestamp with time zone input values';

create aggregate pg_catalog.min(unknown) (
    sfunc = pg_lsn_smaller,
    stype = ???,
combinefunc = pg_lsn_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(unknown) is 'minimum value of all pg_lsn input values';

